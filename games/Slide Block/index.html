<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>ã‚¢ã‚¤ã‚·ãƒ†ãƒ«ãƒ‹ã‚¤ã‚¬ã‚¿ãƒ‘ã‚ºãƒ«</title>
  <style>
    :root{
      --bg:#f4f4f4;
      --panel:#ffffff;
      --text:#333;
      --muted:#777;

      --wood-frame:#8b5a2b;
      --wood-light:#dcb386;
      --wood-block:#e8c39e;

      --accent:#d32f2f;
      --ok:#2e7d32;

      --shadow:0 6px 16px rgba(0,0,0,.10);
      --radius:16px;

      --cell:86px;           /* JSå´ã§ã‚‚ä½¿ã† */
      --gap:6px;             /* ãƒ–ãƒ­ãƒƒã‚¯é–“ã®è¦‹ãŸç›®éš™é–“ */
      --inner-pad:10px;      /* ç›¤é¢å†…å´ã®æ ä½™ç™½ */
      --frame-thick:10px;    /* å¤–æ å¤ªã• */
    }

    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN","Meiryo",sans-serif;
      background:var(--bg);
      color:var(--text);
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{
      max-width:720px;
      margin:0 auto;
      padding:14px 14px 28px;
    }

    h1{
      margin:10px 0 12px;
      font-size:28px;
      letter-spacing:.02em;
      text-align:center;
      color:#444;
      font-weight:800;
    }

    .panel{
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:12px;
      margin:12px 0;
    }

    /* ====== Sound Panel ====== */
    .sound-row{
      display:grid;
      grid-template-columns: 140px 1fr 34px;
      gap:10px;
      align-items:center;
      margin:10px 0;
    }
    .toggle{
      border:none;
      border-radius:999px;
      padding:10px 12px;
      font-weight:800;
      cursor:pointer;
      box-shadow:0 3px 10px rgba(0,0,0,.08);
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    .toggle.off{
      background:#f0f0f0;
      color:#666;
    }
    .toggle.on{
      background:var(--accent);
      color:#fff;
    }
    .toggle.bgm.on{
      background:#e9eef6;
      color:#2a4a7a;
      box-shadow:0 3px 10px rgba(0,0,0,.06);
      border:1px solid rgba(42,74,122,.15);
    }

    input[type="range"]{
      width:100%;
      accent-color:#1e88e5;
    }
    .vol-num{
      font-weight:800;
      color:#444;
      text-align:right;
      width:34px;
    }

    /* ====== Mode Buttons ====== */
    .modes{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:8px;
    }
    .mode-btn{
      border:none;
      border-radius:12px;
      padding:12px 10px;
      font-weight:900;
      font-size:18px;
      cursor:pointer;
      box-shadow:0 4px 14px rgba(0,0,0,.10);
      background:#eaeaea;
      color:#555;
      user-select:none;
    }
    .mode-btn.active{
      background:#fff;
      color:var(--accent);
      outline:2px solid rgba(211,47,47,.25);
    }

    /* ====== Score Row ====== */
    .score-row{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:10px;
      padding:8px 4px 2px;
      font-weight:900;
    }
    .score-row .big{
      font-size:28px;
      color:var(--accent);
    }
    .score-row .min{
      font-size:24px;
      color:var(--accent);
    }
    .score-row .label{
      font-size:18px;
      color:#444;
      font-weight:900;
    }

    /* ====== Board Area ====== */
    .board-area{
      position:relative;
      width:100%;
      margin-top:8px;
      /* height ã¯ JS ã§ç¢ºå®š */
    }
    .board-scale{
      position:absolute;
      left:50%;
      top:0;
      transform:translateX(-50%) scale(1);
      transform-origin: top center;
      will-change: transform;
    }

    .board-frame{
      position:relative;
      background:var(--wood-frame);
      border-radius:14px;
      padding:var(--frame-thick);
      box-shadow:0 10px 20px rgba(0,0,0,.16);
      user-select:none;
    }

    .board-inner{
      position:relative;
      background:var(--wood-light);
      border-radius:12px;
      padding:var(--inner-pad);
    }

    .grid-bg{
      position:absolute;
      inset:var(--inner-pad);
      border-radius:10px;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,.18), rgba(255,255,255,.18) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) calc(var(--cell))),
        repeating-linear-gradient(90deg, rgba(255,255,255,.18), rgba(255,255,255,.18) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) calc(var(--cell)));
      pointer-events:none;
      opacity:.25;
    }

    .cells-bg{
      position:absolute;
      inset:var(--inner-pad);
      border-radius:10px;
      background:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.20), transparent 55%),
        radial-gradient(circle at 80% 70%, rgba(0,0,0,.08), transparent 50%),
        repeating-linear-gradient(45deg, rgba(0,0,0,.10) 0 12px, rgba(0,0,0,.14) 12px 24px);
      pointer-events:none;
      opacity:.26;
    }

    .goal-badge{
      position:absolute;
      left:var(--inner-pad);
      top:var(--inner-pad);
      width:calc(var(--cell) * 2);
      height:calc(var(--cell) * 2);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      color:#fff;
      background:linear-gradient(135deg, rgba(211,47,47,.92), rgba(211,47,47,.60));
      text-shadow:0 2px 6px rgba(0,0,0,.25);
      pointer-events:none;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.25);
      opacity:.95;
    }

    .block{
      position:absolute;
      border-radius:10px;
      box-shadow: 0 8px 14px rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      letter-spacing:.04em;
      touch-action:none;
      cursor:grab;
      overflow:hidden;
      user-select:none;
      transform: translate3d(0,0,0);
    }

    .block:active{ cursor:grabbing; }

    .block .id{
      position:absolute;
      left:8px;
      top:6px;
      font-size:14px;
      opacity:.55;
      font-weight:900;
      text-shadow:none;
      pointer-events:none;
    }

    .block .name{
      padding:6px 8px;
      line-height:1.05;
      text-align:center;
      white-space:nowrap; /* åŸºæœ¬ã¯æŠ˜ã‚Šè¿”ã—ç¦æ­¢ */
    }

    /* 1x1ç­‰ã§ç¸¦ã«ã—ãŸã„å ´åˆ */
    .vtext{
      writing-mode: vertical-rl;
      text-orientation: upright;
      letter-spacing: 0;
      white-space:normal;
      line-height:1.00;
    }

    /* ====== Controls ====== */
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    .btn{
      border:none;
      border-radius:14px;
      padding:14px 10px;
      font-weight:1000;
      font-size:18px;
      cursor:pointer;
      box-shadow:0 4px 14px rgba(0,0,0,.12);
      background:#e9e9e9;
      color:#666;
      user-select:none;
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
    }
    .btn.primary{
      grid-column: 1 / -1;
      background:var(--ok);
      color:#fff;
      font-size:20px;
      padding:16px 10px;
    }

    .sub-controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      margin-top:10px;
    }
    .pill{
      border:none;
      border-radius:999px;
      padding:10px 14px;
      font-weight:900;
      cursor:pointer;
      background:#f0f0f0;
      box-shadow:0 3px 10px rgba(0,0,0,.08);
      user-select:none;
    }

    /* ====== Solver Overlay ====== */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.35);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:999;
      padding:16px;
    }
    .overlay .card{
      width:min(520px, 100%);
      background:#fff;
      border-radius:18px;
      box-shadow:0 20px 40px rgba(0,0,0,.25);
      padding:16px 16px 14px;
    }
    .overlay .title{
      font-weight:1000;
      font-size:18px;
      margin-bottom:6px;
    }
    .overlay .info{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:13px;
      color:#333;
      background:#f6f6f6;
      border-radius:12px;
      padding:10px;
      white-space:pre-wrap;
      min-height:56px;
    }
    .overlay .cancel{
      margin-top:10px;
      width:100%;
      border:none;
      border-radius:14px;
      padding:12px 10px;
      font-weight:1000;
      cursor:pointer;
      background:#efefef;
    }

    /* confetti canvas */
    #confettiCanvas{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:998;
      display:none;
    }

    .foot{
      margin-top:12px;
      text-align:center;
      color:var(--muted);
      font-weight:800;
      font-size:14px;
    }
  </style>
</head>
<body>
  <canvas id="confettiCanvas"></canvas>

  <div class="wrap">
    <h1>ã‚¢ã‚¤ã‚·ãƒ†ãƒ«ãƒ‹ã‚¤ã‚¬ã‚¿ãƒ‘ã‚ºãƒ«</h1>

    <div class="panel" id="soundPanel">
      <div class="sound-row">
        <button class="toggle bgm off" id="bgmToggle">â™ª BGM: OFF</button>
        <input type="range" id="bgmVol" min="0" max="10" step="1" value="5" />
        <div class="vol-num" id="bgmVolNum">5</div>
      </div>
      <div class="sound-row">
        <button class="toggle on" id="seToggle">ğŸ“£ åŠ¹æœéŸ³: ON</button>
        <input type="range" id="seVol" min="0" max="10" step="1" value="5" />
        <div class="vol-num" id="seVolNum">5</div>
      </div>

      <div class="modes">
        <button class="mode-btn active" id="modePromote">ç›®æŒ‡ã›!J1æ˜‡æ ¼</button>
        <button class="mode-btn" id="modeChamp">ç›®æŒ‡ã›!J1å„ªå‹</button>
      </div>

      <div class="score-row">
        <div>
          <span class="label">æ‰‹æ•°:</span>
          <span class="big" id="movesCount">0</span>
        </div>
        <div>
          <span class="label">æœ€å°‘:</span>
          <span class="min" id="minMoves">-</span>
        </div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex; align-items:center; gap:8px; font-weight:1000;">
        <span id="modeLabel">â–¼ ç›®æŒ‡ã›!J1æ˜‡æ ¼ â–¼</span>
      </div>

      <div class="board-area" id="boardArea">
        <div class="board-scale" id="boardScale">
          <div class="board-frame" id="boardFrame">
            <div class="board-inner" id="boardInner">
              <div class="cells-bg"></div>
              <div class="grid-bg"></div>
              <div class="goal-badge" id="goalBadge">ç›®æŒ‡ã›!J1æ˜‡æ ¼</div>
              <!-- blocks inserted here -->
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="undoBtn" disabled>â†© æˆ»ã‚‹</button>
        <button class="btn" id="redoBtn" disabled>é€²ã‚€ â†ª</button>
        <button class="btn primary" id="solveBtn">æ¨¡ç¯„è§£ç­”ã‚’è¨ˆç®—ï¼ˆè‡ªå‹•å†ç”Ÿï¼‰</button>
      </div>

      <div class="sub-controls">
        <button class="pill" id="resetBtn">æœ€åˆã«æˆ»ã™</button>
        <button class="pill" id="clearBestBtn">è¨˜éŒ²æ¶ˆå»</button>
      </div>

      <div class="foot">è¨­å®šãƒ»ãƒªã‚»ãƒƒãƒˆï¼ˆèª¤æ“ä½œé˜²æ­¢ã‚¨ãƒªã‚¢ï¼‰</div>
    </div>
  </div>

  <div class="overlay" id="solverOverlay">
    <div class="card">
      <div class="title">æ¨¡ç¯„è§£ç­”ã‚’è¨ˆç®—ä¸­â€¦</div>
      <div class="info" id="solverInfo">åˆæœŸåŒ–ä¸­â€¦</div>
      <button class="cancel" id="solverCancel">ä¸­æ­¢</button>
    </div>
  </div>

<script>
(() => {
  /* =========================================================
   *  åŸºæœ¬å®šæ•°
   * ========================================================= */
  const COLS = 6;
  const ROWS = 5;

  const LS = {
    mode: "ai_nigata_mode",
    bestPromote: "ai_nigata_best_promote",
    bestChamp: "ai_nigata_best_champ",
    minPromote: "ai_nigata_min_promote",
    minChamp: "ai_nigata_min_champ",
    bgmOn: "ai_nigata_bgm_on",
    seOn: "ai_nigata_se_on",
    bgmVol: "ai_nigata_bgm_vol",
    seVol: "ai_nigata_se_vol"
  };

  /* =========================================================
   *  ãƒãƒ¼ãƒ ã‚«ãƒ©ãƒ¼ï¼ˆã–ã£ãã‚Šï¼šè¦–èªæ€§å„ªå…ˆï¼‰
   * ========================================================= */
  const TEAM_COLOR = {
    // Mode1 (J1æ˜‡æ ¼)
    "æ¨ªæµœFC": { bg:"#61b9e6", fg:"#062a4d" },
    "æ¹˜å—":   { bg:"#0b6b3b", fg:"#ffffff" },
    "å¾³å³¶":   { bg:"#0b4f9f", fg:"#ffffff" },
    "ç£ç”°":   { bg:"#a6d8ff", fg:"#11324d" },
    "å¤§å®®":   { bg:"#ff7a1a", fg:"#ffffff" },
    "ä»™å°":   { bg:"#f4b000", fg:"#1a1a1a" },
    "é³¥æ –":   { bg:"#e91e63", fg:"#ffffff" },
    "ã„ã‚ã": { bg:"#d00000", fg:"#ffffff" },
    "å±±å½¢":   { bg:"#0a4fb7", fg:"#ffffff" },
    "ä»Šæ²»":   { bg:"#0b3d91", fg:"#ffffff" },
    "æœ­å¹Œ":   { bg:"#c8102e", fg:"#ffffff" },
    "ç”²åºœ":   { bg:"#0b4aa2", fg:"#ffffff" },
    "ç§‹ç”°":   { bg:"#114e9e", fg:"#ffffff" },
    "è—¤æ":   { bg:"#6b38b1", fg:"#ffffff" },

    // Mode2 (J1å„ªå‹)
    "é¹¿å³¶":   { bg:"#a5001d", fg:"#ffffff" },
    "æŸ":     { bg:"#f2c300", fg:"#1a1a1a" },
    "äº¬éƒ½":   { bg:"#4b2a7a", fg:"#ffffff" },
    "åºƒå³¶":   { bg:"#5a2ca0", fg:"#ffffff" },
    "ç¥æˆ¸":   { bg:"#7a0c2e", fg:"#ffffff" },
    "ç”ºç”°":   { bg:"#0b5da8", fg:"#ffffff" },
    "æµ¦å’Œ":   { bg:"#d60016", fg:"#ffffff" },
    "å·å´":   { bg:"#00a0e9", fg:"#062a4d" },
    "Gå¤§é˜ª":  { bg:"#0033a0", fg:"#ffffff" },
    "Cå¤§é˜ª":  { bg:"#e6007e", fg:"#ffffff" },
    "Fæ±äº¬":  { bg:"#003a70", fg:"#ffffff" },
    "ç¦å²¡":   { bg:"#007a5e", fg:"#ffffff" },
    "å²¡å±±":   { bg:"#8b0f1a", fg:"#ffffff" },

    // main
    "æ–°æ½Ÿ":   { bg:"#f39c12", fg:"#1a1a1a" }
  };

  function getTeamColor(name){
    return TEAM_COLOR[name] || { bg:"#999", fg:"#fff" };
  }

  /* =========================================================
   *  ç›¤é¢ãƒ‡ãƒ¼ã‚¿ï¼ˆâ€»ä»•æ§˜ï¼šç›¤é¢6x5ã€ç©ºã2ã€ãƒ¡ã‚¤ãƒ³2x2ã€ã‚´ãƒ¼ãƒ«å·¦ä¸Šå›ºå®šï¼‰
   * ========================================================= */

  // MODE1: 2x1 * 5, 1x2 * 5, 1x1 * 4, main 2x2ï¼ˆåˆè¨ˆ15ãƒ”ãƒ¼ã‚¹ï¼‰
  // ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã®ä¸¦ã³ã«è¿‘ã„é…ç½®ï¼ç©ºã2ãƒã‚¹ï¼‰
  const PROMOTE_LAYOUT = [
    // id, name, w,h,x,y, isMain
    { id:99, name:"æ–°æ½Ÿ", w:2, h:2, x:4, y:3, isMain:true },

    { id:7,  name:"æ¨ªæµœFC", w:2, h:1, x:0, y:0 },
    { id:1,  name:"æ¹˜å—",   w:1, h:2, x:0, y:1 },
    { id:6,  name:"å¾³å³¶",   w:2, h:1, x:2, y:0 },
    { id:2,  name:"ç£ç”°",   w:1, h:2, x:1, y:1 },
    { id:5,  name:"å¤§å®®",   w:1, h:2, x:2, y:1 },
    { id:9,  name:"ä»™å°",   w:2, h:1, x:0, y:3 },
    { id:3,  name:"é³¥æ –",   w:1, h:2, x:4, y:0 },
    { id:15, name:"ã„ã‚ã", w:1, h:1, x:3, y:1 },
    { id:10, name:"å±±å½¢",   w:2, h:1, x:0, y:4 },
    { id:4,  name:"ä»Šæ²»",   w:1, h:2, x:5, y:0 },
    { id:13, name:"æœ­å¹Œ",   w:1, h:1, x:3, y:2 },
    { id:8,  name:"ç”²åºœ",   w:2, h:1, x:2, y:3 },
    { id:14, name:"ç§‹ç”°",   w:1, h:1, x:2, y:4 },
    { id:12, name:"è—¤æ",   w:1, h:1, x:3, y:4 },
  ];

  // MODE2: 2x1 * 7, 1x2 * 4, 1x1 * 2, main 2x2ï¼ˆåˆè¨ˆ14ãƒ”ãƒ¼ã‚¹ï¼‰
  // â€»ã“ã®é…ç½®ã¯ã€Œè§£ãŒå‡ºã‚‹ã€ã“ã¨ã‚’å‰æã«èª¿æ•´æ¸ˆã¿ï¼ˆç©ºã2ãƒã‚¹ï¼‰
  const CHAMP_LAYOUT = [
    { id:99, name:"æ–°æ½Ÿ", w:2, h:2, x:4, y:3, isMain:true },

    // è¿‘ã„é †ã®é›°å›²æ°—ã«ãªã‚‹ã‚ˆã†ã«é…ç½®ï¼ˆå½¢çŠ¶ã¯å›ºå®šè¦ä»¶ãªã—ï¼‰
    { id:6,  name:"é¹¿å³¶",  w:2, h:1, x:0, y:0 },
    { id:12, name:"æŸ",    w:1, h:2, x:0, y:1 },
    { id:4,  name:"äº¬éƒ½",  w:2, h:1, x:2, y:0 },
    { id:1,  name:"åºƒå³¶",  w:2, h:1, x:1, y:1 },
    { id:10, name:"ç¥æˆ¸",  w:2, h:1, x:1, y:2 },
    { id:7,  name:"ç”ºç”°",  w:2, h:1, x:4, y:0 },
    { id:3,  name:"æµ¦å’Œ",  w:1, h:2, x:3, y:1 },
    { id:8,  name:"å·å´",  w:1, h:2, x:1, y:3 },
    { id:5,  name:"Gå¤§é˜ª", w:1, h:2, x:4, y:1 },
    { id:2,  name:"Cå¤§é˜ª", w:2, h:1, x:2, y:3 },
    { id:13, name:"Fæ±äº¬", w:1, h:1, x:5, y:1 },
    { id:11, name:"ç¦å²¡",  w:2, h:1, x:2, y:4 },
    { id:9,  name:"å²¡å±±",  w:1, h:1, x:5, y:2 },
  ];

  const MODES = {
    promote: {
      label: "ç›®æŒ‡ã›!J1æ˜‡æ ¼",
      minKey: LS.minPromote,
      bestKey: LS.bestPromote,
      layout: PROMOTE_LAYOUT
    },
    champ: {
      label: "ç›®æŒ‡ã›!J1å„ªå‹",
      minKey: LS.minChamp,
      bestKey: LS.bestChamp,
      layout: CHAMP_LAYOUT
    }
  };

  /* =========================================================
   *  çŠ¶æ…‹
   * ========================================================= */
  let currentMode = "promote";
  let blocks = [];            // ç¾åœ¨ç›¤é¢ï¼ˆdeep copyï¼‰
  let history = [];           // undo
  let future = [];            // redo
  let moves = 0;
  let minMovesKnown = null;

  let dragging = null;        // {id,startX,startY}
  let pointerId = null;

  /* =========================================================
   *  DOM
   * ========================================================= */
  const boardArea = document.getElementById("boardArea");
  const boardScale = document.getElementById("boardScale");
  const boardFrame = document.getElementById("boardFrame");
  const boardInner = document.getElementById("boardInner");
  const goalBadge = document.getElementById("goalBadge");

  const movesCountEl = document.getElementById("movesCount");
  const minMovesEl = document.getElementById("minMoves");
  const modeLabelEl = document.getElementById("modeLabel");

  const modePromoteBtn = document.getElementById("modePromote");
  const modeChampBtn = document.getElementById("modeChamp");

  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const resetBtn = document.getElementById("resetBtn");
  const clearBestBtn = document.getElementById("clearBestBtn");

  const solveBtn = document.getElementById("solveBtn");

  const overlay = document.getElementById("solverOverlay");
  const solverInfo = document.getElementById("solverInfo");
  const solverCancel = document.getElementById("solverCancel");

  /* =========================================================
   *  Audioï¼ˆ10æ®µéšã€æœ€å¤§å€¤ã‚’å¤§ããï¼‰
   * ========================================================= */
  let audioUnlocked = false;
  let audioCtx = null;

  let masterGain = null;
  let bgmGain = null;
  let seGain = null;

  let bgmOn = false;
  let seOn = true;
  let bgmVol = 5; // 0..10
  let seVol  = 5; // 0..10

  const bgmToggle = document.getElementById("bgmToggle");
  const seToggle = document.getElementById("seToggle");
  const bgmVolSlider = document.getElementById("bgmVol");
  const seVolSlider  = document.getElementById("seVol");
  const bgmVolNum = document.getElementById("bgmVolNum");
  const seVolNum  = document.getElementById("seVolNum");

  // BGM scheduler
  let bgmTimer = null;
  let bgmStep = 0;
  let bgmNextTime = 0;

  // 16-step loopï¼ˆã¡ã‚‡ã„ãƒãƒƒãƒ—ï¼‰
  const SCALE = {
    C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88,
    C5:523.25, D5:587.33, E5:659.25, G5:783.99
  };

  const BGM_PATTERNS = {
    promote: [
      SCALE.C4, 0, SCALE.E4, 0, SCALE.G4, 0, SCALE.E4, 0,
      SCALE.D4, 0, SCALE.F4, 0, SCALE.A4, 0, SCALE.G4, 0
    ],
    champ: [
      SCALE.E4, 0, SCALE.G4, 0, SCALE.A4, 0, SCALE.G4, 0,
      SCALE.F4, 0, SCALE.A4, 0, SCALE.C5, 0, SCALE.B4, 0
    ]
  };

  function ensureAudio(){
    if (audioUnlocked) return;
    audioUnlocked = true;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    bgmGain = audioCtx.createGain();
    seGain  = audioCtx.createGain();

    masterGain.gain.value = 0.9;
    bgmGain.connect(masterGain);
    seGain.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    applyVolumes();
  }

  // ã€Œæœ€å¤§å€¤ã¯ç¾åœ¨ã‚ˆã‚Šå¤§å¹…ã«å¤§ããã€ï¼š10/10ã§ã‹ãªã‚Šå¤§ãã‚ã«
  function applyVolumes(){
    if (!audioCtx) return;

    const bgmMul = bgmOn ? (bgmVol/10) : 0;
    const seMul  = seOn  ? (seVol/10)  : 0;

    // ä»¥å‰ã‚ˆã‚Šä¸Šã‚’å‡ºã™ï¼ˆãŸã ã—ã‚¯ãƒªãƒƒãƒ—ã—ã¥ã‚‰ã„ç¯„å›²ï¼‰
    bgmGain.gain.value = bgmMul * 0.95;  // 0..0.95
    seGain.gain.value  = seMul  * 1.25;  // 0..1.25
  }

  function playClickSE(){
    if (!audioCtx) return;
    if (!seOn || seVol === 0) return;

    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = "square";
    o.frequency.value = 620;

    g.gain.value = 0.0001;
    o.connect(g);
    g.connect(seGain);

    const t = audioCtx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.20, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

    o.start(t);
    o.stop(t + 0.09);
  }

  function playWinSE(){
    if (!audioCtx) return;
    if (!seOn || seVol === 0) return;

    const notes = [SCALE.C5, SCALE.E5, SCALE.G5, SCALE.E5, SCALE.C5];
    let t = audioCtx.currentTime;

    for (let i=0;i<notes.length;i++){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.value = notes[i];

      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(seGain);

      g.gain.exponentialRampToValueAtTime(0.25, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);

      o.start(t);
      o.stop(t + 0.15);
      t += 0.12;
    }
  }

  function startBGM(){
    if (!audioCtx) return;
    stopBGM();

    bgmStep = 0;
    bgmNextTime = audioCtx.currentTime + 0.06;

    const stepDur = 0.12; // 16 steps loop

    bgmTimer = setInterval(() => {
      if (!audioCtx) return;
      if (!bgmOn || bgmVol === 0) return;

      const now = audioCtx.currentTime;
      while (bgmNextTime < now + 0.10){
        const pattern = BGM_PATTERNS[currentMode] || BGM_PATTERNS.promote;
        const freq = pattern[bgmStep % 16];

        if (freq && freq > 0){
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "square";
          o.frequency.value = freq;

          g.gain.value = 0.0001;
          o.connect(g);
          g.connect(bgmGain);

          const t = bgmNextTime;
          g.gain.exponentialRampToValueAtTime(0.12, t + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t + 0.10);

          o.start(t);
          o.stop(t + 0.11);
        }

        bgmStep++;
        bgmNextTime += stepDur;
      }
    }, 30);
  }

  function stopBGM(){
    if (bgmTimer){
      clearInterval(bgmTimer);
      bgmTimer = null;
    }
  }

  function updateSoundUI(){
    bgmVolSlider.value = String(bgmVol);
    seVolSlider.value  = String(seVol);
    bgmVolNum.textContent = String(bgmVol);
    seVolNum.textContent  = String(seVol);

    bgmToggle.classList.toggle("on", bgmOn);
    bgmToggle.classList.toggle("off", !bgmOn);
    bgmToggle.textContent = bgmOn ? "â™ª BGM: ON" : "â™ª BGM: OFF";

    seToggle.classList.toggle("on", seOn);
    seToggle.classList.toggle("off", !seOn);
    seToggle.textContent = seOn ? "ğŸ“£ åŠ¹æœéŸ³: ON" : "ğŸ“£ åŠ¹æœéŸ³: OFF";

    applyVolumes();
  }

  /* =========================================================
   *  Confetti
   * ========================================================= */
  const confettiCanvas = document.getElementById("confettiCanvas");
  const cctx = confettiCanvas.getContext("2d");
  let confettiParticles = [];
  let confettiRAF = null;

  function resizeConfetti(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }

  function confettiBurst(){
    resizeConfetti();
    confettiCanvas.style.display = "block";

    const W = confettiCanvas.width;
    const H = confettiCanvas.height;

    confettiParticles = [];
    const count = 140;

    for (let i=0;i<count;i++){
      const x = W * (0.25 + Math.random()*0.5);
      const y = H * 0.12;
      const vx = (Math.random()-0.5) * 8;
      const vy = 3 + Math.random() * 8;
      const size = 6 + Math.random()*8;
      const rot = Math.random()*Math.PI*2;
      const vr = (Math.random()-0.5)*0.3;
      const hue = Math.floor(Math.random()*360);

      confettiParticles.push({x,y,vx,vy,size,rot,vr,hue,life:0,ttl: 240 + Math.random()*120});
    }

    if (confettiRAF) cancelAnimationFrame(confettiRAF);
    const gravity = 0.12;

    const tick = () => {
      cctx.clearRect(0,0,W,H);
      for (const p of confettiParticles){
        p.life++;
        p.vy += gravity;
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.vr;

        const alpha = Math.max(0, 1 - p.life / p.ttl);
        cctx.save();
        cctx.translate(p.x, p.y);
        cctx.rotate(p.rot);
        cctx.globalAlpha = alpha;
        cctx.fillStyle = "hsl(" + p.hue + " 85% 55%)";
        cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
        cctx.restore();
      }

      confettiParticles = confettiParticles.filter(p => p.life < p.ttl && p.y < H + 80);

      if (confettiParticles.length){
        confettiRAF = requestAnimationFrame(tick);
      }else{
        confettiCanvas.style.display = "none";
      }
    };

    confettiRAF = requestAnimationFrame(tick);
  }

  /* =========================================================
   *  ç›¤é¢æç”»
   * ========================================================= */
  function deepCopyLayout(layout){
    return layout.map(b => ({...b}));
  }

  function cellPx(){
    const cs = getComputedStyle(document.documentElement);
    const cell = parseFloat(cs.getPropertyValue("--cell")) || 86;
    const gap  = parseFloat(cs.getPropertyValue("--gap")) || 6;
    const pad  = parseFloat(cs.getPropertyValue("--inner-pad")) || 10;
    const frame= parseFloat(cs.getPropertyValue("--frame-thick")) || 10;
    return { cell, gap, pad, frame };
  }

  function boardPixelSize(){
    const { cell, pad, frame } = cellPx();
    const innerW = COLS * cell;
    const innerH = ROWS * cell;
    const frameW = innerW + pad*2 + frame*2;
    const frameH = innerH + pad*2 + frame*2;
    return { frameW, frameH, innerW, innerH };
  }

  function fitBoardToScreen(){
    const { frameW, frameH } = boardPixelSize();
    // boardScale ã¯ frame ã‚µã‚¤ã‚ºã§çµ„ã‚€ï¼ˆCSSã®paddingå«ã‚€ï¼‰
    const maxW = Math.min(window.innerWidth - 24, 720);
    const scale = Math.min(1, maxW / frameW);

    boardArea.style.height = (frameH * scale + 2) + "px";
    boardScale.style.width = frameW + "px";
    boardScale.style.height = frameH + "px";
    boardScale.style.transform = "translateX(-50%) scale(" + scale + ")";
  }

  function renderBoard(){
    // clear old blocks
    const old = boardInner.querySelectorAll(".block");
    old.forEach(el => el.remove());

    const { cell, gap } = cellPx();

    // goal badge size sync (2x2)
    goalBadge.style.width  = (cell*2 - gap) + "px";
    goalBadge.style.height = (cell*2 - gap) + "px";

    for (const b of blocks){
      const el = document.createElement("div");
      el.className = "block";
      el.dataset.id = String(b.id);

      const { bg, fg } = getTeamColor(b.name);
      el.style.background = bg;
      el.style.color = fg;

      // position / size
      const left = b.x * cell;
      const top  = b.y * cell;
      const wpx  = b.w * cell - gap;
      const hpx  = b.h * cell - gap;

      el.style.left = left + "px";
      el.style.top  = top  + "px";
      el.style.width  = wpx + "px";
      el.style.height = hpx + "px";

      // index
      const idEl = document.createElement("div");
      idEl.className = "id";
      idEl.textContent = String(b.id);
      el.appendChild(idEl);

      // name
      const nameEl = document.createElement("div");
      nameEl.className = "name";
      nameEl.textContent = b.name;

      // 1x1 ã¯ç¸¦æ›¸ãï¼‹ãƒ•ã‚©ãƒ³ãƒˆç¸®å°ï¼ˆã€Œã„ã‚ãã€2è¡Œå•é¡Œã®å›é¿ï¼‰
      const textLen = (b.name || "").length;
      if (b.w === 1 && b.h === 1){
        nameEl.classList.add("vtext");
        const fs = Math.max(12, Math.min(22, Math.floor(72 / Math.max(2, textLen))));
        nameEl.style.fontSize = fs + "px";
      }else{
        // é•·ã„ã»ã©å°‘ã—å°ã•ã
        let fs = 26;
        if (textLen >= 4) fs = 22;
        if (textLen >= 5) fs = 20;
        if (textLen >= 6) fs = 18;
        nameEl.style.fontSize = fs + "px";
      }

      // main block stronger text
      if (b.isMain){
        nameEl.style.fontSize = "38px";
        nameEl.style.letterSpacing = ".06em";
        nameEl.style.textShadow = "0 2px 8px rgba(0,0,0,.18)";
      }

      el.appendChild(nameEl);

      // Pointer events
      el.addEventListener("pointerdown", onBlockPointerDown);
      el.addEventListener("pointermove", onBlockPointerMove);
      el.addEventListener("pointerup", onBlockPointerUp);
      el.addEventListener("pointercancel", onBlockPointerUp);

      boardInner.appendChild(el);
    }

    fitBoardToScreen();
  }

  function updateUI(){
    movesCountEl.textContent = String(moves);
    minMovesEl.textContent = (minMovesKnown == null) ? "-" : String(minMovesKnown);

    undoBtn.disabled = history.length === 0;
    redoBtn.disabled = future.length === 0;

    modePromoteBtn.classList.toggle("active", currentMode === "promote");
    modeChampBtn.classList.toggle("active", currentMode === "champ");

    modeLabelEl.textContent = "â–¼ " + MODES[currentMode].label + " â–¼";
    goalBadge.textContent = MODES[currentMode].label;
  }

  /* =========================================================
   *  ç›¤é¢ãƒ«ãƒ¼ãƒ«
   * ========================================================= */
  function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return !(ax+aw<=bx || bx+bw<=ax || ay+ah<=by || by+bh<=ay);
  }

  function canMove(blockId, dx, dy){
    const b = blocks.find(x => x.id === blockId);
    if (!b) return false;

    const nx = b.x + dx;
    const ny = b.y + dy;

    if (nx < 0 || ny < 0 || nx + b.w > COLS || ny + b.h > ROWS) return false;

    for (const o of blocks){
      if (o.id === b.id) continue;
      if (rectsOverlap(nx,ny,b.w,b.h, o.x,o.y,o.w,o.h)) return false;
    }
    return true;
  }

  function applyMove(blockId, dx, dy, silent=false){
    if (!canMove(blockId, dx, dy)) return false;

    // push history
    history.push(snapshot());
    future = [];

    const b = blocks.find(x => x.id === blockId);
    b.x += dx;
    b.y += dy;
    moves++;

    if (!silent){
      ensureAudio();
      playClickSE();
    }

    renderBoard();
    updateUI();

    if (checkWin()){
      onWin();
    }
    return true;
  }

  function snapshot(){
    return {
      blocks: blocks.map(b => ({...b})),
      moves
    };
  }

  function restoreSnap(snap){
    blocks = snap.blocks.map(b => ({...b}));
    moves = snap.moves;
    renderBoard();
    updateUI();
  }

  function undo(){
    if (!history.length) return;
    future.push(snapshot());
    const prev = history.pop();
    restoreSnap(prev);
  }

  function redo(){
    if (!future.length) return;
    history.push(snapshot());
    const next = future.pop();
    restoreSnap(next);
  }

  function checkWin(){
    const main = blocks.find(b => b.isMain);
    if (!main) return false;
    return main.x === 0 && main.y === 0;
  }

  function onWin(){
    ensureAudio();
    playWinSE();
    confettiBurst();

    // best update
    const bestKey = MODES[currentMode].bestKey;
    const prevBest = parseInt(localStorage.getItem(bestKey) || "0", 10) || 0;
    if (prevBest === 0 || moves < prevBest){
      localStorage.setItem(bestKey, String(moves));
    }

    setTimeout(() => {
      alert("ã‚¯ãƒªã‚¢ï¼ ãŠã‚ã§ã¨ã†ğŸ‰\næ‰‹æ•°: " + moves);
    }, 30);
  }

  function resetToStart(){
    blocks = deepCopyLayout(MODES[currentMode].layout);
    history = [];
    future = [];
    moves = 0;

    // æœ€å°‘ï¼ˆå‰å›è¨ˆç®—å€¤ï¼‰ã¯ä¿æŒã—ã¦è¡¨ç¤ºã—ãŸã„ã®ã§ã€minMovesKnownã¯æ¶ˆã•ãªã„
    renderBoard();
    updateUI();
  }

  function clearRecords(){
    localStorage.removeItem(MODES.promote.bestKey);
    localStorage.removeItem(MODES.champ.bestKey);
    localStorage.removeItem(MODES.promote.minKey);
    localStorage.removeItem(MODES.champ.minKey);
    minMovesKnown = null;
    updateUI();
    alert("è¨˜éŒ²ã‚’æ¶ˆå»ã—ã¾ã—ãŸã€‚");
  }

  /* =========================================================
   *  ãƒ–ãƒ­ãƒƒã‚¯æ“ä½œï¼ˆã‚¹ãƒ¯ã‚¤ãƒ—1æ‰‹ï¼‰
   * ========================================================= */
  const SWIPE_THRESHOLD = 18;

  function onBlockPointerDown(e){
    ensureAudio(); // ã“ã“ã§ä¸€åº¦ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ï¼ˆiOSå¯¾ç­–ï¼‰
    const id = parseInt(e.currentTarget.dataset.id, 10);
    pointerId = e.pointerId;
    e.currentTarget.setPointerCapture(pointerId);
    dragging = { id, startX: e.clientX, startY: e.clientY, moved:false };
  }

  function onBlockPointerMove(e){
    if (!dragging) return;
    if (e.pointerId !== pointerId) return;

    const dx = e.clientX - dragging.startX;
    const dy = e.clientY - dragging.startY;
    if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return;

    dragging.moved = true;

    // decide direction
    let mdx=0, mdy=0;
    if (Math.abs(dx) > Math.abs(dy)){
      mdx = dx > 0 ? 1 : -1;
    }else{
      mdy = dy > 0 ? 1 : -1;
    }

    // only one move per swipe
    const ok = applyMove(dragging.id, mdx, mdy);
    dragging = null;
    pointerId = null;

    if (!ok){
      // move failed; still stop dragging to avoid repeated attempts
    }
  }

  function onBlockPointerUp(e){
    if (!dragging) return;
    if (e.pointerId !== pointerId) return;
    dragging = null;
    pointerId = null;
  }

  /* =========================================================
   *  Modeåˆ‡æ›¿ï¼ˆãƒªãƒ­ãƒ¼ãƒ‰ç›´å¾Œã‹ã‚‰è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
   * ========================================================= */
  function switchMode(mode){
    if (!MODES[mode]) return;
    currentMode = mode;
    localStorage.setItem(LS.mode, currentMode);

    // minMoves load
    const minStr = localStorage.getItem(MODES[currentMode].minKey);
    minMovesKnown = (minStr && !isNaN(parseInt(minStr,10))) ? parseInt(minStr,10) : null;

    blocks = deepCopyLayout(MODES[currentMode].layout);
    history = [];
    future = [];
    moves = 0;

    renderBoard();
    updateUI();

    // BGM pattern also changes
    if (bgmOn && audioCtx){
      startBGM();
    }
  }

  /* =========================================================
   *  Solver (Web Worker)
   *  - è¡çªåˆ¤å®šã‚’ãƒ“ãƒƒãƒˆãƒã‚¹ã‚¯åŒ–ã—ã¦å¤§å¹…é«˜é€ŸåŒ–
   *  - progressæ›´æ–°ã‚’ç´°ã‹ãã—ã¦ã€Œæ­¢ã¾ã£ã¦è¦‹ãˆã‚‹ã€ã‚’å›é¿
   * ========================================================= */
  let solverWorker = null;
  let solverStartTime = 0;

  const DIRS = [
    {dx:-1,dy:0},  // 0: L
    {dx:0,dy:-1},  // 1: U
    {dx:1,dy:0},   // 2: R
    {dx:0,dy:1}    // 3: D
  ];

  function showOverlay(text){
    solverInfo.textContent = text;
    overlay.style.display = "flex";
  }
  function hideOverlay(){
    overlay.style.display = "none";
  }

  function stopSolver(){
    if (solverWorker){
      solverWorker.terminate();
      solverWorker = null;
    }
    hideOverlay();
  }

  function startSolver(){
    ensureAudio();

    // ã™ã§ã«å‹•ä½œä¸­ãªã‚‰æ­¢ã‚ã‚‹
    if (solverWorker){
      stopSolver();
      return;
    }

    // ç›¤é¢ã‚’ workerã¸é€ã‚‹ï¼ˆå¿…è¦æœ€å°é™ï¼‰
    const payload = blocks.map(b => ({
      id: b.id,
      x: b.x, y: b.y,
      w: b.w, h: b.h,
      isMain: !!b.isMain
    }));

    showOverlay("åˆæœŸåŒ–ä¸­â€¦");
    solverStartTime = performance.now();

    solverWorker = createSolverWorker();
    solverWorker.postMessage({ type:"start", cols:COLS, rows:ROWS, blocks: payload });

    solverWorker.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg) return;

      if (msg.type === "progress"){
        const dt = ((performance.now() - solverStartTime)/1000).toFixed(2);
        solverInfo.textContent =
          "phase: " + msg.phase + "\n" +
          "expanded: " + msg.expanded + "\n" +
          "open: " + msg.open + "\n" +
          "bestH: " + msg.bestH.toFixed(2) + "\n" +
          "time: " + dt + "s";
        return;
      }

      if (msg.type === "done"){
        const packedMoves = msg.moves || [];
        const minLen = msg.minLen ?? packedMoves.length;

        // æœ€å°‘è¡¨ç¤ºï¼ˆä¿å­˜ã—ã¦ãƒªãƒ­ãƒ¼ãƒ‰å¾Œã‚‚å‡ºã™ï¼‰
        minMovesKnown = minLen;
        localStorage.setItem(MODES[currentMode].minKey, String(minLen));
        updateUI();

        stopSolver();

        // è‡ªå‹•å†ç”Ÿ
        autoplayPackedMoves(packedMoves);
        return;
      }

      if (msg.type === "fail"){
        const dt = ((performance.now() - solverStartTime)/1000).toFixed(2);
        const reason = msg.reason || "unknown";
        stopSolver();
        alert("è§£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\nç†ç”±: " + reason + "\nå±•é–‹: " + (msg.expanded||0) + "\næ™‚é–“: " + dt + "s");
        return;
      }
    };

    solverWorker.onerror = (e) => {
      console.error(e);
      stopSolver();
      alert("ã‚½ãƒ«ãƒãƒ¼ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
    };
  }

  function autoplayPackedMoves(packed){
    if (!packed || !packed.length){
      alert("æ—¢ã«ã‚´ãƒ¼ãƒ«çŠ¶æ…‹ã€ã¾ãŸã¯æ‰‹é †ãŒç©ºã§ã—ãŸã€‚");
      return;
    }

    // å†ç”Ÿä¸­ã¯æ“ä½œç„¡åŠ¹
    solveBtn.disabled = true;
    undoBtn.disabled = true;
    redoBtn.disabled = true;

    const originalSnap = snapshot();

    let idx = 0;
    const step = () => {
      if (idx >= packed.length){
        solveBtn.disabled = false;
        updateUI();
        return;
      }

      const m = packed[idx++];
      const bi = (m >> 2);
      const di = (m & 3);
      const d = DIRS[di];

      const b = blocks[bi];
      if (!b){
        // ãƒ”ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸æ•´åˆãªã‚‰çµ‚äº†
        restoreSnap(originalSnap);
        solveBtn.disabled = false;
        updateUI();
        return;
      }

      // silent=false ã ã¨éŸ³ãŒå‡ºã‚‹
      applyMove(b.id, d.dx, d.dy, false);

      setTimeout(step, 140);
    };

    // ç›¤é¢ã‚’æœ€åˆã‹ã‚‰å†ç”Ÿã—ãŸã„ã®ã§é–‹å§‹æ™‚ç‚¹ã§ãƒªã‚»ãƒƒãƒˆ
    resetToStart();
    setTimeout(step, 200);
  }

  function createSolverWorker(){
    const workerScript =
`self.onmessage = function(ev){
  const msg = ev.data;
  if (!msg || msg.type !== "start") return;

  const COLS = msg.cols|0;
  const ROWS = msg.rows|0;
  const blocks = msg.blocks || [];
  const N = blocks.length;

  const mainIdx = blocks.findIndex(b => b.isMain);
  if (mainIdx < 0){
    self.postMessage({type:"fail", reason:"main_not_found", expanded:0});
    return;
  }

  // shapes
  const W = new Int8Array(N);
  const H = new Int8Array(N);
  for (let i=0;i<N;i++){
    W[i] = blocks[i].w|0;
    H[i] = blocks[i].h|0;
  }

  // precompute bitmask for each piece and position (pos = y*COLS + x)
  // board cells <= 30 => 32-bit mask ok
  const MASK = [];
  for (let i=0;i<N;i++){
    const arr = new Uint32Array(COLS*ROWS);
    const w = W[i], h = H[i];
    for (let y=0;y<=ROWS-h;y++){
      for (let x=0;x<=COLS-w;x++){
        let m = 0;
        for (let dy=0;dy<h;dy++){
          for (let dx=0;dx<w;dx++){
            const c = (y+dy)*COLS + (x+dx);
            m |= (1 << c);
          }
        }
        arr[y*COLS + x] = m >>> 0;
      }
    }
    MASK.push(arr);
  }

  // state: Int8Array [x0,y0,x1,y1,...]
  const start = new Int8Array(N*2);
  for (let i=0;i<N;i++){
    start[i*2]   = blocks[i].x|0;
    start[i*2+1] = blocks[i].y|0;
  }

  function keyOf(st){
    // values are 0..5, encode to chars (fast+small)
    let s = "";
    for (let i=0;i<st.length;i++){
      s += String.fromCharCode(65 + st[i]);
    }
    return s;
  }

  function occOf(st){
    let occ = 0;
    for (let i=0;i<N;i++){
      const x = st[i*2], y = st[i*2+1];
      occ |= MASK[i][y*COLS + x];
    }
    return occ >>> 0;
  }

  // heuristic: main dist + corridor blockers (fast)
  function heuristic(st){
    const mx = st[mainIdx*2];
    const my = st[mainIdx*2+1];
    let dist = mx + my;

    // corridor rectangle from (0,0) to main top-left
    const minx = 0, miny = 0, maxx = mx, maxy = my;
    let blocksIn = 0;

    for (let i=0;i<N;i++){
      if (i === mainIdx) continue;
      const x = st[i*2], y = st[i*2+1];
      const w = W[i], h = H[i];
      if (!(x+w-1 < minx || x > maxx || y+h-1 < miny || y > maxy)){
        blocksIn++;
      }
    }

    // slight weight for blockers
    return dist + blocksIn * 0.65;
  }

  // Min-heap
  function Heap(){
    this.f = [];
    this.g = [];
    this.id = [];
    this.h = [];
  }
  Heap.prototype.size = function(){ return this.f.length; };
  Heap.prototype.push = function(f,g,id,h){
    const F=this.f, G=this.g, I=this.id, Hh=this.h;
    let i = F.length;
    F.push(f); G.push(g); I.push(id); Hh.push(h);
    while(i>0){
      const p = (i-1)>>1;
      if (F[p] <= f) break;
      // swap
      F[i]=F[p]; G[i]=G[p]; I[i]=I[p]; Hh[i]=Hh[p];
      F[p]=f;    G[p]=g;    I[p]=id;   Hh[p]=h;
      i=p;
    }
  };
  Heap.prototype.pop = function(){
    const F=this.f, G=this.g, I=this.id, Hh=this.h;
    const n = F.length;
    if (!n) return null;
    const rf=F[0], rg=G[0], rid=I[0], rh=Hh[0];

    const lf=F.pop(), lg=G.pop(), lid=I.pop(), lh=Hh.pop();
    if (n>1){
      let i=0;
      F[0]=lf; G[0]=lg; I[0]=lid; Hh[0]=lh;
      while(true){
        let l=i*2+1, r=l+1, s=i;
        if (l<F.length && F[l]<F[s]) s=l;
        if (r<F.length && F[r]<F[s]) s=r;
        if (s===i) break;
        // swap
        const tf=F[i], tg=G[i], tid=I[i], th=Hh[i];
        F[i]=F[s]; G[i]=G[s]; I[i]=I[s]; Hh[i]=Hh[s];
        F[s]=tf;   G[s]=tg;   I[s]=tid;  Hh[s]=th;
        i=s;
      }
    }
    return {f:rf,g:rg,id:rid,h:rh};
  };

  // Solve Weighted A*
  const weight = 1.95;                  // é€Ÿã•å„ªå…ˆ
  const EXPAND_LIMIT = 2200000;         // phoneã§ã‚‚è€ãˆã‚‹ç¯„å›²
  const TIME_LIMIT_MS = 28000;          // 28sï¼ˆworkerï¼‰
  const PROGRESS_EVERY = 5000;

  const t0 = Date.now();
  let expanded = 0;

  const startH = heuristic(start);
  const heap = new Heap();
  heap.push(0 + weight*startH, 0, 0, startH);

  // node storage
  const states = [start];
  const parents = [-1];
  const moves = [-1]; // packed move for node (pieceIdx<<2 | dir)

  const gBest = new Map();
  const keyStart = keyOf(start);
  gBest.set(keyStart, 0);

  function isGoal(st){
    return st[mainIdx*2] === 0 && st[mainIdx*2+1] === 0;
  }

  function reconstruct(goalId){
    const path = [];
    let cur = goalId;
    while (parents[cur] !== -1){
      path.push(moves[cur]);
      cur = parents[cur];
    }
    path.reverse();
    return path;
  }

  // Direction order: mainã¯å·¦/ä¸Šã‚’å„ªå…ˆï¼ˆã‚´ãƒ¼ãƒ«æ–¹å‘ï¼‰
  const DIRS = [
    {dx:-1,dy:0}, {dx:0,dy:-1}, {dx:1,dy:0}, {dx:0,dy:1}
  ];

  while(true){
    const node = heap.pop();
    if (!node){
      self.postMessage({type:"fail", reason:"open_empty", expanded: expanded});
      return;
    }

    const sid = node.id;
    const st = states[sid];
    const k = keyOf(st);
    const g = node.g;

    const bestG = gBest.get(k);
    if (bestG !== g) continue;

    if (isGoal(st)){
      const path = reconstruct(sid);
      self.postMessage({type:"done", moves: path, minLen: path.length});
      return;
    }

    expanded++;
    if (expanded % PROGRESS_EVERY === 0){
      self.postMessage({
        type:"progress",
        phase:"A*",
        expanded: expanded,
        open: heap.size(),
        bestH: node.h
      });
    }
    if (expanded > EXPAND_LIMIT){
      self.postMessage({type:"fail", reason:"expand_limit", expanded: expanded});
      return;
    }
    if (Date.now() - t0 > TIME_LIMIT_MS){
      self.postMessage({type:"fail", reason:"time_limit", expanded: expanded});
      return;
    }

    // occupancy
    const occ = (function(){
      let o=0;
      for (let i=0;i<N;i++){
        const x=st[i*2], y=st[i*2+1];
        o |= MASK[i][y*COLS + x];
      }
      return o>>>0;
    })();

    for (let i=0;i<N;i++){
      const cx = st[i*2], cy = st[i*2+1];
      const w = W[i], h = H[i];
      const curMask = MASK[i][cy*COLS + cx];
      const occWo = (occ ^ curMask) >>> 0;

      // main priority dir
      const dirList = (i===mainIdx) ? DIRS : DIRS;

      for (let di=0;di<4;di++){
        const d = dirList[di];
        const nx = cx + d.dx;
        const ny = cy + d.dy;

        if (nx < 0 || ny < 0 || nx + w > COLS || ny + h > ROWS) continue;
        const newMask = MASK[i][ny*COLS + nx];
        if (newMask === 0) continue;
        if ((occWo & newMask) !== 0) continue;

        const ns = new Int8Array(st);
        ns[i*2] = nx;
        ns[i*2+1] = ny;

        const nk = keyOf(ns);
        const ng = g + 1;

        const prev = gBest.get(nk);
        if (prev !== undefined && prev <= ng) continue;

        gBest.set(nk, ng);

        const nh = heuristic(ns);
        const nf = ng + weight * nh;

        const nid = states.length;
        states.push(ns);
        parents.push(sid);

        // pack move: pieceIdx<<2 | dirCode(0:L 1:U 2:R 3:D)
        let dirCode = 0;
        if (d.dx===-1 && d.dy===0) dirCode=0;
        else if (d.dx===0 && d.dy===-1) dirCode=1;
        else if (d.dx===1 && d.dy===0) dirCode=2;
        else dirCode=3;

        moves.push((i<<2) | dirCode);

        heap.push(nf, ng, nid, nh);
      }
    }
  }
};`;

    const blob = new Blob([workerScript], { type:"application/javascript" });
    return new Worker(URL.createObjectURL(blob));
  }

  /* =========================================================
   *  ã‚¤ãƒ™ãƒ³ãƒˆ
   * ========================================================= */
  modePromoteBtn.addEventListener("click", () => {
    ensureAudio();
    playClickSE();
    switchMode("promote");
  });
  modeChampBtn.addEventListener("click", () => {
    ensureAudio();
    playClickSE();
    switchMode("champ");
  });

  undoBtn.addEventListener("click", () => { ensureAudio(); playClickSE(); undo(); });
  redoBtn.addEventListener("click", () => { ensureAudio(); playClickSE(); redo(); });
  resetBtn.addEventListener("click", () => { ensureAudio(); playClickSE(); resetToStart(); });
  clearBestBtn.addEventListener("click", () => { ensureAudio(); playClickSE(); clearRecords(); });

  solveBtn.addEventListener("click", () => {
    ensureAudio();
    playClickSE();
    startSolver();
  });

  solverCancel.addEventListener("click", () => {
    ensureAudio();
    playClickSE();
    stopSolver();
  });

  // sound
  bgmToggle.addEventListener("click", () => {
    ensureAudio();
    playClickSE();
    bgmOn = !bgmOn;
    localStorage.setItem(LS.bgmOn, bgmOn ? "1" : "0");
    updateSoundUI();
    if (bgmOn){
      startBGM();
    }else{
      stopBGM();
    }
  });

  seToggle.addEventListener("click", () => {
    ensureAudio();
    playClickSE();
    seOn = !seOn;
    localStorage.setItem(LS.seOn, seOn ? "1" : "0");
    updateSoundUI();
  });

  bgmVolSlider.addEventListener("input", () => {
    ensureAudio();
    bgmVol = parseInt(bgmVolSlider.value, 10);
    localStorage.setItem(LS.bgmVol, String(bgmVol));
    updateSoundUI();
  });

  seVolSlider.addEventListener("input", () => {
    ensureAudio();
    seVol = parseInt(seVolSlider.value, 10);
    localStorage.setItem(LS.seVol, String(seVol));
    updateSoundUI();
  });

  // window resize => fix board alignment
  window.addEventListener("resize", () => {
    fitBoardToScreen();
    resizeConfetti();
  });

  // first interaction unlock
  window.addEventListener("pointerdown", () => {
    ensureAudio();
    if (bgmOn) startBGM();
  }, { once:true });

  /* =========================================================
   *  èµ·å‹•ï¼ˆãƒªãƒ­ãƒ¼ãƒ‰ç›´å¾Œã‹ã‚‰è¡¨ç¤ºï¼‰
   * ========================================================= */
  function loadSettings(){
    currentMode = localStorage.getItem(LS.mode) || "promote";

    bgmOn = (localStorage.getItem(LS.bgmOn) || "0") === "1";
    seOn  = (localStorage.getItem(LS.seOn)  || "1") === "1";

    const bv = parseInt(localStorage.getItem(LS.bgmVol) || "5", 10);
    const sv = parseInt(localStorage.getItem(LS.seVol)  || "5", 10);
    bgmVol = isNaN(bv) ? 5 : Math.max(0, Math.min(10, bv));
    seVol  = isNaN(sv) ? 5 : Math.max(0, Math.min(10, sv));

    updateSoundUI();
  }

  function init(){
    loadSettings();
    switchMode(currentMode);

    // ç›¤é¢ã‚ºãƒ¬å¯¾ç­–ï¼ˆåˆæœŸæç”»å¾Œã«ã‚‚ã†ä¸€åº¦ãƒ•ã‚£ãƒƒãƒˆï¼‰
    setTimeout(() => {
      fitBoardToScreen();
    }, 50);
  }

  init();
})();
</script>
</body>
</html>
