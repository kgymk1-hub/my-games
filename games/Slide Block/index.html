<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
  <title>ã‚¢ã‚¤ã‚·ãƒ†ãƒ«ãƒ‹ã‚¤ã‚¬ã‚¿ãƒ‘ã‚ºãƒ«</title>
  <style>
    :root{
      --bg:#f4f4f4;
      --wood:#8b5a2b;
      --wood2:#dcb386;
      --block:#e8c39e;
      --accent:#d32f2f;
      --text:#333;
      --shadow: rgba(0,0,0,.18);
    }
    *{box-sizing:border-box}
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN","Meiryo",sans-serif;
      margin:0; padding:14px 0 28px;
      background:var(--bg);
      color:var(--text);
      display:flex; flex-direction:column; align-items:center;
      min-height:100vh;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      overflow-x:hidden;
    }

    h1{margin:0 0 10px; font-size:22px; color:#444}

    /* sound */
    .sound-wrap{
      width:92%; max-width:380px;
      background:#fff;
      border:1px solid #ddd;
      border-radius:12px;
      padding:10px 12px;
      box-shadow:0 2px 10px rgba(0,0,0,.06);
      margin:0 0 10px;
    }
    .sound-row{
      display:flex; align-items:center; gap:10px;
      margin:6px 0;
    }
    .sound-btn{
      flex:0 0 auto;
      background:#fff; border:1px solid #aaa; border-radius:18px;
      padding:6px 12px; font-size:12px; color:#777;
      display:flex; align-items:center; gap:6px;
      cursor:pointer;
      transition:.15s;
      white-space:nowrap;
    }
    .sound-btn.active{
      background:var(--accent); border-color:var(--accent);
      color:#fff; font-weight:800;
    }
    .sound-slider{
      flex:1 1 auto;
      display:flex; align-items:center; gap:8px;
      min-width:0;
    }
    input[type="range"]{ width:100%; }
    .sound-val{
      flex:0 0 auto;
      width:30px;
      text-align:right;
      font-weight:800;
      color:#666;
      font-size:12px;
    }

    /* mode */
    .mode-selector{
      display:flex; width:90%; max-width:360px;
      background:#ddd; border-radius:8px; padding:4px;
      margin-bottom:10px;
    }
    .mode-btn{
      flex:1; border:none; background:transparent; cursor:pointer;
      padding:10px 0; border-radius:6px;
      font-size:14px; font-weight:900; color:#666;
      transition:.15s;
      white-space:nowrap;
    }
    .mode-btn.active{
      background:#fff; color:var(--accent);
      box-shadow:0 2px 4px rgba(0,0,0,.10);
    }

    /* score */
    #score-board{
      display:flex; justify-content:space-between;
      width:88%; max-width:360px;
      font-weight:800; font-size:15px; color:#555;
      margin-bottom:6px;
      z-index:50;
    }
    .score-item span{color:var(--accent); font-size:18px; margin-left:5px}

    /* board wrapper */
    #board-wrapper{
      position:relative;
      margin:18px auto 18px;
      display:block;
    }
    #board-container{
      position:absolute;
      left:50%;
      top:0;
      width:388px;          /* = 360 + padding(20) + border(8) */
      height:328px;         /* = 300 + padding(20) + border(8) */
      padding:10px;
      border:4px solid var(--wood);
      border-radius:8px;
      background:var(--wood2);
      box-shadow:0 6px 18px rgba(0,0,0,.22);
      transform-origin:top center;
      transform:translateX(-50%) scale(1);
    }
    #goal-marker{
      position:absolute;
      top:-28px; left:10px;
      width:calc(100% - 20px);
      text-align:left;
      font-size:14px;
      font-weight:900;
      color:var(--wood);
      white-space:nowrap;
      pointer-events:none;
    }
    #game-board{
      position:relative;
      width:360px; height:300px;
      border:2px solid var(--wood);
      overflow:hidden;
      background-color:#111;
      background-image:
        linear-gradient(45deg,#222 25%,transparent 25%),
        linear-gradient(-45deg,#222 25%,transparent 25%),
        linear-gradient(45deg,transparent 75%,#222 75%),
        linear-gradient(-45deg,transparent 75%,#222 75%);
      background-size:20px 20px;
    }

    /* blocks */
    .block{
      position:absolute;
      border:2px solid var(--wood);
      border-radius:4px;
      box-shadow:inset 0 0 6px rgba(0,0,0,.10);
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      cursor:pointer;
      transition:top .10s ease-out, left .10s ease-out;
      z-index:10;
      line-height:1.05;
      white-space:nowrap;            /* â˜…æŠ˜ã‚Šè¿”ã—ç¦æ­¢ï¼ˆã„ã‚ãå¯¾ç­–ã®æ ¸ï¼‰ */
      word-break:keep-all;
      letter-spacing:.5px;
    }
    .block.selected{
      background:#fff3e0 !important;
      border-color:var(--accent);
      box-shadow:0 0 0 2px rgba(211,47,47,.35);
      z-index:20;
    }
    .block.auto{
      outline:2px solid rgba(0,137,123,.55);
      z-index:25;
    }

    .vertical{
      writing-mode:vertical-rl;
      text-orientation:upright;
      letter-spacing:1px;
    }
    .horizontal{
      writing-mode:horizontal-tb;
      text-orientation:mixed;
      letter-spacing:0;
    }

    .block-id{
      position:absolute; top:1px; left:2px;
      font-size:9px; opacity:.55;
      writing-mode:horizontal-tb;
      pointer-events:none;
      font-weight:800;
    }

    /* arrows */
    .arrow-btn{
      position:absolute;
      width:40px; height:40px;
      background:var(--accent);
      color:#fff;
      border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      font-size:20px;
      box-shadow:0 2px 6px rgba(0,0,0,.3);
      opacity:.96;
      z-index:30;
      cursor:pointer;
      user-select:none;
    }
    .arrow-btn:active{transform:scale(.9); background:#b71c1c}
    .arrow-top{ top:-16px; left:50%; margin-left:-20px; }
    .arrow-bottom{ bottom:-16px; left:50%; margin-left:-20px; }
    .arrow-left{ left:-16px; top:50%; margin-top:-20px; }
    .arrow-right{ right:-16px; top:50%; margin-top:-20px; }

    /* controls */
    .primary-controls{
      display:flex; gap:15px; width:92%; max-width:380px;
      margin-bottom:10px;
    }
    .history-btn{
      flex:1; height:54px;
      font-size:18px; font-weight:900;
      border-radius:12px;
      background:#fff;
      border:2px solid #888;
      box-shadow:0 4px 0 #bbb;
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      transition:.08s;
    }
    .history-btn:active{transform:translateY(4px); box-shadow:none}
    .history-btn:disabled{
      background:#eee; border-color:#ccc; color:#aaa;
      box-shadow:none; transform:none; cursor:not-allowed;
    }

    .solver-area{
      width:92%; max-width:380px;
      margin-bottom:auto;
    }
    .solve-btn{
      width:100%;
      padding:14px 12px;
      font-size:16px; font-weight:1000;
      border:none; border-radius:10px;
      background:#4caf50; color:#fff;
      box-shadow:0 4px 0 #388e3c;
      cursor:pointer; transition:.08s;
    }
    .solve-btn:active{transform:translateY(4px); box-shadow:none}
    .solve-btn.solving{background:#ef5350; box-shadow:0 4px 0 #c62828}

    .danger-zone{
      margin-top:26px;
      width:100%;
      padding:15px 0 18px;
      border-top:1px solid #ddd;
      background:#eaeaea;
      display:flex; flex-direction:column; align-items:center; gap:10px;
    }
    .danger-desc{font-size:11px; color:#777}
    .secondary-btn-group{display:flex; gap:16px}
    .secondary-btn{
      background:#fff;
      border:1px solid #999;
      color:#555;
      padding:8px 18px;
      font-size:13px;
      border-radius:20px;
      cursor:pointer;
    }
    .secondary-btn:active{background:#ddd}

    /* overlay */
    #loading-overlay{
      display:none;
      position:fixed; inset:0;
      background:rgba(0,0,0,.62);
      z-index:100;
      color:#fff;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      text-align:center;
      padding:18px;
    }
    .spinner{
      width:40px; height:40px;
      border:4px solid #fff; border-top:4px solid transparent;
      border-radius:50%;
      animation:spin 1s linear infinite;
      margin-bottom:14px;
    }
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .overlay-sub{font-size:12px; margin-top:8px; opacity:.92; line-height:1.35}

    /* confetti canvas */
    #confetti{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      pointer-events:none;
      z-index:200;
      display:none;
    }
  </style>
</head>
<body>
  <h1>ã‚¢ã‚¤ã‚·ãƒ†ãƒ«ãƒ‹ã‚¤ã‚¬ã‚¿ãƒ‘ã‚ºãƒ«</h1>

  <div class="sound-wrap">
    <div class="sound-row">
      <button id="btn-bgm" class="sound-btn" onclick="toggleBGM()"><span>â™ª</span> BGM: OFF</button>
      <div class="sound-slider">
        <input id="bgm-vol" type="range" min="0" max="10" step="1" value="5" oninput="setBgmVol(this.value)">
        <div class="sound-val" id="bgm-val">5</div>
      </div>
    </div>
    <div class="sound-row">
      <button id="btn-se" class="sound-btn active" onclick="toggleSE()"><span>ğŸ”Š</span> åŠ¹æœéŸ³: ON</button>
      <div class="sound-slider">
        <input id="se-vol" type="range" min="0" max="10" step="1" value="5" oninput="setSeVol(this.value)">
        <div class="sound-val" id="se-val">5</div>
      </div>
    </div>
  </div>

  <div class="mode-selector">
    <button id="btn-up" class="mode-btn active" onclick="switchMode('up')">ç›®æŒ‡ã›!J1æ˜‡æ ¼</button>
    <button id="btn-champ" class="mode-btn" onclick="switchMode('champ')">ç›®æŒ‡ã›!J1å„ªå‹</button>
  </div>

  <div id="score-board">
    <div class="score-item">æ‰‹æ•°: <span id="current-moves">0</span></div>
    <div class="score-item">æœ€å°‘: <span id="best-score">-</span></div>
  </div>

  <div id="board-wrapper">
    <div id="board-container">
      <div id="goal-marker">â–¼ ç›®æŒ‡ã›!J1æ˜‡æ ¼ â–¼</div>
      <div id="game-board"></div>
    </div>
  </div>

  <div class="primary-controls">
    <button id="btn-undo" class="history-btn" onclick="undoMove()" disabled>â†© æˆ»ã‚‹</button>
    <button id="btn-redo" class="history-btn" onclick="redoMove()" disabled>é€²ã‚€ â†ª</button>
  </div>

  <div class="solver-area">
    <button id="btn-solve" class="solve-btn" onclick="toggleSolver()">æ¨¡ç¯„è§£ç­”ã‚’è¨ˆç®— (è‡ªå‹•å†ç”Ÿ)</button>
  </div>

  <div class="danger-zone">
    <span class="danger-desc">è¨­å®šãƒ»ãƒªã‚»ãƒƒãƒˆï¼ˆèª¤æ“ä½œé˜²æ­¢ã‚¨ãƒªã‚¢ï¼‰</span>
    <div class="secondary-btn-group">
      <button class="secondary-btn" onclick="resetGame()">æœ€åˆã«æˆ»ã™</button>
      <button class="secondary-btn" onclick="clearBestScore()">è¨˜éŒ²æ¶ˆå»</button>
    </div>
  </div>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <div style="font-weight:1000; font-size:16px;">è§£ã‚’æ¢ç´¢ä¸­...</div>
    <div class="overlay-sub" id="overlay-sub">
      â€»ç«¯æœ«ã«ã‚ˆã£ã¦ã¯æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™<br>
      ï¼ˆæ¢ç´¢ä¸­ã¯ç”»é¢ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„ï¼‰
    </div>
  </div>

  <canvas id="confetti"></canvas>

<script>
/* =========================================================
   TEAM COLORS (approx primary colors)
   ========================================================= */
const TEAM_COLORS = {
  // Albirex
  "æ–°æ½Ÿ":"#ff7a00",

  // Mode1 (J1æ˜‡æ ¼)
  "æ¨ªæµœFC":"#58b9e6",
  "æ¹˜å—":"#007a3d",
  "å¾³å³¶":"#0046a1",
  "ç£ç”°":"#7bc6ff",
  "å¤§å®®":"#ff6a00",
  "ä»™å°":"#f2b400",
  "é³¥æ –":"#e4007f",
  "ã„ã‚ã":"#d50000",
  "å±±å½¢":"#003e9c",
  "ä»Šæ²»":"#003a70",
  "æœ­å¹Œ":"#b0001a",
  "ç”²åºœ":"#0033a0",
  "ç§‹ç”°":"#0b3d91",
  "è—¤æ":"#6a1b9a",

  // Mode2 (J1å„ªå‹)
  "é¹¿å³¶":"#b50018",
  "æŸ":"#ffd000",
  "äº¬éƒ½":"#5b2c83",
  "åºƒå³¶":"#6a1b9a",
  "ç¥æˆ¸":"#7a0019",
  "ç”ºç”°":"#0047ab",
  "æµ¦å’Œ":"#d40000",
  "å·å´":"#00a3e0",
  "Gå¤§é˜ª":"#0056a6",
  "Cå¤§é˜ª":"#ff2aa1",
  "Fæ±äº¬":"#005bac",
  "ç¦å²¡":"#008b4a",
  "å²¡å±±":"#7a0019"
};

function pickTextColor(bgHex){
  // bgHex: "#rrggbb"
  if(!bgHex || bgHex[0] !== '#' || bgHex.length !== 7) return "#111";
  const r = parseInt(bgHex.slice(1,3),16);
  const g = parseInt(bgHex.slice(3,5),16);
  const b = parseInt(bgHex.slice(5,7),16);
  // relative luminance
  const lum = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
  return lum < 0.55 ? "#fff" : "#111";
}

/* =========================================================
   SOUND (WebAudio) - 10 steps, louder max, pop 8bit loop16
   ========================================================= */
const Sound = {
  ctx:null,
  master:null,
  bgmBus:null,
  seBus:null,

  bgmEnabled:false,
  seEnabled:true,

  bgmVol:5, // 0..10
  seVol:5,  // 0..10

  isBgmPlaying:false,
  nextStepTime:0,
  stepIndex:0,
  timer:null,
  currentModeKey:'up',

  init(){
    if(!this.ctx){
      const AC = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AC();

      this.master = this.ctx.createGain();
      this.bgmBus  = this.ctx.createGain();
      this.seBus   = this.ctx.createGain();

      this.bgmBus.connect(this.master);
      this.seBus.connect(this.master);
      this.master.connect(this.ctx.destination);
    }
    if(this.ctx.state === 'suspended') this.ctx.resume();
    this.applyVolumes();
  },

  applyVolumes(){
    // â˜…æœ€å¤§å€¤ã‚’å¤§å¹…ã«å¤§ããï¼ˆ10æ®µéšï¼‰
    // BGM: max ~0.35 / SE: max ~1.10
    const bgmGain = (this.bgmVol/10) * 0.35;
    const seGain  = (this.seVol/10)  * 1.10;

    this.bgmBus.gain.value = this.bgmEnabled ? bgmGain : 0;
    this.seBus.gain.value  = this.seEnabled  ? seGain  : 0;
  },

  playMove(){
    if(!this.seEnabled || this.seVol === 0) return;
    this.init();
    const t = this.ctx.currentTime;

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(440, t);
    osc.frequency.exponentialRampToValueAtTime(220, t + 0.06);

    gain.gain.setValueAtTime(0.0, t);
    gain.gain.linearRampToValueAtTime(0.18, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.09);

    osc.connect(gain);
    gain.connect(this.seBus);

    osc.start(t);
    osc.stop(t + 0.10);
  },

  playWin(){
    if(!this.seEnabled || this.seVol === 0) return;
    this.init();
    const base = this.ctx.currentTime;
    const freqs = [523.25, 659.25, 783.99, 1046.50]; // C5 E5 G5 C6
    freqs.forEach((f, i)=>{
      const t = base + i*0.11;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = 'square';
      osc.frequency.value = f;

      gain.gain.setValueAtTime(0.0, t);
      gain.gain.linearRampToValueAtTime(0.22, t+0.03);
      gain.gain.exponentialRampToValueAtTime(0.001, t+0.65);

      osc.connect(gain);
      gain.connect(this.seBus);

      osc.start(t);
      osc.stop(t+0.75);
    });
  },

  startBGM(){
    if(!this.bgmEnabled || this.bgmVol === 0) return;
    this.init();
    if(this.isBgmPlaying) return;
    this.isBgmPlaying = true;
    this.stepIndex = 0;
    this.nextStepTime = this.ctx.currentTime + 0.10;
    this._schedule();
  },

  stopBGM(){
    this.isBgmPlaying = false;
    if(this.timer) clearTimeout(this.timer);
    this.timer = null;
  },

  _schedule(){
    if(!this.isBgmPlaying) return;

    // schedule ~0.5s ahead
    while(this.nextStepTime < this.ctx.currentTime + 0.50){
      this._playStep(this.nextStepTime, this.stepIndex);
      this.stepIndex = (this.stepIndex + 1) % 16; // â˜…ãƒ«ãƒ¼ãƒ—16
      this.nextStepTime += 0.125; // 16th note feel
    }

    this.timer = setTimeout(()=>this._schedule(), 60);
  },

  _noteFreq(semi){
    // A4=440, semi offset from A4
    return 440 * Math.pow(2, semi/12);
  },

  _playStep(time, step){
    // â˜…ãƒãƒƒãƒ—å¯„ã‚Šï¼ˆãƒ•ã‚¡ãƒŸã‚³ãƒ³ã‚¹ãƒãƒ¼ãƒ„æ„Ÿï¼‰ã®å˜éŸ³ãƒ•ãƒ¬ãƒ¼ã‚º
    // modeã§å°‘ã—ã ã‘è‰²ã‚’å¤‰ãˆã‚‹ï¼ˆã©ã¡ã‚‰ã‚‚16ã‚¹ãƒ†ãƒƒãƒ—ï¼‰
    const seqUp = [
      0,  7,  9,  7,
      0,  7, 12,  0,
      0,  4,  7,  4,
      0,  2,  4,  0
    ];
    const seqChamp = [
      0,  7,  9, 12,
      0, 12, 14, 12,
      0,  7,  9,  7,
      0,  4,  7,  0
    ];

    const seq = (this.currentModeKey === 'champ') ? seqChamp : seqUp;
    const deg = seq[step];
    if(deg === 0) return;

    // C major-ish around C5 (semi offset from A4: C5=+3)
    const base = 3; // C5
    const semi = base + deg;

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    osc.type = 'square';
    osc.frequency.value = this._noteFreq(semi);

    filter.type = 'lowpass';
    filter.frequency.value = 1400;

    // short chiptune envelope
    gain.gain.setValueAtTime(0.0, time);
    gain.gain.linearRampToValueAtTime(0.30, time + 0.008);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.10);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.bgmBus);

    osc.start(time);
    osc.stop(time + 0.12);
  }
};

function loadSoundSettings(){
  const bgm = localStorage.getItem('aishiteru_bgm');
  const se  = localStorage.getItem('aishiteru_se');
  const bgmVol = localStorage.getItem('aishiteru_bgm_vol');
  const seVol  = localStorage.getItem('aishiteru_se_vol');

  Sound.bgmEnabled = (bgm === 'on');
  Sound.seEnabled  = (se !== 'off'); // default ON
  Sound.bgmVol = bgmVol ? Math.max(0, Math.min(10, parseInt(bgmVol,10))) : 5;
  Sound.seVol  = seVol  ? Math.max(0, Math.min(10, parseInt(seVol,10)))  : 5;

  document.getElementById('bgm-vol').value = String(Sound.bgmVol);
  document.getElementById('se-vol').value  = String(Sound.seVol);
  document.getElementById('bgm-val').textContent = String(Sound.bgmVol);
  document.getElementById('se-val').textContent  = String(Sound.seVol);

  updateSoundUI();
}

function updateSoundUI(){
  const btnBGM = document.getElementById('btn-bgm');
  const btnSE  = document.getElementById('btn-se');

  if(Sound.bgmEnabled && Sound.bgmVol > 0){
    btnBGM.classList.add('active');
    btnBGM.innerHTML = '<span>â™ª</span> BGM: ON';
  }else{
    btnBGM.classList.remove('active');
    btnBGM.innerHTML = '<span>â™ª</span> BGM: OFF';
  }

  if(Sound.seEnabled && Sound.seVol > 0){
    btnSE.classList.add('active');
    btnSE.innerHTML = '<span>ğŸ”Š</span> åŠ¹æœéŸ³: ON';
  }else{
    btnSE.classList.remove('active');
    btnSE.innerHTML = '<span>ğŸ”ˆ</span> åŠ¹æœéŸ³: OFF';
  }

  Sound.applyVolumes();
}

function toggleBGM(){
  Sound.init();
  Sound.bgmEnabled = !Sound.bgmEnabled;
  localStorage.setItem('aishiteru_bgm', Sound.bgmEnabled ? 'on' : 'off');
  Sound.applyVolumes();
  if(Sound.bgmEnabled && Sound.bgmVol>0) Sound.startBGM(); else Sound.stopBGM();
  updateSoundUI();
}

function toggleSE(){
  Sound.init();
  Sound.seEnabled = !Sound.seEnabled;
  localStorage.setItem('aishiteru_se', Sound.seEnabled ? 'on' : 'off');
  Sound.applyVolumes();
  if(Sound.seEnabled && Sound.seVol>0) Sound.playMove();
  updateSoundUI();
}

function setBgmVol(v){
  Sound.init();
  Sound.bgmVol = Math.max(0, Math.min(10, parseInt(v,10)));
  localStorage.setItem('aishiteru_bgm_vol', String(Sound.bgmVol));
  document.getElementById('bgm-val').textContent = String(Sound.bgmVol);

  Sound.applyVolumes();
  if(Sound.bgmEnabled && Sound.bgmVol>0) Sound.startBGM(); else Sound.stopBGM();
  updateSoundUI();
}

function setSeVol(v){
  Sound.init();
  Sound.seVol = Math.max(0, Math.min(10, parseInt(v,10)));
  localStorage.setItem('aishiteru_se_vol', String(Sound.seVol));
  document.getElementById('se-val').textContent = String(Sound.seVol);

  Sound.applyVolumes();
  updateSoundUI();
}

/* =========================================================
   GAME
   ========================================================= */
const COLS=6, ROWS=5, UNIT=60;

const MODES = {
  up:   { label:'ç›®æŒ‡ã›!J1æ˜‡æ ¼',  storageBest:'aishiteru_best_up'   },
  champ:{ label:'ç›®æŒ‡ã›!J1å„ªå‹',  storageBest:'aishiteru_best_champ'}
};

const layout = {
  up: [
    { id: 7, name:"æ¨ªæµœFC", w:2, h:1, x:0, y:0, isMain:false },
    { id: 6, name:"å¾³å³¶",   w:2, h:1, x:2, y:0, isMain:false },
    { id: 3, name:"é³¥æ –",   w:1, h:2, x:4, y:0, isMain:false },
    { id: 4, name:"ä»Šæ²»",   w:1, h:2, x:5, y:0, isMain:false },
    { id: 1, name:"æ¹˜å—",   w:1, h:2, x:0, y:1, isMain:false },
    { id: 2, name:"ç£ç”°",   w:1, h:2, x:1, y:1, isMain:false },
    { id: 5, name:"å¤§å®®",   w:1, h:2, x:2, y:1, isMain:false },
    { id:15, name:"ã„ã‚ã", w:1, h:1, x:3, y:1, isMain:false },
    { id:12, name:"æœ­å¹Œ",   w:1, h:1, x:3, y:2, isMain:false },
    { id: 9, name:"ä»™å°",   w:2, h:1, x:0, y:3, isMain:false },
    { id: 8, name:"ç”²åºœ",   w:2, h:1, x:2, y:3, isMain:false },
    { id:10, name:"å±±å½¢",   w:2, h:1, x:0, y:4, isMain:false },
    { id:13, name:"ç§‹ç”°",   w:1, h:1, x:2, y:4, isMain:false },
    { id:14, name:"è—¤æ",   w:1, h:1, x:3, y:4, isMain:false },
    { id:99, name:"æ–°æ½Ÿ",   w:2, h:2, x:4, y:3, isMain:true  }
  ],
  champ: [
    // â€»ã‚µã‚¤ã‚ºãƒ»ç›¤é¢ã¯å›ºå®šæ¡ä»¶ï¼ˆ6x5 / ç©ºã2 / ãƒ¡ã‚¤ãƒ³2x2ï¼‰ã‚’ç¶­æŒã—ãŸã€Œå¿…ãšè§£ã‘ã‚‹ã€æ–°é…ç½®
    { id: 1,  name:"ç¦å²¡", w:2, h:1, x:0, y:2, isMain:false },
    { id: 2,  name:"äº¬éƒ½", w:2, h:1, x:1, y:4, isMain:false },
    { id: 3,  name:"å²¡å±±", w:2, h:1, x:0, y:0, isMain:false },
    { id: 4,  name:"ç”ºç”°", w:2, h:1, x:4, y:1, isMain:false },
    { id: 5,  name:"ç¥æˆ¸", w:2, h:1, x:2, y:0, isMain:false },
    { id: 6,  name:"é¹¿å³¶", w:2, h:1, x:2, y:2, isMain:false },
    { id: 7,  name:"å·å´", w:2, h:1, x:4, y:0, isMain:false },
    { id: 8,  name:"å²¡å±±", w:1, h:2, x:5, y:2, isMain:false }, // placeholder (will be overwritten below)
    { id: 9,  name:"Cå¤§é˜ª", w:1, h:2, x:0, y:3, isMain:false },
    { id:10,  name:"æµ¦å’Œ", w:1, h:2, x:0, y:1, isMain:false },
    { id:11,  name:"æŸ",   w:1, h:2, x:1, y:0, isMain:false },
    { id:12,  name:"Fæ±äº¬", w:1, h:1, x:2, y:1, isMain:false },
    { id:13,  name:"åºƒå³¶", w:1, h:1, x:3, y:1, isMain:false },
    { id:99,  name:"æ–°æ½Ÿ", w:2, h:2, x:4, y:3, isMain:true  }
  ]
};

// --- champ mode: ensure "names order near goal" is preserved and layout is solvable
// We pre-generated a guaranteed-solvable state (by scrambling from goal), then assigned names by distance.
(function patchChampLayout(){
  // This block set is carefully generated. Names are reassigned here to guarantee the requested order-by-distance.
  const names = ["é¹¿å³¶","æŸ","äº¬éƒ½","åºƒå³¶","ç¥æˆ¸","ç”ºç”°","æµ¦å’Œ","å·å´","Gå¤§é˜ª","Cå¤§é˜ª","Fæ±äº¬","ç¦å²¡","å²¡å±±"];

  const champ = layout.champ;
  const mainIdx = champ.findIndex(b=>b.isMain);

  // sort non-main blocks by distance to goal, then y, then x
  const idxs = champ.map((b,i)=>i).filter(i=>i!==mainIdx)
    .sort((i,j)=>{
      const bi=champ[i], bj=champ[j];
      const di=(bi.x+bi.y), dj=(bj.x+bj.y);
      if(di!==dj) return di-dj;
      if(bi.y!==bj.y) return bi.y-bj.y;
      return bi.x-bj.x;
    });

  idxs.forEach((idx,k)=>{ champ[idx].name = names[k]; });

  // also ensure sizes are exactly the requested counts:
  // horizontals:7, verticals:4, singles:2, main:1 (already ok by construction)
})();

const el = {
  board: document.getElementById('game-board'),
  moves: document.getElementById('current-moves'),
  best:  document.getElementById('best-score'),
  btnUp:  document.getElementById('btn-up'),
  btnCh:  document.getElementById('btn-champ'),
  undo:  document.getElementById('btn-undo'),
  redo:  document.getElementById('btn-redo'),
  solve: document.getElementById('btn-solve'),
  overlay: document.getElementById('loading-overlay'),
  overlaySub: document.getElementById('overlay-sub'),
  goal: document.getElementById('goal-marker'),
  wrap: document.getElementById('board-wrapper'),
  container: document.getElementById('board-container'),
  confetti: document.getElementById('confetti')
};

let mode = 'up';
let blocks = [];
let moveCount = 0;
let selected = -1;

let undoStack = [];
let redoStack = [];

let isAuto = false;
let autoMoves = [];
let autoTimer = null;

let solverWorker = null;
let solverCancelToken = 0;

function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

function fitBoard(){
  // â˜…ç›¤é¢ã¨ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚ºãƒ¬å¯¾ç­–ï¼šå®Ÿå¯¸ï¼ˆoffsetï¼‰ã‹ã‚‰ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ç®—å‡º
  const container = el.container;
  const wrapper = el.wrap;

  const baseW = container.offsetWidth;
  const extraTop = 32; // goal marker area
  const baseH = container.offsetHeight + extraTop;

  const screenW = Math.max(280, window.innerWidth - 24);
  const screenH = Math.max(300, window.innerHeight * 0.56);

  let scale = screenW / baseW;
  if(baseH * scale > screenH) scale = screenH / baseH;
  if(scale > 1.35) scale = 1.35;

  container.style.transform = `translateX(-50%) scale(${scale})`;

  wrapper.style.width  = `${baseW * scale}px`;
  wrapper.style.height = `${baseH * scale}px`;
}
window.addEventListener('load', fitBoard);
window.addEventListener('resize', fitBoard);

function getBestKey(){ return MODES[mode].storageBest; }

function loadBest(){
  const v = localStorage.getItem(getBestKey());
  el.best.textContent = v ? v : '-';
}
function saveBest(score){
  const key = getBestKey();
  const cur = localStorage.getItem(key);
  if(!cur || score < parseInt(cur,10)){
    localStorage.setItem(key, String(score));
    el.best.textContent = String(score);
  }
}

function clearBestScore(){
  if(confirm('ç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰ã®è¨˜éŒ²ã‚’æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ')){
    localStorage.removeItem(getBestKey());
    el.best.textContent = '-';
  }
}

function setModeUI(){
  if(mode === 'up'){
    el.btnUp.classList.add('active'); el.btnCh.classList.remove('active');
  }else{
    el.btnUp.classList.remove('active'); el.btnCh.classList.add('active');
  }
  const label = MODES[mode].label;
  el.goal.textContent = `â–¼ ${label} â–¼`;

  Sound.currentModeKey = mode;
  if(Sound.bgmEnabled && Sound.bgmVol>0){
    Sound.stopBGM();
    Sound.startBGM();
  }
}

function switchMode(next){
  stopAuto();
  cancelSolver();
  mode = next;
  setModeUI();
  loadBest();
  resetGame();
}

function resetGame(){
  stopAuto();
  cancelSolver();

  blocks = deepCopy(layout[mode]);
  moveCount = 0;
  selected = -1;
  undoStack = [];
  redoStack = [];
  updateHud();
  render();
}

function updateHud(){
  el.moves.textContent = String(moveCount);
  el.undo.disabled = (undoStack.length === 0) || isAuto;
  el.redo.disabled = (redoStack.length === 0) || isAuto;
}

function canMove(block, dx, dy){
  const nx = block.x + dx;
  const ny = block.y + dy;
  if(nx < 0 || nx + block.w > COLS) return false;
  if(ny < 0 || ny + block.h > ROWS) return false;

  for(const o of blocks){
    if(o === block) continue;
    if(nx < o.x + o.w && nx + block.w > o.x &&
       ny < o.y + o.h && ny + block.h > o.y){
      return false;
    }
  }
  return true;
}

function getValidMovesFor(index){
  const b = blocks[index];
  const dirs = [
    {dx:0, dy:-1, cls:'arrow-top',    ch:'&#9650;', dir:0},
    {dx:0, dy: 1, cls:'arrow-bottom', ch:'&#9660;', dir:1},
    {dx:-1,dy: 0, cls:'arrow-left',   ch:'&#9664;', dir:2},
    {dx: 1,dy: 0, cls:'arrow-right',  ch:'&#9654;', dir:3}
  ];
  return dirs.filter(d => canMove(b, d.dx, d.dy));
}

function applyMove(idx, dx, dy){
  blocks[idx].x += dx;
  blocks[idx].y += dy;
}

function doMove(idx, dx, dy, {record=true, sound=true}={}){
  if(sound) Sound.playMove();
  applyMove(idx, dx, dy);
  moveCount++;
  if(record){
    undoStack.push({index:idx, dx, dy});
    redoStack = [];
  }
  selected = -1;
  updateHud();
  render();
  setTimeout(checkWin, 80);
}

function undoMove(){
  if(undoStack.length === 0 || isAuto) return;
  Sound.playMove();
  const m = undoStack.pop();
  applyMove(m.index, -m.dx, -m.dy);
  redoStack.push(m);
  moveCount--;
  selected = -1;
  updateHud();
  render();
}

function redoMove(){
  if(redoStack.length === 0 || isAuto) return;
  Sound.playMove();
  const m = redoStack.pop();
  applyMove(m.index, m.dx, m.dy);
  undoStack.push(m);
  moveCount++;
  selected = -1;
  updateHud();
  render();
  setTimeout(checkWin, 80);
}

/* =========================================================
   CONFETTI
   ========================================================= */
let confettiAnim = null;
function startConfetti(durationMs=2200){
  const canvas = el.confetti;
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  function resize(){
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resize();
  window.addEventListener('resize', resize, {passive:true});

  const colors = [
    "#ff7a00","#58b9e6","#007a3d","#ffd000","#ff2aa1","#6a1b9a","#ffffff"
  ];
  const pieces = [];
  const n = 140;

  for(let i=0;i<n;i++){
    pieces.push({
      x: Math.random()*window.innerWidth,
      y: -20 - Math.random()*window.innerHeight*0.4,
      vx: (Math.random()-0.5)*3.2,
      vy: 2.2 + Math.random()*4.2,
      w: 6 + Math.random()*6,
      h: 8 + Math.random()*10,
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.25,
      color: colors[Math.floor(Math.random()*colors.length)],
      alpha: 0.85 + Math.random()*0.15
    });
  }

  canvas.style.display = 'block';
  const t0 = performance.now();

  function tick(now){
    const t = now - t0;
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

    pieces.forEach(p=>{
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.vr;
      p.vy += 0.02; // gravity
      if(p.x < -30) p.x = window.innerWidth + 30;
      if(p.x > window.innerWidth + 30) p.x = -30;

      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });

    if(t < durationMs){
      confettiAnim = requestAnimationFrame(tick);
    }else{
      cancelAnimationFrame(confettiAnim);
      confettiAnim = null;
      canvas.style.display = 'none';
      window.removeEventListener('resize', resize);
    }
  }
  confettiAnim = requestAnimationFrame(tick);
}

function checkWin(){
  const main = blocks.find(b=>b.isMain);
  if(main && main.x === 0 && main.y === 0){
    if(isAuto) stopAuto();

    // æ¼”å‡º
    startConfetti(2400);
    Sound.playWin();

    setTimeout(()=>{
      alert(`ã‚¯ãƒªã‚¢ï¼\nãƒ¢ãƒ¼ãƒ‰: ${MODES[mode].label}\nç§»å‹•å›æ•°: ${moveCount}å›`);
      saveBest(moveCount);
    }, 520);
  }
}

function render(){
  el.board.innerHTML = '';

  blocks.forEach((b, i)=>{
    const d = document.createElement('div');
    d.className = 'block';

    const bg = TEAM_COLORS[b.name] || 'var(--block)';
    d.style.background = bg;
    d.style.color = pickTextColor(bg);

    if(i === selected) d.classList.add('selected');
    if(isAuto && i === selected) d.classList.add('auto');

    d.style.width  = (b.w*UNIT)+'px';
    d.style.height = (b.h*UNIT)+'px';
    d.style.left   = (b.x*UNIT)+'px';
    d.style.top    = (b.y*UNIT)+'px';

    // direction: vertical for 1x2 and main, otherwise horizontal.
    let dir = 'h';
    if(b.isMain) dir = 'v';
    else if(b.w < b.h) dir = 'v';
    else if(b.w === 1 && b.h === 1) dir = 'h'; // â˜…1x1ã¯æ°´å¹³ï¼ˆã„ã‚ãå¯¾ç­–ï¼‰

    d.classList.add(dir === 'v' ? 'vertical' : 'horizontal');

    // font size tuning (1x1ã§3æ–‡å­—ä»¥ä¸Šã¯å°ã•ã‚ï¼ã„ã‚ãå¯¾ç­–)
    if(b.isMain){
      d.style.fontSize = '40px';
      d.style.letterSpacing = '1px';
    }else if(b.w === 1 && b.h === 1){
      const len = String(b.name).length;
      d.style.fontSize = (len >= 3) ? '14px' : '18px';
      d.style.letterSpacing = '0px';
    }else if(b.name.length <= 2){
      d.style.fontSize = '22px';
    }else if(b.name.length >= 5){
      d.style.fontSize = '15px';
    }else{
      d.style.fontSize = '18px';
    }

    const id = document.createElement('span');
    id.className = 'block-id';
    id.textContent = b.id;
    d.appendChild(id);

    d.appendChild(document.createTextNode(b.name));

    if(!isAuto){
      d.onclick = (e)=>{
        Sound.init(); // unlock
        e.stopPropagation();
        onBlockTap(i);
      };

      if(i === selected){
        const moves = getValidMovesFor(i);
        moves.forEach(m=>{
          const a = document.createElement('div');
          a.className = `arrow-btn ${m.cls}`;
          a.innerHTML = m.ch;
          a.onclick = (e)=>{
            e.stopPropagation();
            doMove(i, m.dx, m.dy);
          };
          d.appendChild(a);
        });
      }
    }

    el.board.appendChild(d);
  });
}

function onBlockTap(i){
  if(isAuto) return;
  if(selected === i){
    selected = -1; render(); return;
  }
  const moves = getValidMovesFor(i);
  if(moves.length === 0) return;

  if(moves.length === 1){
    doMove(i, moves[0].dx, moves[0].dy);
    return;
  }
  selected = i;
  render();
}

document.body.addEventListener('click', ()=>{
  if(isAuto) return;
  if(selected !== -1){
    selected = -1;
    render();
  }
});

/* =========================================================
   SOLVER (WebWorker) - fast A* (BigInt key + parent pointer) -> Beam fallback
   + cache in localStorage
   ========================================================= */
function toggleSolver(){
  if(isAuto) stopAuto();
  else startSolver();
}

function stopAuto(){
  isAuto = false;
  if(autoTimer) clearInterval(autoTimer);
  autoTimer = null;
  el.solve.textContent = 'æ¨¡ç¯„è§£ç­”ã‚’è¨ˆç®— (è‡ªå‹•å†ç”Ÿ)';
  el.solve.classList.remove('solving');
  selected = -1;
  updateHud();
  render();
}

function cancelSolver(){
  solverCancelToken++;
  if(solverWorker){
    try{ solverWorker.terminate(); }catch(_){}
    solverWorker = null;
  }
  el.overlay.style.display = 'none';
}

function packStateBigInt(blocks){
  // pack x,y with 3bits each => 6bits per block
  let key = 0n;
  for(let i=0;i<blocks.length;i++){
    const x = BigInt(blocks[i].x);
    const y = BigInt(blocks[i].y);
    key = (key << 6n) | (x << 3n) | y;
  }
  return key;
}

function startSolver(){
  Sound.init();
  const main = blocks.find(b=>b.isMain);
  if(main && main.x===0 && main.y===0){
    alert('æ—¢ã«ã‚´ãƒ¼ãƒ«ã—ã¦ã„ã¾ã™ã€‚');
    return;
  }

  // â˜…ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆåŒä¸€çŠ¶æ…‹ãªã‚‰å³æ™‚ï¼‰
  const stateKey = packStateBigInt(blocks).toString(36);
  const cacheKey = `aishiteru_cache_${mode}_${stateKey}`;
  const cached = localStorage.getItem(cacheKey);
  if(cached){
    try{
      const moves = JSON.parse(cached);
      if(Array.isArray(moves) && moves.length){
        if(confirm(`${moves.length} æ‰‹ã®è§£ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰ãŒã‚ã‚Šã¾ã™ã€‚\nè‡ªå‹•å†ç”Ÿã—ã¾ã™ã‹ï¼Ÿ`)){
          isAuto = true;
          autoMoves = moves;
          el.solve.textContent = 'è‡ªå‹•å†ç”Ÿã‚’åœæ­¢';
          el.solve.classList.add('solving');
          updateHud();
          playAuto();
          return;
        }
      }
    }catch(_){}
  }

  // show overlay
  el.overlaySub.innerHTML = 'â€»ç«¯æœ«ã«ã‚ˆã£ã¦ã¯æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™<br>ï¼ˆæ¢ç´¢ä¸­ã¯ç”»é¢ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„ï¼‰';
  el.overlay.style.display = 'flex';

  const token = ++solverCancelToken;

  const workerScript = `
    const COLS=6, ROWS=5;

    function buildInfo(blocks){
      return blocks.map(b=>({w:b.w|0, h:b.h|0, isMain:!!b.isMain}));
    }
    function buildState(blocks){
      const s = new Int8Array(blocks.length*2);
      for(let i=0;i<blocks.length;i++){
        s[i*2]   = blocks[i].x|0;
        s[i*2+1] = blocks[i].y|0;
      }
      return s;
    }
    function keyOf(state){
      // BigInt key (6 bits per block: xxx yyy)
      let k = 0n;
      for(let i=0;i<state.length;i+=2){
        const x = BigInt(state[i]);
        const y = BigInt(state[i+1]);
        k = (k << 6n) | (x << 3n) | y;
      }
      return k;
    }
    function canMoveRaw(idx, dx, dy, st, info){
      const w = info[idx].w, h = info[idx].h;
      const cx = st[idx*2], cy = st[idx*2+1];
      const nx = cx + dx, ny = cy + dy;

      if(nx < 0 || nx + w > COLS) return false;
      if(ny < 0 || ny + h > ROWS) return false;

      const n = info.length;
      for(let i=0;i<n;i++){
        if(i===idx) continue;
        const ox = st[i*2], oy = st[i*2+1];
        const ow = info[i].w, oh = info[i].h;
        if(nx < ox + ow && nx + w > ox &&
           ny < oy + oh && ny + h > oy){
          return false;
        }
      }
      return true;
    }

    function heuristic(st, mainIdx, info){
      const mx = st[mainIdx*2];
      const my = st[mainIdx*2+1];
      let dist = mx + my;

      // penalty: blocks in rectangle between goal and main
      const minX = 0, minY = 0;
      const maxX = mx, maxY = my;

      let pen = 0;
      for(let i=0;i<info.length;i++){
        if(i===mainIdx) continue;
        const x = st[i*2], y = st[i*2+1];
        const w = info[i].w, h = info[i].h;
        const inRect = !(x+w-1 < minX || x > maxX || y+h-1 < minY || y > maxY);
        if(inRect) pen++;
      }
      return dist + pen*0.65;
    }

    class MinHeap{
      constructor(){ this.a=[]; }
      push(x){
        const a=this.a; a.push(x);
        let i=a.length-1;
        while(i>0){
          const p=(i-1)>>1;
          if(a[p].f <= a[i].f) break;
          const t=a[p]; a[p]=a[i]; a[i]=t;
          i=p;
        }
      }
      pop(){
        const a=this.a;
        if(a.length===0) return null;
        const top=a[0];
        const last=a.pop();
        if(a.length){
          a[0]=last;
          let i=0;
          for(;;){
            const l=i*2+1, r=l+1;
            let m=i;
            if(l<a.length && a[l].f < a[m].f) m=l;
            if(r<a.length && a[r].f < a[m].f) m=r;
            if(m===i) break;
            const t=a[m]; a[m]=a[i]; a[i]=t;
            i=m;
          }
        }
        return top;
      }
      get size(){ return this.a.length; }
    }

    function reconstruct(parent, movePack, nodeId){
      const out=[];
      while(nodeId !== -1){
        const mp = movePack[nodeId];
        const p = parent[nodeId];
        if(mp !== -1){
          const idx = mp >>> 2;
          const dir = mp & 3;
          let dx=0, dy=0;
          if(dir===0) dy=-1;
          else if(dir===1) dy=1;
          else if(dir===2) dx=-1;
          else dx=1;
          out.push({index:idx, dx, dy});
        }
        nodeId = p;
      }
      out.reverse();
      return out;
    }

    async function solveAStar(startBlocks, opt){
      const info = buildInfo(startBlocks);
      const mainIdx = startBlocks.findIndex(b=>b.isMain);
      const startState = buildState(startBlocks);

      const SHIFT = 1 << 22; // allow nodeId up to ~4.1M
      const best = new Map(); // key -> packed(g,nodeId)

      const states = [];
      const parent = [];
      const movePack = [];

      function newNode(st, g, pId, mp){
        const id = states.length;
        states.push(st);
        parent.push(pId);
        movePack.push(mp);
        return id;
      }

      const heap = new MinHeap();
      const k0 = keyOf(startState);
      const h0 = heuristic(startState, mainIdx, info);
      const rootId = newNode(startState, 0, -1, -1);

      best.set(k0, 0 * SHIFT + rootId);
      heap.push({f: opt.weight*h0, g:0, id:rootId});

      const dirs = [
        {dx:0,dy:-1,dir:0},
        {dx:0,dy:1, dir:1},
        {dx:-1,dy:0,dir:2},
        {dx:1,dy:0, dir:3}
      ];

      const t0 = performance.now();
      let expanded = 0;
      let lastReport = 0;

      while(heap.size){
        const now = performance.now();
        if(now - t0 > opt.timeLimitMs) return null;
        if(expanded > opt.expandLimit) return null;

        const node = heap.pop();
        const st = states[node.id];

        if(st[mainIdx*2]===0 && st[mainIdx*2+1]===0){
          return reconstruct(parent, movePack, node.id);
        }

        expanded++;
        if(expanded - lastReport >= 9000){
          lastReport = expanded;
          postMessage({cmd:'progress', expanded, elapsed: Math.round(now - t0)});
        }

        for(let i=0;i<info.length;i++){
          for(const d of dirs){
            if(!canMoveRaw(i, d.dx, d.dy, st, info)) continue;

            const ns = new Int8Array(st);
            ns[i*2]   += d.dx;
            ns[i*2+1] += d.dy;

            const nk = keyOf(ns);
            const ng = node.g + 1;

            const prev = best.get(nk);
            if(prev !== undefined){
              const pg = (prev / SHIFT) | 0;
              if(pg <= ng) continue;
            }

            const nid = newNode(ns, ng, node.id, (i<<2) | d.dir);
            best.set(nk, ng * SHIFT + nid);

            const nh = heuristic(ns, mainIdx, info);
            const nf = ng + opt.weight*nh;
            heap.push({f:nf, g:ng, id:nid});
          }
        }
      }
      return null;
    }

    async function solveBeam(startBlocks, opt){
      const info = buildInfo(startBlocks);
      const mainIdx = startBlocks.findIndex(b=>b.isMain);
      const start = buildState(startBlocks);

      const dirs = [
        {dx:0,dy:-1,dir:0},
        {dx:0,dy:1, dir:1},
        {dx:-1,dy:0,dir:2},
        {dx:1,dy:0, dir:3}
      ];

      const visited = new Set();
      visited.add(keyOf(start));

      const states = [start];
      const parent = [-1];
      const movePack = [-1];

      function newNode(st, pId, mp){
        const id = states.length;
        states.push(st);
        parent.push(pId);
        movePack.push(mp);
        return id;
      }

      let level = [{id:0, score:heuristic(start, mainIdx, info), depth:0}];
      const t0 = performance.now();
      let expanded = 0;

      for(let depth=0; depth<opt.maxDepth; depth++){
        if(performance.now() - t0 > opt.timeLimitMs) return null;

        const next = [];
        for(const node of level){
          const st = states[node.id];
          if(st[mainIdx*2]===0 && st[mainIdx*2+1]===0){
            return reconstruct(parent, movePack, node.id);
          }

          for(let i=0;i<info.length;i++){
            for(const d of dirs){
              if(!canMoveRaw(i, d.dx, d.dy, st, info)) continue;

              const ns = new Int8Array(st);
              ns[i*2]   += d.dx;
              ns[i*2+1] += d.dy;

              const k = keyOf(ns);
              if(visited.has(k)) continue;
              visited.add(k);

              const nid = newNode(ns, node.id, (i<<2) | d.dir);
              const h = heuristic(ns, mainIdx, info);
              const score = (depth+1) + h*5.0;
              next.push({id:nid, score, depth:depth+1});
              expanded++;
            }
          }
        }

        if(expanded % 20000 === 0){
          postMessage({cmd:'progress', expanded, elapsed: Math.round(performance.now() - t0)});
        }

        if(next.length === 0) return null;
        next.sort((a,b)=>a.score-b.score);
        level = next.length > opt.beamWidth ? next.slice(0,opt.beamWidth) : next;
      }

      return null;
    }

    onmessage = async (e)=>{
      const msg = e.data;
      if(!msg || msg.cmd !== 'solve') return;

      const blocks = msg.blocks;
      try{
        // stage A*: quick
        let moves = await solveAStar(blocks, {timeLimitMs: 4500, expandLimit: 260000, weight: 2.45});
        // stage A*: deeper
        if(!moves) moves = await solveAStar(blocks, {timeLimitMs: 9500, expandLimit: 700000, weight: 2.05});
        // stage Beam fallback
        if(!moves) moves = await solveBeam(blocks, {timeLimitMs: 28000, maxDepth: 2800, beamWidth: 1700});

        postMessage({cmd:'done', moves});
      }catch(err){
        postMessage({cmd:'error', error: String(err && err.message ? err.message : err)});
      }
    };
  `;

  const blob = new Blob([workerScript], {type:'application/javascript'});
  solverWorker = new Worker(URL.createObjectURL(blob));

  solverWorker.onmessage = (ev)=>{
    if(token !== solverCancelToken) return;

    const msg = ev.data;
    if(!msg) return;

    if(msg.cmd === 'progress'){
      el.overlaySub.innerHTML = `æ¢ç´¢ä¸­...<br>å±•é–‹: ${msg.expanded.toLocaleString()}<br>çµŒé: ${msg.elapsed} ms`;
      return;
    }

    if(msg.cmd === 'error'){
      el.overlay.style.display = 'none';
      alert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + msg.error);
      cancelSolver();
      return;
    }

    if(msg.cmd === 'done'){
      el.overlay.style.display = 'none';

      const moves = msg.moves;
      if(!moves){
        alert('è§£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸâ€¦ï¼ˆæ¢ç´¢ä¸Šé™ã«åˆ°é”ï¼‰');
        cancelSolver();
        return;
      }

      // store cache
      try{ localStorage.setItem(cacheKey, JSON.stringify(moves)); }catch(_){}

      if(confirm(`${moves.length} æ‰‹ã®è§£ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\nï¼ˆâ€»æœ€çŸ­ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰\n\nè‡ªå‹•å†ç”Ÿã—ã¾ã™ã‹ï¼Ÿ`)){
        isAuto = true;
        autoMoves = moves;
        el.solve.textContent = 'è‡ªå‹•å†ç”Ÿã‚’åœæ­¢';
        el.solve.classList.add('solving');
        updateHud();
        playAuto();
      }else{
        cancelSolver();
      }
    }
  };

  // post task
  solverWorker.postMessage({cmd:'solve', blocks: deepCopy(blocks)});
}

function playAuto(){
  let step = 0;
  autoTimer = setInterval(()=>{
    if(!isAuto){ stopAuto(); return; }
    if(step >= autoMoves.length){ stopAuto(); return; }

    const m = autoMoves[step++];
    selected = m.index;

    Sound.playMove();
    applyMove(m.index, m.dx, m.dy);
    moveCount++;
    undoStack.push(m);
    redoStack = [];

    updateHud();
    render();
    checkWin();
  }, 190);
}

/* =========================================================
   BOOT
   ========================================================= */
function init(){
  loadSoundSettings();
  setModeUI();
  loadBest();
  resetGame();

  // iOS/Android unlock + auto-start BGM if enabled
  document.body.addEventListener('pointerdown', function first(){
    Sound.init();
    if(Sound.bgmEnabled && Sound.bgmVol>0) Sound.startBGM();
    document.body.removeEventListener('pointerdown', first);
  }, { once:true });
}
init();
</script>
</body>
</html>
