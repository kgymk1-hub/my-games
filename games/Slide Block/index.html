<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
  <title>ã‚¢ã‚¤ã‚·ãƒ†ãƒ«ãƒ‹ã‚¤ã‚¬ã‚¿ãƒ‘ã‚ºãƒ«</title>
  <style>
    :root{
      --bg:#f4f4f4;
      --wood:#8b5a2b;
      --wood2:#dcb386;
      --accent:#d32f2f;
      --text:#333;
    }
    *{box-sizing:border-box}
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN","Meiryo",sans-serif;
      margin:0; padding:14px 0 28px;
      background:var(--bg);
      color:var(--text);
      display:flex; flex-direction:column; align-items:center;
      min-height:100vh;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      overflow-x:hidden;
    }

    h1{margin:0 0 10px; font-size:22px; color:#444}

    /* sound */
    .sound-wrap{
      width:92%; max-width:380px;
      background:#fff;
      border:1px solid #ddd;
      border-radius:12px;
      padding:10px 12px;
      box-shadow:0 2px 10px rgba(0,0,0,.06);
      margin:0 0 10px;
    }
    .sound-row{
      display:flex; align-items:center; gap:10px;
      margin:6px 0;
    }
    .sound-btn{
      flex:0 0 auto;
      background:#fff; border:1px solid #aaa; border-radius:18px;
      padding:6px 12px; font-size:12px; color:#777;
      display:flex; align-items:center; gap:6px;
      cursor:pointer;
      transition:.15s;
      white-space:nowrap;
    }
    .sound-btn.active{
      background:var(--accent); border-color:var(--accent);
      color:#fff; font-weight:800;
    }
    .sound-slider{
      flex:1 1 auto;
      display:flex; align-items:center; gap:8px;
      min-width:0;
    }
    input[type="range"]{ width:100%; }
    .sound-val{
      flex:0 0 auto;
      width:30px;
      text-align:right;
      font-weight:800;
      color:#666;
      font-size:12px;
    }

    /* mode */
    .mode-selector{
      display:flex; width:90%; max-width:360px;
      background:#ddd; border-radius:8px; padding:4px;
      margin-bottom:10px;
    }
    .mode-btn{
      flex:1; border:none; background:transparent; cursor:pointer;
      padding:10px 0; border-radius:6px;
      font-size:14px; font-weight:900; color:#666;
      transition:.15s;
      white-space:nowrap;
    }
    .mode-btn.active{
      background:#fff; color:var(--accent);
      box-shadow:0 2px 4px rgba(0,0,0,.10);
    }

    /* score */
    #score-board{
      display:flex; justify-content:space-between;
      width:88%; max-width:360px;
      font-weight:800; font-size:15px; color:#555;
      margin-bottom:6px;
      z-index:50;
    }
    .score-item span{color:var(--accent); font-size:18px; margin-left:5px}

    /* board wrapper */
    #board-wrapper{
      position:relative;
      margin:18px auto 18px;
      display:block;
    }
    #board-container{
      position:absolute;
      left:50%;
      top:0;
      width:388px;          /* = 360 + padding(20) + border(8) */
      height:328px;         /* = 300 + padding(20) + border(8) */
      padding:10px;
      border:4px solid var(--wood);
      border-radius:8px;
      background:var(--wood2);
      box-shadow:0 6px 18px rgba(0,0,0,.22);
      transform-origin:top center;
      transform:translateX(-50%) scale(1);
    }
    #goal-marker{
      position:absolute;
      top:-28px; left:10px;
      width:calc(100% - 20px);
      text-align:left;
      font-size:14px;
      font-weight:900;
      color:var(--wood);
      white-space:nowrap;
      pointer-events:none;
    }
    #game-board{
      position:relative;
      width:360px; height:300px;
      border:2px solid var(--wood);
      overflow:hidden;
      background-color:#111;
      background-image:
        linear-gradient(45deg,#222 25%,transparent 25%),
        linear-gradient(-45deg,#222 25%,transparent 25%),
        linear-gradient(45deg,transparent 75%,#222 75%),
        linear-gradient(-45deg,transparent 75%,#222 75%);
      background-size:20px 20px;
    }

    /* blocks */
    .block{
      position:absolute;
      border:2px solid var(--wood);
      border-radius:4px;
      box-shadow:inset 0 0 6px rgba(0,0,0,.10);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      transition:top .10s ease-out, left .10s ease-out;
      z-index:10;
      line-height:1.05;
      white-space:nowrap;
      word-break:keep-all;
      padding:0 4px;
    }
    .block.selected{
      background:#fff3e0 !important;
      border-color:var(--accent);
      box-shadow:0 0 0 2px rgba(211,47,47,.35);
      z-index:20;
    }
    .block.auto{
      outline:2px solid rgba(0,137,123,.55);
      z-index:25;
    }

    .vertical{
      writing-mode:vertical-rl;
      text-orientation:upright;
      letter-spacing:1px;
    }
    .horizontal{
      writing-mode:horizontal-tb;
      text-orientation:mixed;
      letter-spacing:0;
    }

    .block-id{
      position:absolute; top:1px; left:2px;
      font-size:9px; opacity:.55;
      writing-mode:horizontal-tb;
      pointer-events:none;
      font-weight:800;
    }
    .label{
      font-weight:1000;
      display:block;
      pointer-events:none;
      white-space:nowrap; /* ã„ã‚ãå«ã‚å…¨å“¡1è¡Œå›ºå®š */
    }

    /* arrows */
    .arrow-btn{
      position:absolute;
      width:40px; height:40px;
      background:var(--accent);
      color:#fff;
      border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      font-size:20px;
      box-shadow:0 2px 6px rgba(0,0,0,.3);
      opacity:.96;
      z-index:30;
      cursor:pointer;
      user-select:none;
    }
    .arrow-btn:active{transform:scale(.9); background:#b71c1c}
    .arrow-top{ top:-16px; left:50%; margin-left:-20px; }
    .arrow-bottom{ bottom:-16px; left:50%; margin-left:-20px; }
    .arrow-left{ left:-16px; top:50%; margin-top:-20px; }
    .arrow-right{ right:-16px; top:50%; margin-top:-20px; }

    /* controls */
    .primary-controls{
      display:flex; gap:15px; width:92%; max-width:380px;
      margin-bottom:10px;
    }
    .history-btn{
      flex:1; height:54px;
      font-size:18px; font-weight:900;
      border-radius:12px;
      background:#fff;
      border:2px solid #888;
      box-shadow:0 4px 0 #bbb;
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      transition:.08s;
    }
    .history-btn:active{transform:translateY(4px); box-shadow:none}
    .history-btn:disabled{
      background:#eee; border-color:#ccc; color:#aaa;
      box-shadow:none; transform:none; cursor:not-allowed;
    }

    .solver-area{
      width:92%; max-width:380px;
      margin-bottom:auto;
    }
    .solve-btn{
      width:100%;
      padding:14px 12px;
      font-size:16px; font-weight:1000;
      border:none; border-radius:10px;
      background:#4caf50; color:#fff;
      box-shadow:0 4px 0 #388e3c;
      cursor:pointer; transition:.08s;
    }
    .solve-btn:active{transform:translateY(4px); box-shadow:none}
    .solve-btn.solving{background:#ef5350; box-shadow:0 4px 0 #c62828}

    .danger-zone{
      margin-top:26px;
      width:100%;
      padding:15px 0 18px;
      border-top:1px solid #ddd;
      background:#eaeaea;
      display:flex; flex-direction:column; align-items:center; gap:10px;
    }
    .danger-desc{font-size:11px; color:#777}
    .secondary-btn-group{display:flex; gap:16px}
    .secondary-btn{
      background:#fff;
      border:1px solid #999;
      color:#555;
      padding:8px 18px;
      font-size:13px;
      border-radius:20px;
      cursor:pointer;
    }
    .secondary-btn:active{background:#ddd}

    /* overlay */
    #loading-overlay{
      display:none;
      position:fixed; inset:0;
      background:rgba(0,0,0,.62);
      z-index:100;
      color:#fff;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      text-align:center;
      padding:18px;
    }
    .spinner{
      width:40px; height:40px;
      border:4px solid #fff; border-top:4px solid transparent;
      border-radius:50%;
      animation:spin 1s linear infinite;
      margin-bottom:14px;
    }
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .overlay-sub{font-size:12px; margin-top:8px; opacity:.92; line-height:1.35}

    /* confetti canvas */
    #confetti{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      pointer-events:none;
      z-index:200;
      display:none;
    }
  </style>
</head>
<body>
  <h1>ã‚¢ã‚¤ã‚·ãƒ†ãƒ«ãƒ‹ã‚¤ã‚¬ã‚¿ãƒ‘ã‚ºãƒ«</h1>

  <div class="sound-wrap">
    <div class="sound-row">
      <button id="btn-bgm" class="sound-btn" onclick="toggleBGM()"><span>â™ª</span> BGM: OFF</button>
      <div class="sound-slider">
        <input id="bgm-vol" type="range" min="0" max="10" step="1" value="5" oninput="setBgmVol(this.value)">
        <div class="sound-val" id="bgm-val">5</div>
      </div>
    </div>
    <div class="sound-row">
      <button id="btn-se" class="sound-btn active" onclick="toggleSE()"><span>ğŸ”Š</span> åŠ¹æœéŸ³: ON</button>
      <div class="sound-slider">
        <input id="se-vol" type="range" min="0" max="10" step="1" value="5" oninput="setSeVol(this.value)">
        <div class="sound-val" id="se-val">5</div>
      </div>
    </div>
  </div>

  <div class="mode-selector">
    <button id="btn-up" class="mode-btn active" onclick="switchMode('up')">ç›®æŒ‡ã›!J1æ˜‡æ ¼</button>
    <button id="btn-champ" class="mode-btn" onclick="switchMode('champ')">ç›®æŒ‡ã›!J1å„ªå‹</button>
  </div>

  <div id="score-board">
    <div class="score-item">æ‰‹æ•°: <span id="current-moves">0</span></div>
    <div class="score-item">æœ€å°‘: <span id="best-score">-</span></div>
  </div>

  <div id="board-wrapper">
    <div id="board-container">
      <div id="goal-marker">â–¼ ç›®æŒ‡ã›!J1æ˜‡æ ¼ â–¼</div>
      <div id="game-board"></div>
    </div>
  </div>

  <div class="primary-controls">
    <button id="btn-undo" class="history-btn" onclick="undoMove()" disabled>â†© æˆ»ã‚‹</button>
    <button id="btn-redo" class="history-btn" onclick="redoMove()" disabled>é€²ã‚€ â†ª</button>
  </div>

  <div class="solver-area">
    <button id="btn-solve" class="solve-btn" onclick="toggleSolver()">æ¨¡ç¯„è§£ç­”ã‚’è¨ˆç®— (è‡ªå‹•å†ç”Ÿ)</button>
  </div>

  <div class="danger-zone">
    <span class="danger-desc">è¨­å®šãƒ»ãƒªã‚»ãƒƒãƒˆï¼ˆèª¤æ“ä½œé˜²æ­¢ã‚¨ãƒªã‚¢ï¼‰</span>
    <div class="secondary-btn-group">
      <button class="secondary-btn" onclick="resetGame()">æœ€åˆã«æˆ»ã™</button>
      <button class="secondary-btn" onclick="clearBestScore()">è¨˜éŒ²æ¶ˆå»</button>
    </div>
  </div>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <div style="font-weight:1000; font-size:16px;">è§£ã‚’æ¢ç´¢ä¸­...</div>
    <div class="overlay-sub" id="overlay-sub">
      â€»ç«¯æœ«ã«ã‚ˆã£ã¦ã¯æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™<br>
      ï¼ˆæ¢ç´¢ä¸­ã¯ç”»é¢ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„ï¼‰
    </div>
  </div>

  <canvas id="confetti"></canvas>

<script>
/* =========================================================
   TEAM COLORS (approx primary colors)
   ========================================================= */
const TEAM_COLORS = {
  "æ–°æ½Ÿ":"#ff7a00",

  // Mode1 (J1æ˜‡æ ¼)
  "æ¨ªæµœFC":"#58b9e6",
  "æ¹˜å—":"#007a3d",
  "å¾³å³¶":"#0046a1",
  "ç£ç”°":"#7bc6ff",
  "å¤§å®®":"#ff6a00",
  "ä»™å°":"#f2b400",
  "é³¥æ –":"#e4007f",
  "ã„ã‚ã":"#d50000",
  "å±±å½¢":"#003e9c",
  "ä»Šæ²»":"#003a70",
  "æœ­å¹Œ":"#b0001a",
  "ç”²åºœ":"#0033a0",
  "ç§‹ç”°":"#0b3d91",
  "è—¤æ":"#6a1b9a",

  // Mode2 (J1å„ªå‹)
  "é¹¿å³¶":"#b50018",
  "æŸ":"#ffd000",
  "äº¬éƒ½":"#5b2c83",
  "åºƒå³¶":"#6a1b9a",
  "ç¥æˆ¸":"#7a0019",
  "ç”ºç”°":"#0047ab",
  "æµ¦å’Œ":"#d40000",
  "å·å´":"#00a3e0",
  "Gå¤§é˜ª":"#0056a6",
  "Cå¤§é˜ª":"#ff2aa1",
  "Fæ±äº¬":"#005bac",
  "ç¦å²¡":"#008b4a",
  "å²¡å±±":"#7a0019"
};

function pickTextColor(bgHex){
  if(!bgHex || bgHex[0] !== '#' || bgHex.length !== 7) return "#111";
  const r = parseInt(bgHex.slice(1,3),16);
  const g = parseInt(bgHex.slice(3,5),16);
  const b = parseInt(bgHex.slice(5,7),16);
  const lum = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
  return lum < 0.55 ? "#fff" : "#111";
}

/* =========================================================
   SOUND (WebAudio) - 10 steps, louder max, pop 8bit loop16
   ========================================================= */
const Sound = {
  ctx:null,
  master:null,
  bgmBus:null,
  seBus:null,

  bgmEnabled:false,
  seEnabled:true,

  bgmVol:5,
  seVol:5,

  isBgmPlaying:false,
  nextStepTime:0,
  stepIndex:0,
  timer:null,
  currentModeKey:'up',

  init(){
    if(!this.ctx){
      const AC = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AC();

      this.master = this.ctx.createGain();
      this.bgmBus  = this.ctx.createGain();
      this.seBus   = this.ctx.createGain();

      this.bgmBus.connect(this.master);
      this.seBus.connect(this.master);
      this.master.connect(this.ctx.destination);
    }
    if(this.ctx.state === 'suspended') this.ctx.resume();
    this.applyVolumes();
  },

  applyVolumes(){
    // â˜…æœªåˆæœŸåŒ–ã§è½ã¡ãªã„ã‚¬ãƒ¼ãƒ‰ï¼ˆãƒªãƒ­ãƒ¼ãƒ‰ç›´å¾Œã®ç›¤é¢æœªè¡¨ç¤ºã®æ ¹æœ¬åŸå› ã‚’ä¿®æ­£ï¼‰
    if(!this.bgmBus || !this.seBus) return;

    const bgmGain = (this.bgmVol/10) * 0.35;
    const seGain  = (this.seVol/10)  * 1.10;

    this.bgmBus.gain.value = this.bgmEnabled ? bgmGain : 0;
    this.seBus.gain.value  = this.seEnabled  ? seGain  : 0;
  },

  playMove(){
    if(!this.seEnabled || this.seVol === 0) return;
    this.init();
    const t = this.ctx.currentTime;

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(440, t);
    osc.frequency.exponentialRampToValueAtTime(220, t + 0.06);

    gain.gain.setValueAtTime(0.0, t);
    gain.gain.linearRampToValueAtTime(0.18, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.09);

    osc.connect(gain);
    gain.connect(this.seBus);

    osc.start(t);
    osc.stop(t + 0.10);
  },

  playWin(){
    if(!this.seEnabled || this.seVol === 0) return;
    this.init();
    const base = this.ctx.currentTime;
    const freqs = [523.25, 659.25, 783.99, 1046.50];
    freqs.forEach((f, i)=>{
      const t = base + i*0.11;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = 'square';
      osc.frequency.value = f;

      gain.gain.setValueAtTime(0.0, t);
      gain.gain.linearRampToValueAtTime(0.22, t+0.03);
      gain.gain.exponentialRampToValueAtTime(0.001, t+0.65);

      osc.connect(gain);
      gain.connect(this.seBus);

      osc.start(t);
      osc.stop(t+0.75);
    });
  },

  startBGM(){
    if(!this.bgmEnabled || this.bgmVol === 0) return;
    this.init();
    if(this.isBgmPlaying) return;
    this.isBgmPlaying = true;
    this.stepIndex = 0;
    this.nextStepTime = this.ctx.currentTime + 0.10;
    this._schedule();
  },

  stopBGM(){
    this.isBgmPlaying = false;
    if(this.timer) clearTimeout(this.timer);
    this.timer = null;
  },

  _schedule(){
    if(!this.isBgmPlaying) return;

    while(this.nextStepTime < this.ctx.currentTime + 0.50){
      this._playStep(this.nextStepTime, this.stepIndex);
      this.stepIndex = (this.stepIndex + 1) % 16;
      this.nextStepTime += 0.125;
    }

    this.timer = setTimeout(()=>this._schedule(), 60);
  },

  _noteFreq(semi){
    return 440 * Math.pow(2, semi/12);
  },

  _playStep(time, step){
    const seqUp = [
      0,  7,  9,  7,
      0,  7, 12,  0,
      0,  4,  7,  4,
      0,  2,  4,  0
    ];
    const seqChamp = [
      0,  7,  9, 12,
      0, 12, 14, 12,
      0,  7,  9,  7,
      0,  4,  7,  0
    ];

    const seq = (this.currentModeKey === 'champ') ? seqChamp : seqUp;
    const deg = seq[step];
    if(deg === 0) return;

    const base = 3; // C5
    const semi = base + deg;

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    osc.type = 'square';
    osc.frequency.value = this._noteFreq(semi);

    filter.type = 'lowpass';
    filter.frequency.value = 1400;

    gain.gain.setValueAtTime(0.0, time);
    gain.gain.linearRampToValueAtTime(0.30, time + 0.008);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.10);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.bgmBus);

    osc.start(time);
    osc.stop(time + 0.12);
  }
};

function loadSoundSettings(){
  const bgm = localStorage.getItem('aishiteru_bgm');
  const se  = localStorage.getItem('aishiteru_se');
  const bgmVol = localStorage.getItem('aishiteru_bgm_vol');
  const seVol  = localStorage.getItem('aishiteru_se_vol');

  Sound.bgmEnabled = (bgm === 'on');
  Sound.seEnabled  = (se !== 'off');
  Sound.bgmVol = bgmVol ? Math.max(0, Math.min(10, parseInt(bgmVol,10))) : 5;
  Sound.seVol  = seVol  ? Math.max(0, Math.min(10, parseInt(seVol,10)))  : 5;

  document.getElementById('bgm-vol').value = String(Sound.bgmVol);
  document.getElementById('se-vol').value  = String(Sound.seVol);
  document.getElementById('bgm-val').textContent = String(Sound.bgmVol);
  document.getElementById('se-val').textContent  = String(Sound.seVol);

  updateSoundUI();
}

function updateSoundUI(){
  const btnBGM = document.getElementById('btn-bgm');
  const btnSE  = document.getElementById('btn-se');

  if(Sound.bgmEnabled && Sound.bgmVol > 0){
    btnBGM.classList.add('active');
    btnBGM.innerHTML = '<span>â™ª</span> BGM: ON';
  }else{
    btnBGM.classList.remove('active');
    btnBGM.innerHTML = '<span>â™ª</span> BGM: OFF';
  }

  if(Sound.seEnabled && Sound.seVol > 0){
    btnSE.classList.add('active');
    btnSE.innerHTML = '<span>ğŸ”Š</span> åŠ¹æœéŸ³: ON';
  }else{
    btnSE.classList.remove('active');
    btnSE.innerHTML = '<span>ğŸ”ˆ</span> åŠ¹æœéŸ³: OFF';
  }

  // æœªåˆæœŸåŒ–ã§ã‚‚è½ã¡ãªã„ï¼ˆapplyVolumesã«ã‚¬ãƒ¼ãƒ‰ã‚ã‚Šï¼‰
  Sound.applyVolumes();
}

function toggleBGM(){
  Sound.init();
  Sound.bgmEnabled = !Sound.bgmEnabled;
  localStorage.setItem('aishiteru_bgm', Sound.bgmEnabled ? 'on' : 'off');
  Sound.applyVolumes();
  if(Sound.bgmEnabled && Sound.bgmVol>0) Sound.startBGM(); else Sound.stopBGM();
  updateSoundUI();
}

function toggleSE(){
  Sound.init();
  Sound.seEnabled = !Sound.seEnabled;
  localStorage.setItem('aishiteru_se', Sound.seEnabled ? 'on' : 'off');
  Sound.applyVolumes();
  if(Sound.seEnabled && Sound.seVol>0) Sound.playMove();
  updateSoundUI();
}

function setBgmVol(v){
  Sound.bgmVol = Math.max(0, Math.min(10, parseInt(v,10)));
  localStorage.setItem('aishiteru_bgm_vol', String(Sound.bgmVol));
  document.getElementById('bgm-val').textContent = String(Sound.bgmVol);

  // iOSå¯¾ç­–ï¼šã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œè‡ªä½“ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãªã®ã§ init ã—ã¦OK
  Sound.init();
  Sound.applyVolumes();
  if(Sound.bgmEnabled && Sound.bgmVol>0) Sound.startBGM(); else Sound.stopBGM();
  updateSoundUI();
}

function setSeVol(v){
  Sound.seVol = Math.max(0, Math.min(10, parseInt(v,10)));
  localStorage.setItem('aishiteru_se_vol', String(Sound.seVol));
  document.getElementById('se-val').textContent = String(Sound.seVol);

  Sound.init();
  Sound.applyVolumes();
  updateSoundUI();
}

/* =========================================================
   GAME
   ========================================================= */
const COLS=6, ROWS=5, UNIT=60;

const MODES = {
  up:   { label:'ç›®æŒ‡ã›!J1æ˜‡æ ¼',  storageBest:'aishiteru_best_up'   },
  champ:{ label:'ç›®æŒ‡ã›!J1å„ªå‹',  storageBest:'aishiteru_best_champ'}
};

/* -------------------------
   Layouts (NO overlap)
   - Board: 6x5
   - Empty: 2
   - Main: 2x2 at (4,3)
   - Mode1: 1x1 x4, 2x1 x5, 1x2 x5
   - Mode2: 1x1 x2, 2x1 x7, 1x2 x4
   ------------------------- */
const layout = {
  // Mode1: J1æ˜‡æ ¼ï¼ˆä»¥å‰ã®é…ç½®ã‚’ç¶­æŒï¼‰
  up: [
    { id: 7,  name:"æ¨ªæµœFC", w:2, h:1, x:0, y:0, isMain:false },
    { id: 6,  name:"å¾³å³¶",   w:2, h:1, x:2, y:0, isMain:false },
    { id: 3,  name:"é³¥æ –",   w:1, h:2, x:4, y:0, isMain:false },
    { id: 4,  name:"ä»Šæ²»",   w:1, h:2, x:5, y:0, isMain:false },
    { id: 1,  name:"æ¹˜å—",   w:1, h:2, x:0, y:1, isMain:false },
    { id: 2,  name:"ç£ç”°",   w:1, h:2, x:1, y:1, isMain:false },
    { id: 5,  name:"å¤§å®®",   w:1, h:2, x:2, y:1, isMain:false },
    { id: 15, name:"ã„ã‚ã", w:1, h:1, x:3, y:1, isMain:false },
    { id: 12, name:"æœ­å¹Œ",   w:1, h:1, x:3, y:2, isMain:false },
    { id: 9,  name:"ä»™å°",   w:2, h:1, x:0, y:3, isMain:false },
    { id: 8,  name:"ç”²åºœ",   w:2, h:1, x:2, y:3, isMain:false },
    { id: 10, name:"å±±å½¢",   w:2, h:1, x:0, y:4, isMain:false },
    { id: 13, name:"ç§‹ç”°",   w:1, h:1, x:2, y:4, isMain:false },
    { id: 14, name:"è—¤æ",   w:1, h:1, x:3, y:4, isMain:false },
    { id: 99, name:"æ–°æ½Ÿ",   w:2, h:2, x:4, y:3, isMain:true  }
  ],

  // Mode2: J1å„ªå‹ï¼ˆé‡ãªã‚Šã‚¼ãƒ­ã§ä½œã‚Šç›´ã—ãƒ»å›ºå®šé…ç½®ï¼‰
  // æ¡ä»¶: 1x1=2, 2x1=7, 1x2=4, main=2x2, empty=2, mainã¯å³ä¸‹(4,3)å›ºå®š
  champ: [
    // 2x1 (7 pieces)
    { id: 201, name:"é¹¿å³¶", w:2, h:1, x:0, y:0, isMain:false }, // dist 0
    { id: 202, name:"åºƒå³¶", w:2, h:1, x:2, y:0, isMain:false }, // dist 2
    { id: 203, name:"Gå¤§é˜ª", w:2, h:1, x:4, y:0, isMain:false }, // dist 4
    { id: 204, name:"ç¥æˆ¸", w:2, h:1, x:2, y:1, isMain:false }, // dist 3
    { id: 205, name:"Fæ±äº¬", w:2, h:1, x:4, y:1, isMain:false }, // dist 5
    { id: 206, name:"Cå¤§é˜ª", w:2, h:1, x:2, y:3, isMain:false }, // dist 5
    { id: 207, name:"å²¡å±±", w:2, h:1, x:2, y:4, isMain:false }, // dist 6

    // 1x2 (4 pieces)
    { id: 211, name:"æŸ",   w:1, h:2, x:0, y:1, isMain:false }, // dist 1
    { id: 212, name:"äº¬éƒ½", w:1, h:2, x:1, y:1, isMain:false }, // dist 2
    { id: 213, name:"ç”ºç”°", w:1, h:2, x:0, y:3, isMain:false }, // dist 3
    { id: 214, name:"æµ¦å’Œ", w:1, h:2, x:1, y:3, isMain:false }, // dist 4

    // 1x1 (2 pieces)
    { id: 221, name:"å·å´", w:1, h:1, x:2, y:2, isMain:false }, // dist 4
    { id: 222, name:"ç¦å²¡", w:1, h:1, x:3, y:2, isMain:false }, // dist 5

    // main 2x2 at (4,3)
    { id: 99,  name:"æ–°æ½Ÿ", w:2, h:2, x:4, y:3, isMain:true  }
    // ç©ºããƒã‚¹2ã¤ï¼š (4,2) ã¨ (5,2)
  ]
};

const el = {
  board: document.getElementById('game-board'),
  moves: document.getElementById('current-moves'),
  best:  document.getElementById('best-score'),
  btnUp:  document.getElementById('btn-up'),
  btnCh:  document.getElementById('btn-champ'),
  undo:  document.getElementById('btn-undo'),
  redo:  document.getElementById('btn-redo'),
  solve: document.getElementById('btn-solve'),
  overlay: document.getElementById('loading-overlay'),
  overlaySub: document.getElementById('overlay-sub'),
  goal: document.getElementById('goal-marker'),
  wrap: document.getElementById('board-wrapper'),
  container: document.getElementById('board-container'),
  confetti: document.getElementById('confetti')
};

let mode = 'up';
let blocks = [];
let moveCount = 0;
let selected = -1;

let undoStack = [];
let redoStack = [];

let isAuto = false;
let autoMoves = [];
let autoTimer = null;

let solverWorker = null;
let solverCancelToken = 0;

function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

function fitBoard(){
  const container = el.container;
  const wrapper = el.wrap;

  const baseW = container.offsetWidth;
  const extraTop = 32;
  const baseH = container.offsetHeight + extraTop;

  const screenW = Math.max(280, window.innerWidth - 24);
  const screenH = Math.max(300, window.innerHeight * 0.56);

  let scale = screenW / baseW;
  if(baseH * scale > screenH) scale = screenH / baseH;
  if(scale > 1.35) scale = 1.35;

  container.style.transform = \`translateX(-50%) scale(\${scale})\`;

  wrapper.style.width  = \`\${baseW * scale}px\`;
  wrapper.style.height = \`\${baseH * scale}px\`;
}
window.addEventListener('load', fitBoard);
window.addEventListener('resize', fitBoard);

function getBestKey(){ return MODES[mode].storageBest; }

function loadBest(){
  const v = localStorage.getItem(getBestKey());
  el.best.textContent = v ? v : '-';
}
function saveBest(score){
  const key = getBestKey();
  const cur = localStorage.getItem(key);
  if(!cur || score < parseInt(cur,10)){
    localStorage.setItem(key, String(score));
    el.best.textContent = String(score);
  }
}

function clearBestScore(){
  if(confirm('ç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰ã®è¨˜éŒ²ã‚’æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ')){
    localStorage.removeItem(getBestKey());
    el.best.textContent = '-';
  }
}

function setModeUI(){
  if(mode === 'up'){
    el.btnUp.classList.add('active'); el.btnCh.classList.remove('active');
  }else{
    el.btnUp.classList.remove('active'); el.btnCh.classList.add('active');
  }
  const label = MODES[mode].label;
  el.goal.textContent = \`â–¼ \${label} â–¼\`;

  Sound.currentModeKey = mode;
  if(Sound.bgmEnabled && Sound.bgmVol>0){
    Sound.stopBGM();
    Sound.startBGM();
  }
}

function switchMode(next){
  stopAuto();
  cancelSolver();
  mode = next;
  setModeUI();
  loadBest();
  resetGame();
}

function resetGame(){
  stopAuto();
  cancelSolver();

  blocks = deepCopy(layout[mode]);
  moveCount = 0;
  selected = -1;
  undoStack = [];
  redoStack = [];
  updateHud();
  render();
}

function updateHud(){
  el.moves.textContent = String(moveCount);
  el.undo.disabled = (undoStack.length === 0) || isAuto;
  el.redo.disabled = (redoStack.length === 0) || isAuto;
}

function canMove(block, dx, dy){
  const nx = block.x + dx;
  const ny = block.y + dy;
  if(nx < 0 || nx + block.w > COLS) return false;
  if(ny < 0 || ny + block.h > ROWS) return false;

  for(const o of blocks){
    if(o === block) continue;
    if(nx < o.x + o.w && nx + block.w > o.x &&
       ny < o.y + o.h && ny + block.h > o.y){
      return false;
    }
  }
  return true;
}

function getValidMovesFor(index){
  const b = blocks[index];
  const dirs = [
    {dx:0, dy:-1, cls:'arrow-top',    ch:'&#9650;', dir:0},
    {dx:0, dy: 1, cls:'arrow-bottom', ch:'&#9660;', dir:1},
    {dx:-1,dy: 0, cls:'arrow-left',   ch:'&#9664;', dir:2},
    {dx: 1,dy: 0, cls:'arrow-right',  ch:'&#9654;', dir:3}
  ];
  return dirs.filter(d => canMove(b, d.dx, d.dy));
}

function applyMove(idx, dx, dy){
  blocks[idx].x += dx;
  blocks[idx].y += dy;
}

function doMove(idx, dx, dy, {record=true, sound=true}={}){
  if(sound) Sound.playMove();
  applyMove(idx, dx, dy);
  moveCount++;
  if(record){
    undoStack.push({index:idx, dx, dy});
    redoStack = [];
  }
  selected = -1;
  updateHud();
  render();
  setTimeout(checkWin, 80);
}

function undoMove(){
  if(undoStack.length === 0 || isAuto) return;
  Sound.playMove();
  const m = undoStack.pop();
  applyMove(m.index, -m.dx, -m.dy);
  redoStack.push(m);
  moveCount--;
  selected = -1;
  updateHud();
  render();
}

function redoMove(){
  if(redoStack.length === 0 || isAuto) return;
  Sound.playMove();
  const m = redoStack.pop();
  applyMove(m.index, m.dx, m.dy);
  undoStack.push(m);
  moveCount++;
  selected = -1;
  updateHud();
  render();
  setTimeout(checkWin, 80);
}

/* =========================================================
   CONFETTI
   ========================================================= */
let confettiAnim = null;
function startConfetti(durationMs=2200){
  const canvas = el.confetti;
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  function resize(){
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resize();
  window.addEventListener('resize', resize, {passive:true});

  const colors = ["#ff7a00","#58b9e6","#007a3d","#ffd000","#ff2aa1","#6a1b9a","#ffffff"];
  const pieces = [];
  const n = 140;

  for(let i=0;i<n;i++){
    pieces.push({
      x: Math.random()*window.innerWidth,
      y: -20 - Math.random()*window.innerHeight*0.4,
      vx: (Math.random()-0.5)*3.2,
      vy: 2.2 + Math.random()*4.2,
      w: 6 + Math.random()*6,
      h: 8 + Math.random()*10,
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.25,
      color: colors[Math.floor(Math.random()*colors.length)],
      alpha: 0.85 + Math.random()*0.15
    });
  }

  canvas.style.display = 'block';
  const t0 = performance.now();

  function tick(now){
    const t = now - t0;
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

    pieces.forEach(p=>{
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.vr;
      p.vy += 0.02;
      if(p.x < -30) p.x = window.innerWidth + 30;
      if(p.x > window.innerWidth + 30) p.x = -30;

      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });

    if(t < durationMs){
      confettiAnim = requestAnimationFrame(tick);
    }else{
      cancelAnimationFrame(confettiAnim);
      confettiAnim = null;
      canvas.style.display = 'none';
      window.removeEventListener('resize', resize);
    }
  }
  confettiAnim = requestAnimationFrame(tick);
}

function checkWin(){
  const main = blocks.find(b=>b.isMain);
  if(main && main.x === 0 && main.y === 0){
    if(isAuto) stopAuto();
    startConfetti(2400);
    Sound.playWin();

    setTimeout(()=>{
      alert(\`ã‚¯ãƒªã‚¢ï¼\\nãƒ¢ãƒ¼ãƒ‰: \${MODES[mode].label}\\nç§»å‹•å›æ•°: \${moveCount}å›\`);
      saveBest(moveCount);
    }, 520);
  }
}

/* =========================================================
   Label auto-fit (prevents clipping)
   ========================================================= */
function fitLabelToBlock(blockEl, labelEl){
  // keep 1-line; shrink font until both width/height fit
  const pad = 6;
  const maxW = blockEl.clientWidth - pad;
  const maxH = blockEl.clientHeight - pad;

  let size = parseFloat(labelEl.style.fontSize || '18');
  if(!isFinite(size) || size <= 0) size = 18;

  for(let i=0;i<28;i++){
    const okW = labelEl.scrollWidth <= maxW;
    const okH = labelEl.scrollHeight <= maxH;
    if(okW && okH) break;
    size -= 1;
    if(size < 10) { size = 10; break; }
    labelEl.style.fontSize = size + 'px';
  }
}

function render(){
  el.board.innerHTML = '';

  const blockEls = [];

  blocks.forEach((b, i)=>{
    const d = document.createElement('div');
    d.className = 'block';

    const bg = TEAM_COLORS[b.name] || '#e8c39e';
    d.style.background = bg;
    d.style.color = pickTextColor(bg);

    if(i === selected) d.classList.add('selected');
    if(isAuto && i === selected) d.classList.add('auto');

    d.style.width  = (b.w*UNIT)+'px';
    d.style.height = (b.h*UNIT)+'px';
    d.style.left   = (b.x*UNIT)+'px';
    d.style.top    = (b.y*UNIT)+'px';

    // direction
    let dir = 'h';
    if(b.isMain) dir = 'v';
    else if(b.w < b.h) dir = 'v';
    else dir = 'h';
    d.classList.add(dir === 'v' ? 'vertical' : 'horizontal');

    const id = document.createElement('span');
    id.className = 'block-id';
    id.textContent = b.id;
    d.appendChild(id);

    const label = document.createElement('span');
    label.className = 'label';
    label.textContent = b.name;

    // base font sizes (fitLabelToBlock will shrink if needed)
    if(b.isMain){
      label.style.fontSize = '40px';
    }else if(b.w === 1 && b.h === 1){
      label.style.fontSize = '18px';
    }else if(b.name.length <= 2){
      label.style.fontSize = '22px';
    }else if(b.name.length >= 5){
      label.style.fontSize = '15px';
    }else{
      label.style.fontSize = '18px';
    }

    d.appendChild(label);

    if(!isAuto){
      d.onclick = (e)=>{
        Sound.init();
        e.stopPropagation();
        onBlockTap(i);
      };

      if(i === selected){
        const moves = getValidMovesFor(i);
        moves.forEach(m=>{
          const a = document.createElement('div');
          a.className = \`arrow-btn \${m.cls}\`;
          a.innerHTML = m.ch;
          a.onclick = (e)=>{
            e.stopPropagation();
            doMove(i, m.dx, m.dy);
          };
          d.appendChild(a);
        });
      }
    }

    el.board.appendChild(d);
    blockEls.push({d, label});
  });

  // after append, auto-fit text
  requestAnimationFrame(()=>{
    blockEls.forEach(({d,label})=>fitLabelToBlock(d,label));
  });
}

function onBlockTap(i){
  if(isAuto) return;
  if(selected === i){
    selected = -1; render(); return;
  }
  const moves = getValidMovesFor(i);
  if(moves.length === 0) return;

  if(moves.length === 1){
    doMove(i, moves[0].dx, moves[0].dy);
    return;
  }
  selected = i;
  render();
}

document.body.addEventListener('click', ()=>{
  if(isAuto) return;
  if(selected !== -1){
    selected = -1;
    render();
  }
});

/* =========================================================
   SOLVER (WebWorker) - fast bitboard weighted A* + beam fallback
   ========================================================= */
function toggleSolver(){
  if(isAuto) stopAuto();
  else startSolver();
}

function stopAuto(){
  isAuto = false;
  if(autoTimer) clearInterval(autoTimer);
  autoTimer = null;
  el.solve.textContent = 'æ¨¡ç¯„è§£ç­”ã‚’è¨ˆç®— (è‡ªå‹•å†ç”Ÿ)';
  el.solve.classList.remove('solving');
  selected = -1;
  updateHud();
  render();
}

function cancelSolver(){
  solverCancelToken++;
  if(solverWorker){
    try{ solverWorker.terminate(); }catch(_){}
    solverWorker = null;
  }
  el.overlay.style.display = 'none';
}

function packStateBigInt(blocks){
  let key = 0n;
  for(let i=0;i<blocks.length;i++){
    const x = BigInt(blocks[i].x);
    const y = BigInt(blocks[i].y);
    key = (key << 6n) | (x << 3n) | y;
  }
  return key;
}

function startSolver(){
  Sound.init();
  const main = blocks.find(b=>b.isMain);
  if(main && main.x===0 && main.y===0){
    alert('æ—¢ã«ã‚´ãƒ¼ãƒ«ã—ã¦ã„ã¾ã™ã€‚');
    return;
  }

  const stateKey = packStateBigInt(blocks).toString(36);
  const cacheKey = \`aishiteru_cache_\${mode}_\${stateKey}\`;
  const cached = localStorage.getItem(cacheKey);
  if(cached){
    try{
      const moves = JSON.parse(cached);
      if(Array.isArray(moves) && moves.length){
        if(confirm(\`\${moves.length} æ‰‹ã®è§£ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰ãŒã‚ã‚Šã¾ã™ã€‚\\nè‡ªå‹•å†ç”Ÿã—ã¾ã™ã‹ï¼Ÿ\`)){
          isAuto = true;
          autoMoves = moves;
          el.solve.textContent = 'è‡ªå‹•å†ç”Ÿã‚’åœæ­¢';
          el.solve.classList.add('solving');
          updateHud();
          playAuto();
          return;
        }
      }
    }catch(_){}
  }

  el.overlaySub.innerHTML = 'â€»ç«¯æœ«ã«ã‚ˆã£ã¦ã¯æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™<br>ï¼ˆæ¢ç´¢ä¸­ã¯ç”»é¢ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„ï¼‰';
  el.overlay.style.display = 'flex';

  const token = ++solverCancelToken;

  // â˜…ã“ã“ã ã‘é«˜é€Ÿç‰ˆã«å·®ã—æ›¿ãˆï¼ˆUIãƒ»æ“ä½œã¯ä¸€åˆ‡å¤‰æ›´ãªã—ï¼‰
  const workerScript = `
    const COLS = 6, ROWS = 5;
    const CELLN = COLS * ROWS; // 30

    function pop32(x){
      x = x - ((x >>> 1) & 0x55555555);
      x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
      return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
    }

    function buildInfo(blocks){
      return blocks.map(b=>({
        w: b.w|0,
        h: b.h|0,
        isMain: !!b.isMain
      }));
    }

    function makeBaseMask(w,h){
      let m = 0;
      for(let y=0;y<h;y++){
        const row = y*COLS;
        for(let x=0;x<w;x++){
          m |= (1 << (row + x));
        }
      }
      return m >>> 0;
    }

    function rectMask(rx, ry){
      let m = 0;
      for(let y=0;y<=ry;y++){
        const row = y*COLS;
        for(let x=0;x<=rx;x++){
          m |= (1 << (row + x));
        }
      }
      return m >>> 0;
    }

    class MinHeap{
      constructor(){ this.a=[]; }
      push(x){
        const a=this.a; a.push(x);
        let i=a.length-1;
        while(i>0){
          const p=(i-1)>>1;
          if(a[p].f <= a[i].f) break;
          const t=a[p]; a[p]=a[i]; a[i]=t;
          i=p;
        }
      }
      pop(){
        const a=this.a;
        if(a.length===0) return null;
        const top=a[0];
        const last=a.pop();
        if(a.length){
          a[0]=last;
          let i=0;
          for(;;){
            const l=i*2+1, r=l+1;
            let m=i;
            if(l<a.length && a[l].f < a[m].f) m=l;
            if(r<a.length && a[r].f < a[m].f) m=r;
            if(m===i) break;
            const t=a[m]; a[m]=a[i]; a[i]=t;
            i=m;
          }
        }
        return top;
      }
      get size(){ return this.a.length; }
    }

    function makeKeyFromPos(posArr){
      let k = 0n;
      for(let i=0;i<posArr.length;i++){
        k = (k << 6n) | BigInt(posArr[i] & 63);
      }
      return k;
    }

    function reconstruct(parent, movePack, nodeId){
      const out=[];
      while(nodeId !== -1){
        const mp = movePack[nodeId];
        const p = parent[nodeId];
        if(mp !== 0xffff){
          const idx = mp >>> 2;
          const dir = mp & 3;
          let dx=0, dy=0;
          if(dir===0) dy=-1;
          else if(dir===1) dy=1;
          else if(dir===2) dx=-1;
          else dx=1;
          out.push({index:idx, dx, dy});
        }
        nodeId = p;
      }
      out.reverse();
      return out;
    }

    function NodeStore(n){
      this.n = n;
      this.cap = 200000;
      this.size = 0;

      this.pos = new Uint8Array(this.cap * n);
      this.parent = new Int32Array(this.cap);
      this.movePack = new Uint16Array(this.cap);
      this.gCost = new Uint32Array(this.cap);
      this.occ = new Uint32Array(this.cap);
    }
    NodeStore.prototype._grow = function(){
      const n = this.n;
      const newCap = this.cap * 2;

      const newPos = new Uint8Array(newCap * n);
      newPos.set(this.pos);
      this.pos = newPos;

      const newParent = new Int32Array(newCap);
      newParent.set(this.parent);
      this.parent = newParent;

      const newMove = new Uint16Array(newCap);
      newMove.set(this.movePack);
      this.movePack = newMove;

      const newG = new Uint32Array(newCap);
      newG.set(this.gCost);
      this.gCost = newG;

      const newOcc = new Uint32Array(newCap);
      newOcc.set(this.occ);
      this.occ = newOcc;

      this.cap = newCap;
    }
    NodeStore.prototype.addRoot = function(posArr, occMask){
      const n = this.n;
      if(this.size >= this.cap) this._grow();
      const id = this.size++;
      const off = id*n;
      for(let i=0;i<n;i++) this.pos[off+i] = posArr[i];
      this.parent[id] = -1;
      this.movePack[id] = 0xffff;
      this.gCost[id] = 0;
      this.occ[id] = occMask >>> 0;
      return id;
    }
    NodeStore.prototype.addChild = function(parentId, parentOff, movePackVal, g, occMask, movedIdx, newPosVal){
      const n = this.n;
      if(this.size >= this.cap) this._grow();
      const id = this.size++;
      const off = id*n;
      for(let i=0;i<n;i++) this.pos[off+i] = this.pos[parentOff+i];
      this.pos[off + movedIdx] = newPosVal & 63;
      this.parent[id] = parentId;
      this.movePack[id] = movePackVal;
      this.gCost[id] = g >>> 0;
      this.occ[id] = occMask >>> 0;
      return id;
    }

    onmessage = async (e)=>{
      const msg = e.data;
      if(!msg || msg.cmd !== 'solve') return;

      const blocks = msg.blocks;
      try{
        const info = buildInfo(blocks);
        const n = info.length;
        const mainIdx = info.findIndex(b=>b.isMain);
        const mw = info[mainIdx].w, mh = info[mainIdx].h;

        const baseMask = new Uint32Array(n);
        for(let i=0;i<n;i++){
          baseMask[i] = makeBaseMask(info[i].w, info[i].h);
        }

        const shiftBits = new Array(n);
        for(let i=0;i<n;i++){
          shiftBits[i] = BigInt((n-1-i)*6);
        }

        const rootPos = new Uint8Array(n);
        let rootOcc = 0;
        for(let i=0;i<n;i++){
          const x = blocks[i].x|0, y = blocks[i].y|0;
          const pos = ((x<<3) | y) & 63;
          rootPos[i] = pos;
          const offset = x + y*COLS;
          const m = (baseMask[i] << offset) >>> 0;
          rootOcc |= m;
        }

        const store = new NodeStore(n);
        const rootId = store.addRoot(rootPos, rootOcc);

        const rootKey = makeKeyFromPos(rootPos);

        function heuristic(mx,my, occMask){
          const dist = mx + my;

          const mainOffset = mx + my*COLS;
          const mainMask = (baseMask[mainIdx] << mainOffset) >>> 0;

          const rx = mx + mw - 1;
          const ry = my + mh - 1;
          const rMask = rectMask(rx, ry);

          const blockers = pop32(((occMask ^ mainMask) & rMask) >>> 0);

          let bp = 0;
          if(mx > 0){
            const leftMask = (mainMask >>> 1) >>> 0;
            if((leftMask & (occMask ^ mainMask)) !== 0) bp++;
          }
          if(my > 0){
            const upMask = (mainMask >>> COLS) >>> 0;
            if((upMask & (occMask ^ mainMask)) !== 0) bp++;
          }

          return dist + blockers * 0.38 + bp * 0.85;
        }

        function getXY(pos){
          return { x: (pos>>>3), y: (pos & 7) };
        }

        function buildMasksFromNode(off){
          const xs = new Int8Array(n);
          const ys = new Int8Array(n);
          const masks = new Uint32Array(n);
          let occ = 0;
          for(let i=0;i<n;i++){
            const p = store.pos[off+i];
            const x = p>>>3;
            const y = p & 7;
            xs[i] = x;
            ys[i] = y;
            const offset = x + y*COLS;
            const m = (baseMask[i] << offset) >>> 0;
            masks[i] = m;
            occ |= m;
          }
          return {xs,ys,masks,occ:occ>>>0};
        }

        const DIRS = [
          {dx:0, dy:-1, dir:0, shift: -COLS},
          {dx:0, dy: 1, dir:1, shift:  COLS},
          {dx:-1,dy: 0, dir:2, shift: -1},
          {dx: 1,dy: 0, dir:3, shift:  1},
        ];

        async function solveWeightedAStar(timeLimitMs, expandLimit, weight){
          const bestG = new Map();
          bestG.set(rootKey, 0);

          const heap = new MinHeap();

          const rootMain = getXY(rootPos[mainIdx]);
          const h0 = heuristic(rootMain.x, rootMain.y, rootOcc);
          heap.push({f: weight*h0, g:0, id:rootId, key:rootKey});

          const t0 = performance.now();
          let expanded = 0;
          let lastReport = 0;

          while(heap.size){
            const now = performance.now();
            if(now - t0 > timeLimitMs) return null;
            if(expanded > expandLimit) return null;

            const node = heap.pop();
            const g = node.g;
            const key = node.key;
            const id  = node.id;

            const best = bestG.get(key);
            if(best === undefined || best !== g) continue;

            const off = id * n;
            const occMask = store.occ[id];

            const mainPos = store.pos[off + mainIdx];
            const mx = mainPos>>>3;
            const my = mainPos & 7;
            if(mx===0 && my===0){
              return reconstruct(store.parent, store.movePack, id);
            }

            expanded++;
            if(expanded - lastReport >= 12000){
              lastReport = expanded;
              postMessage({cmd:'progress', expanded, elapsed: Math.round(now - t0)});
            }

            const {xs,ys,masks,occ} = buildMasksFromNode(off);

            for(let i=0;i<n;i++){
              const w = info[i].w, h = info[i].h;
              const x = xs[i], y = ys[i];
              const curMask = masks[i];
              const occWithout = (occ ^ curMask) >>> 0;

              for(const d of DIRS){
                const nx = x + d.dx;
                const ny = y + d.dy;

                if(nx < 0 || nx + w > COLS) continue;
                if(ny < 0 || ny + h > ROWS) continue;

                let newMask;
                if(d.shift === 1) newMask = (curMask << 1) >>> 0;
                else if(d.shift === -1) newMask = (curMask >>> 1) >>> 0;
                else if(d.shift === COLS) newMask = (curMask << COLS) >>> 0;
                else newMask = (curMask >>> COLS) >>> 0;

                if((newMask & occWithout) !== 0) continue;

                const newOcc = (occWithout | newMask) >>> 0;
                const newPosVal = ((nx<<3) | ny) & 63;

                const oldPosVal = store.pos[off+i] & 63;
                const diff = (oldPosVal ^ newPosVal) & 63;
                const childKey = key ^ (BigInt(diff) << shiftBits[i]);

                const ng = g + 1;
                const prev = bestG.get(childKey);
                if(prev !== undefined && prev <= ng) continue;

                const movePackVal = ((i<<2) | d.dir) & 0xffff;
                const childId = store.addChild(id, off, movePackVal, ng, newOcc, i, newPosVal);

                const cmx = (i===mainIdx) ? nx : mx;
                const cmy = (i===mainIdx) ? ny : my;
                const hh = heuristic(cmx, cmy, newOcc);
                const ff = ng + weight*hh;

                bestG.set(childKey, ng);
                heap.push({f: ff, g: ng, id: childId, key: childKey});
              }
            }
          }
          return null;
        }

        async function solveBeam(timeLimitMs, maxDepth, beamWidth){
          const t0 = performance.now();
          const visited = new Set();

          let layer = [{id:rootId, key:rootKey, score:0}];
          visited.add(rootKey.toString());

          let expanded = 0;
          for(let depth=0; depth<maxDepth; depth++){
            if(performance.now() - t0 > timeLimitMs) return null;

            const next = [];
            for(const node of layer){
              const id = node.id;
              const key = node.key;
              const off = id*n;
              const occMask = store.occ[id];

              const mainPos = store.pos[off + mainIdx];
              const mx = mainPos>>>3;
              const my = mainPos & 7;
              if(mx===0 && my===0){
                return reconstruct(store.parent, store.movePack, id);
              }

              const {xs,ys,masks,occ} = buildMasksFromNode(off);

              for(let i=0;i<n;i++){
                const w = info[i].w, h = info[i].h;
                const x = xs[i], y = ys[i];
                const curMask = masks[i];
                const occWithout = (occ ^ curMask) >>> 0;

                for(const d of DIRS){
                  const nx = x + d.dx;
                  const ny = y + d.dy;
                  if(nx < 0 || nx + w > COLS) continue;
                  if(ny < 0 || ny + h > ROWS) continue;

                  let newMask;
                  if(d.shift === 1) newMask = (curMask << 1) >>> 0;
                  else if(d.shift === -1) newMask = (curMask >>> 1) >>> 0;
                  else if(d.shift === COLS) newMask = (curMask << COLS) >>> 0;
                  else newMask = (curMask >>> COLS) >>> 0;

                  if((newMask & occWithout) !== 0) continue;

                  const newOcc = (occWithout | newMask) >>> 0;
                  const newPosVal = ((nx<<3) | ny) & 63;

                  const oldPosVal = store.pos[off+i] & 63;
                  const diff = (oldPosVal ^ newPosVal) & 63;
                  const childKey = key ^ (BigInt(diff) << shiftBits[i]);
                  const childKeyStr = childKey.toString();
                  if(visited.has(childKeyStr)) continue;
                  visited.add(childKeyStr);

                  const movePackVal = ((i<<2) | d.dir) & 0xffff;
                  const childId = store.addChild(id, off, movePackVal, (store.gCost[id]+1)>>>0, newOcc, i, newPosVal);

                  const cmx = (i===mainIdx) ? nx : mx;
                  const cmy = (i===mainIdx) ? ny : my;
                  const hh = heuristic(cmx, cmy, newOcc);

                  let bonus = 0;
                  if(i===mainIdx && (d.dir===0 || d.dir===2)) bonus = -0.25;

                  next.push({id:childId, key:childKey, score:(depth+1) + hh*2.0 + bonus});
                  expanded++;
                }
              }
            }

            if(expanded % 30000 === 0){
              postMessage({cmd:'progress', expanded, elapsed: Math.round(performance.now() - t0)});
            }

            if(next.length === 0) return null;
            next.sort((a,b)=>a.score-b.score);
            layer = next.length > beamWidth ? next.slice(0, beamWidth) : next;
          }
          return null;
        }

        let moves = await solveWeightedAStar(9000, 650000, 2.55);
        if(!moves) moves = await solveWeightedAStar(16000, 1300000, 2.15);
        if(!moves) moves = await solveWeightedAStar(22000, 2200000, 1.95);
        if(!moves) moves = await solveBeam(35000, 2600, 2200);

        postMessage({cmd:'done', moves});

      }catch(err){
        postMessage({cmd:'error', error: String(err && err.message ? err.message : err)});
      }
    };
  `;

  const blob = new Blob([workerScript], {type:'application/javascript'});
  solverWorker = new Worker(URL.createObjectURL(blob));

  solverWorker.onmessage = (ev)=>{
    if(token !== solverCancelToken) return;

    const msg = ev.data;
    if(!msg) return;

    if(msg.cmd === 'progress'){
      el.overlaySub.innerHTML = \`æ¢ç´¢ä¸­...<br>å±•é–‹: \${msg.expanded.toLocaleString()}<br>çµŒé: \${msg.elapsed} ms\`;
      return;
    }

    if(msg.cmd === 'error'){
      el.overlay.style.display = 'none';
      alert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + msg.error);
      cancelSolver();
      return;
    }

    if(msg.cmd === 'done'){
      el.overlay.style.display = 'none';

      const moves = msg.moves;
      if(!moves){
        alert('è§£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸâ€¦ï¼ˆæ¢ç´¢ä¸Šé™ã«åˆ°é”ï¼‰');
        cancelSolver();
        return;
      }

      try{ localStorage.setItem(cacheKey, JSON.stringify(moves)); }catch(_){}

      if(confirm(\`\${moves.length} æ‰‹ã®è§£ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\\nï¼ˆâ€»æœ€çŸ­ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰\\n\\nè‡ªå‹•å†ç”Ÿã—ã¾ã™ã‹ï¼Ÿ\`)){
        isAuto = true;
        autoMoves = moves;
        el.solve.textContent = 'è‡ªå‹•å†ç”Ÿã‚’åœæ­¢';
        el.solve.classList.add('solving');
        updateHud();
        playAuto();
      }else{
        cancelSolver();
      }
    }
  };

  solverWorker.postMessage({cmd:'solve', blocks: deepCopy(blocks)});
}

function playAuto(){
  let step = 0;
  autoTimer = setInterval(()=>{
    if(!isAuto){ stopAuto(); return; }
    if(step >= autoMoves.length){ stopAuto(); return; }

    const m = autoMoves[step++];
    selected = m.index;

    Sound.playMove();
    applyMove(m.index, m.dx, m.dy);
    moveCount++;
    undoStack.push(m);
    redoStack = [];

    updateHud();
    render();
    checkWin();
  }, 190);
}

/* =========================================================
   BOOT
   ========================================================= */
function init(){
  loadSoundSettings();
  setModeUI();
  loadBest();
  resetGame();
  requestAnimationFrame(fitBoard);

  // unlock + auto-start
  document.body.addEventListener('pointerdown', function first(){
    Sound.init();
    if(Sound.bgmEnabled && Sound.bgmVol>0) Sound.startBGM();
    document.body.removeEventListener('pointerdown', first);
  }, { once:true });
}
init();
</script>
</body>
</html>
