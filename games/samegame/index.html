<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>さめがめ（サイズ＆色数選択可）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #1f2430;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }

    .game-container {
      background: #262c3a;
      padding: 18px 16px 20px;
      border-radius: 16px;
      box-shadow: 0 14px 32px rgba(0,0,0,0.5);
      width: 380px;
      max-width: 100%;
      box-sizing: border-box;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.25rem;
      text-align: center;
    }

    .subtitle {
      font-size: 0.8rem;
      text-align: center;
      color: #c3c7d8;
      margin-bottom: 8px;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 0.8rem;
    }

    .settings-row label {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      min-width: 0;
    }

    select {
      background: #333949;
      color: #f1f1f1;
      border-radius: 6px;
      border: 1px solid #444b5e;
      padding: 4px 6px;
      font-size: 0.8rem;
      outline: none;
      box-sizing: border-box;
    }

    /* サイズ欄を小さめにして、色数欄がはみ出さないように */
    #sizeSelect { width: 108px; }
    #colorSelect { width: 152px; }

    @media (max-width: 360px) {
      .settings-row { flex-wrap: wrap; }
      #sizeSelect, #colorSelect { width: 100%; }
      .settings-row label { width: 100%; justify-content: space-between; }
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      margin-bottom: 8px;
      gap: 8px;
    }

    .score-label span { font-weight: 600; }

    .high-score {
      font-size: 0.78rem;
      color: #c3c7d8;
      white-space: nowrap;
    }

    .btn-row {
      display: flex;
      gap: 6px;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    .btn-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
      width: 100%;
    }

    .grid-wrapper {
      display: flex;
      justify-content: center;
      margin: 6px 0 8px;
    }

    .grid {
      --cols: 10;
      width: 100%;
      max-width: 320px;
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: 3px;
      background: #1a1f2a;
      padding: 5px;
      border-radius: 10px;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
      box-sizing: border-box;
    }

    @keyframes popIn {
      from { transform: scale(0.92); opacity: 0; }
      to   { transform: scale(1); opacity: 1; }
    }

    /* 初回生成（ニューゲーム直後）だけ軽く出現アニメ */
    .grid.animate .cell:not(.empty) {
      animation: popIn 0.22s ease-out;
    }

    .cell {
      width: 100%;
      padding-bottom: 100%; /* 正方形 */
      border-radius: 6px;
      cursor: pointer;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.4);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.12s ease, filter 0.08s ease;
      position: relative;
      overflow: hidden;

      /* スマホ誤ズーム/ハイライト抑止 */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    .cell-inner {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: #555;
    }

    .cell:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.6);
    }

    .cell.empty {
      opacity: 0;
      pointer-events: none;
      box-shadow: none;
      border: none;
    }

    /* 消せる塊の軽いハイライト */
    .cell.hl:not(.empty) {
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.35) inset,
        0 3px 10px rgba(0,0,0,0.55);
      filter: brightness(1.06);
    }

    /* 記号（色覚多様性対応） */
    .symbol {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-weight: 800;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
      color: rgba(255,255,255,0.38);
      text-shadow: 0 1px 2px rgba(0,0,0,0.55);
      pointer-events: none;
      user-select: none;
    }

    /* カラーブロック（ライトっぽく立体感） */
    .color-0 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #fff5f5, #ff6b6b 45%, #b52e32 100%);
    }
    .color-1 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #f0f7ff, #4d8dff 45%, #25427f 100%);
    }
    .color-2 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #f1fff4, #4cd17b 45%, #1f6b3a 100%);
    }
    .color-3 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #fffaf0, #ffb347 45%, #b36819 100%);
    }
    .color-4 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #faf2ff, #c77dff 45%, #6a319d 100%);
    }

    button {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.85rem;
      cursor: pointer;
      background: #4f7dff;
      color: #fff;
      box-shadow: 0 3px 10px rgba(79,125,255,0.5);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
      white-space: nowrap;

      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-secondary {
      background: #3a4255;
      color: #e0e3f0;
      box-shadow: none;
    }

    .btn-warn {
      background: #3a4255;
      color: #ffb2b2;
      box-shadow: none;
    }

    .message {
      font-size: 0.85rem;
      min-height: 1.3em;
      margin-top: 6px;
      text-align: center;
      color: #c3c7d8;
    }

    .message.over {
      color: #ff9f6b;
      font-weight: 650;
    }

    .message.perfect {
      color: #7cffb1;
      font-weight: 750;
    }

    /* スコア内訳（直近の加点表示） */
    .delta {
      font-size: 0.82rem;
      min-height: 1.1em;
      text-align: center;
      color: #e7eaff;
      opacity: 0;
      transform: translateY(-2px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: none;
      user-select: none;
    }
    .delta.show {
      opacity: 1;
      transform: translateY(0);
    }

    .small-note {
      margin-top: 6px;
      font-size: 0.75rem;
      text-align: right;
      color: #9ca3b8;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>さめがめ</h1>
    <div class="subtitle">サイズと色数を変えて、ベストスコアを狙おう</div>

    <div class="settings-row">
      <label>
        サイズ：
        <select id="sizeSelect">
          <option value="8x8">8 × 8</option>
          <option value="10x10">10 × 10</option>
          <option value="10x12" selected>10 × 12（縦長）</option>
        </select>
      </label>
      <label>
        色数：
        <select id="colorSelect">
          <option value="3">3色（やさしめ）</option>
          <option value="4">4色</option>
          <option value="5" selected>5色（むずかしめ）</option>
        </select>
      </label>
    </div>

    <div class="status-row">
      <div class="score-label">スコア：<span id="score">0</span></div>
      <div class="high-score">ハイスコア：<span id="highScore">0</span></div>
    </div>

    <div class="btn-row">
      <div class="btn-group">
        <button id="newGameBtn">ニューゲーム</button>
        <button id="undoBtn" class="btn-secondary" disabled>Undo</button>
        <button id="redoBtn" class="btn-secondary" disabled>Redo</button>
        <button id="resetHighBtn" class="btn-warn">この設定のハイスコア消去</button>
      </div>
    </div>

    <div class="grid-wrapper">
      <div id="grid" class="grid"></div>
    </div>

    <div id="delta" class="delta"></div>
    <div id="message" class="message"></div>

    <div class="small-note">
      <div>※n個消しのスコア = n × n × 5</div>
      <div id="perfectNote">※全消しボーナス = —</div>
    </div>
  </div>

  <script>
    // ===== 定数 =====
    const SCORE_FACTOR = 5;
    const PERFECT_FACTOR = 10;          // 全消しボーナス = (横×縦×PERFECT_FACTOR)
    const INIT_TRY_LIMIT = 300;         // 初期盤面生成のリトライ上限
    const HISTORY_LIMIT = 80;           // Undo/Redoの履歴上限
    const LAST_SETTINGS_KEY = "samegameLastSettings_v2";

    // 色覚多様性：色ごとの記号（色数に応じて先頭から使う）
    const SYMBOLS = ["●", "■", "▲", "★", "◆", "✦", "✚"];

    // ===== 設定（UI＝ゲーム反映は即時） =====
    let COLS = 10;
    let ROWS = 12;
    let COLORS = 5;

    // ===== ハイスコアキー =====
    let HIGH_KEY = "";

    // ===== ゲーム状態 =====
    let board = [];
    let score = 0;
    let gameOver = false;

    // Undo/Redo
    let undoStack = [];
    let redoStack = [];

    // ハイライト管理
    let highlighted = []; // [[r,c], ...]
    let lastHoverCellKey = ""; // "r,c"

    // ===== DOM =====
    const gridEl = document.getElementById("grid");
    const scoreEl = document.getElementById("score");
    const messageEl = document.getElementById("message");
    const deltaEl = document.getElementById("delta");
    const highScoreEl = document.getElementById("highScore");
    const perfectNoteEl = document.getElementById("perfectNote");

    const newGameBtn = document.getElementById("newGameBtn");
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
    const resetHighBtn = document.getElementById("resetHighBtn");

    const sizeSelect = document.getElementById("sizeSelect");
    const colorSelect = document.getElementById("colorSelect");

    // ===== ユーティリティ =====
    function getHighScoreKey(cols, rows, colors) {
      return `samegameHighScore_${cols}x${rows}_c${colors}`;
    }

    function deepCopyBoard(b) {
      return b.map(row => row.slice());
    }

    function setMessage(text, cls = "message") {
      messageEl.textContent = text || "";
      messageEl.className = cls;
    }

    let deltaTimer = null;
    function showDelta(text) {
      if (!text) return;
      deltaEl.textContent = text;
      deltaEl.classList.add("show");
      if (deltaTimer) clearTimeout(deltaTimer);
      deltaTimer = setTimeout(() => {
        deltaEl.classList.remove("show");
      }, 650);
    }

    function updatePerfectNote() {
      const bonus = COLS * ROWS * PERFECT_FACTOR;
      perfectNoteEl.textContent = `※全消しボーナス = ${COLS} × ${ROWS} × ${PERFECT_FACTOR} = ${bonus}`;
    }

    function loadHighScore() {
      const raw = localStorage.getItem(HIGH_KEY);
      const val = raw ? parseInt(raw, 10) : 0;
      highScoreEl.textContent = isNaN(val) ? 0 : String(val);
    }

    function saveHighScoreIfNeeded() {
      const raw = localStorage.getItem(HIGH_KEY);
      const current = raw ? parseInt(raw, 10) : 0;
      const hi = isNaN(current) ? 0 : current;

      if (score > hi) {
        localStorage.setItem(HIGH_KEY, String(score));
        highScoreEl.textContent = String(score);
      }
    }

    function updateUndoRedoButtons() {
      undoBtn.disabled = undoStack.length === 0;
      redoBtn.disabled = redoStack.length === 0;
    }

    function pushUndoState() {
      const snapshot = {
        board: deepCopyBoard(board),
        score,
        gameOver,
        messageText: messageEl.textContent,
        messageClass: messageEl.className
      };
      undoStack.push(snapshot);
      if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
      redoStack = [];
      updateUndoRedoButtons();
    }

    function applySnapshot(snap) {
      board = deepCopyBoard(snap.board);
      score = snap.score;
      gameOver = !!snap.gameOver;
      messageEl.textContent = snap.messageText || "";
      messageEl.className = snap.messageClass || "message";
      clearHighlight();
      updateStatus();
      renderBoard();
      updateUndoRedoButtons();
    }

    function undo() {
      if (undoStack.length === 0) return;
      const current = {
        board: deepCopyBoard(board),
        score,
        gameOver,
        messageText: messageEl.textContent,
        messageClass: messageEl.className
      };
      redoStack.push(current);
      const prev = undoStack.pop();
      applySnapshot(prev);
    }

    function redo() {
      if (redoStack.length === 0) return;
      const current = {
        board: deepCopyBoard(board),
        score,
        gameOver,
        messageText: messageEl.textContent,
        messageClass: messageEl.className
      };
      undoStack.push(current);
      const next = redoStack.pop();
      applySnapshot(next);
    }

    // ===== 設定保存／復元 =====
    function readSettingsFromUI() {
      const sizeVal = sizeSelect.value;
      const [colsStr, rowsStr] = sizeVal.split("x");
      return {
        cols: parseInt(colsStr, 10),
        rows: parseInt(rowsStr, 10),
        colors: parseInt(colorSelect.value, 10),
        sizeVal,
        colorVal: colorSelect.value
      };
    }

    function applySettingsToUI(sizeVal, colorVal) {
      if (typeof sizeVal === "string") {
        const ok = Array.from(sizeSelect.options).some(o => o.value === sizeVal);
        if (ok) sizeSelect.value = sizeVal;
      }
      if (typeof colorVal === "string") {
        const ok = Array.from(colorSelect.options).some(o => o.value === colorVal);
        if (ok) colorSelect.value = colorVal;
      }
    }

    function loadLastSettingsIntoUI() {
      try {
        const raw = localStorage.getItem(LAST_SETTINGS_KEY);
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return;
        applySettingsToUI(obj.size, obj.colors);
      } catch (_) {
        // ignore
      }
    }

    function saveLastSettingsFromUI() {
      const s = readSettingsFromUI();
      const payload = { size: s.sizeVal, colors: s.colorVal };
      localStorage.setItem(LAST_SETTINGS_KEY, JSON.stringify(payload));
    }

    function applySettingsFromUI() {
      const s = readSettingsFromUI();
      COLS = s.cols;
      ROWS = s.rows;
      COLORS = s.colors;

      HIGH_KEY = getHighScoreKey(COLS, ROWS, COLORS);
      loadHighScore();

      gridEl.style.setProperty("--cols", String(COLS));
      updatePerfectNote();
    }

    // ===== 盤面生成 =====
    function initBoard() {
      score = 0;
      gameOver = false;
      undoStack = [];
      redoStack = [];
      updateUndoRedoButtons();
      clearHighlight();
      setMessage("");
      deltaEl.textContent = "";
      deltaEl.classList.remove("show");

      gridEl.classList.add("animate");

      let generated = false;
      for (let tries = 0; tries < INIT_TRY_LIMIT; tries++) {
        const b = [];
        for (let r = 0; r < ROWS; r++) {
          const row = [];
          for (let c = 0; c < COLS; c++) {
            row.push(Math.floor(Math.random() * COLORS));
          }
          b.push(row);
        }
        board = b;
        if (hasAnyMove()) {
          generated = true;
          break;
        }
      }

      updateStatus();
      renderBoard();
      saveHighScoreIfNeeded(); // 0でも整合のため（表示はそのまま）

      setTimeout(() => gridEl.classList.remove("animate"), 260);

      if (!generated) {
        gameOver = true;
        setMessage("初期盤面の生成に失敗しました。ニューゲームを押してください。", "message over");
      }
    }

    function updateStatus() {
      scoreEl.textContent = String(score);
    }

    // ===== 描画 =====
    function renderBoard() {
      gridEl.innerHTML = "";

      const symList = SYMBOLS.slice(0, Math.max(1, COLORS));

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement("div");
          const inner = document.createElement("div");
          inner.className = "cell-inner";
          cell.appendChild(inner);

          cell.classList.add("cell");

          const v = board[r][c];
          if (v === null) {
            cell.classList.add("empty");
          } else {
            cell.classList.add(`color-${v}`);
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);

            // 記号（色覚多様性）
            const sym = symList[v] ?? symList[v % symList.length] ?? "●";
            const symEl = document.createElement("div");
            symEl.className = "symbol";
            symEl.textContent = sym;
            cell.appendChild(symEl);
          }

          gridEl.appendChild(cell);
        }
      }
    }

    // ===== ハイライト =====
    function idxOf(r, c) {
      return r * COLS + c;
    }

    function clearHighlight() {
      if (highlighted.length === 0) return;
      for (const [r, c] of highlighted) {
        const i = idxOf(r, c);
        const el = gridEl.children[i];
        if (el) el.classList.remove("hl");
      }
      highlighted = [];
      lastHoverCellKey = "";
    }

    function highlightClusterAt(r, c) {
      if (gameOver) return;

      const key = `${r},${c}`;
      if (key === lastHoverCellKey) return;
      lastHoverCellKey = key;

      clearHighlight();

      const color = board[r]?.[c];
      if (color === null || color === undefined) return;

      const cluster = getCluster(r, c, color);
      if (cluster.length < 2) return;

      highlighted = cluster;
      for (const [rr, cc] of cluster) {
        const i = idxOf(rr, cc);
        const el = gridEl.children[i];
        if (el) el.classList.add("hl");
      }
    }

    // ===== ゲームロジック =====
    function onGridClick(e) {
      if (gameOver) return;

      const cell = e.target.closest(".cell");
      if (!cell || !gridEl.contains(cell)) return;
      if (cell.classList.contains("empty")) return;

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      if (!Number.isFinite(r) || !Number.isFinite(c)) return;

      const color = board[r][c];
      if (color === null) return;

      const cluster = getCluster(r, c, color);
      if (cluster.length < 2) return;

      // Undo保存
      pushUndoState();

      // スコア加算
      const n = cluster.length;
      const gained = n * n * SCORE_FACTOR;
      score += gained;

      // 消す
      for (const [rr, cc] of cluster) {
        board[rr][cc] = null;
      }

      applyGravity();
      shiftColumnsLeft();

      clearHighlight();
      updateStatus();
      renderBoard();

      showDelta(`${n}個消し +${gained}`);
      saveHighScoreIfNeeded();
      checkGameEnd();
    }

    function onGridPointerMove(e) {
      const cell = e.target.closest(".cell");
      if (!cell || !gridEl.contains(cell)) return;
      if (cell.classList.contains("empty")) { clearHighlight(); return; }

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      if (!Number.isFinite(r) || !Number.isFinite(c)) return;

      highlightClusterAt(r, c);
    }

    function onGridPointerLeave() {
      clearHighlight();
    }

    function getCluster(sr, sc, color) {
      const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      const stack = [[sr, sc]];
      const cluster = [];

      while (stack.length > 0) {
        const [r, c] = stack.pop();
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS) continue;
        if (visited[r][c]) continue;
        if (board[r][c] !== color) continue;

        visited[r][c] = true;
        cluster.push([r, c]);

        stack.push([r - 1, c]);
        stack.push([r + 1, c]);
        stack.push([r, c - 1]);
        stack.push([r, c + 1]);
      }
      return cluster;
    }

    function applyGravity() {
      for (let c = 0; c < COLS; c++) {
        const col = [];
        for (let r = ROWS - 1; r >= 0; r--) {
          const v = board[r][c];
          if (v !== null) col.push(v);
        }
        let idx = 0;
        for (let r = ROWS - 1; r >= 0; r--) {
          board[r][c] = (idx < col.leng
