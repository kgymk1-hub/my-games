<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>さめがめ（サイズ＆色数選択可）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #1f2430;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }

    .game-container {
      background: #262c3a;
      padding: 18px 16px 20px;
      border-radius: 16px;
      box-shadow: 0 14px 32px rgba(0,0,0,0.5);
      width: 380px;
      max-width: 100%;
      box-sizing: border-box;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.25rem;
      text-align: center;
    }

    .subtitle {
      font-size: 0.8rem;
      text-align: center;
      color: #c3c7d8;
      margin-bottom: 8px;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 0.8rem;
    }

    .settings-row label {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    select {
      background: #333949;
      color: #f1f1f1;
      border-radius: 6px;
      border: 1px solid #444b5e;
      padding: 4px 6px;
      font-size: 0.8rem;
      outline: none;
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      margin-bottom: 6px;
    }

    .score-label span {
      font-weight: 600;
    }

    .high-score {
      font-size: 0.78rem;
      color: #c3c7d8;
    }

    .grid-wrapper {
      display: flex;
      justify-content: center;
      margin: 6px 0 10px;
    }

    /* JSから列数だけ渡してレイアウトはCSS側に寄せる */
    .grid {
      --cols: 10;
      width: 100%;
      max-width: 320px;
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: 3px;
      background: #1a1f2a;
      padding: 5px;
      border-radius: 10px;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
      box-sizing: border-box;
    }

    @keyframes popIn {
      from { transform: scale(0.92); opacity: 0; }
      to   { transform: scale(1); opacity: 1; }
    }

    /* 初回生成（ニューゲーム直後）だけ軽く出現アニメ */
    .grid.animate .cell:not(.empty) {
      animation: popIn 0.22s ease-out;
    }

    .cell {
      width: 100%;
      padding-bottom: 100%; /* 正方形 */
      border-radius: 6px;
      cursor: pointer;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.4);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.12s ease;
      position: relative;
      overflow: hidden;

      /* スマホの誤ズーム抑止 */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    .cell-inner {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: #555;
    }

    .cell:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.6);
    }

    .cell.empty {
      opacity: 0;
      pointer-events: none;
      box-shadow: none;
      border: none;
    }

    /* カラーブロック（ライトっぽく立体感） */
    .color-0 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #fff5f5, #ff6b6b 45%, #b52e32 100%);
    }
    .color-1 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #f0f7ff, #4d8dff 45%, #25427f 100%);
    }
    .color-2 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #f1fff4, #4cd17b 45%, #1f6b3a 100%);
    }
    .color-3 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #fffaf0, #ffb347 45%, #b36819 100%);
    }
    .color-4 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #faf2ff, #c77dff 45%, #6a319d 100%);
    }

    button {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.85rem;
      cursor: pointer;
      background: #4f7dff;
      color: #fff;
      box-shadow: 0 3px 10px rgba(79,125,255,0.5);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
      white-space: nowrap;

      /* スマホの誤ズーム抑止 */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .btn-secondary {
      background: #3a4255;
      color: #e0e3f0;
      box-shadow: none;
    }

    .message {
      font-size: 0.85rem;
      min-height: 1.3em;
      margin-top: 6px;
      text-align: center;
      color: #c3c7d8;
    }

    .message.over {
      color: #ff9f6b;
      font-weight: 600;
    }

    .message.perfect {
      color: #7cffb1;
      font-weight: 700;
    }

    .small-note {
      margin-top: 6px;
      font-size: 0.75rem;
      text-align: right;
      color: #9ca3b8;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>さめがめ</h1>
    <div class="subtitle">サイズと色数を変えて、ベストスコアを狙おう</div>

    <div class="settings-row">
      <label>
        サイズ：
        <select id="sizeSelect">
          <option value="8x8">8 × 8</option>
          <option value="10x10">10 × 10</option>
          <option value="10x12" selected>10 × 12（縦長）</option>
        </select>
      </label>
      <label>
        色数：
        <select id="colorSelect">
          <option value="3">3色（やさしめ）</option>
          <option value="4">4色</option>
          <option value="5" selected>5色（むずかしめ）</option>
        </select>
      </label>
    </div>

    <div class="status-row">
      <div class="score-label">スコア：<span id="score">0</span></div>
      <div class="high-score">ハイスコア：<span id="highScore">0</span></div>
    </div>

    <div class="status-row">
      <div>手数：<span id="moves">0</span></div>
      <div>
        <button id="newGameBtn">ニューゲーム</button>
        <button id="resetHighBtn" class="btn-secondary">この設定のハイスコア消去</button>
      </div>
    </div>

    <div class="grid-wrapper">
      <div id="grid" class="grid"></div>
    </div>

    <div id="message" class="message"></div>
    <div class="small-note">※n個消しのスコア = n × n × 5</div>
  </div>

  <script>
    // ===== 定数 =====
    const SCORE_FACTOR = 5;

    // 前回「ニューゲームで開始した設定」を保存するキー
    const LAST_SETTINGS_KEY = "samegameLastSettings_v1";

    // ===== ゲーム本体が使う設定（プレイ中に変わらない） =====
    let GAME_COLS = 10;
    let GAME_ROWS = 12;
    let GAME_COLORS = 5;

    // ===== UIで選択中の設定（プレビュー用） =====
    let SEL_COLS = 10;
    let SEL_ROWS = 12;
    let SEL_COLORS = 5;

    // ハイスコアキー（ゲーム用 / UI選択用）
    let GAME_HIGH_KEY = "";
    let SEL_HIGH_KEY = "";

    // ===== ゲーム状態 =====
    let board = [];
    let score = 0;
    let moves = 0;
    let gameOver = false;

    // ===== DOM =====
    const gridEl = document.getElementById("grid");
    const scoreEl = document.getElementById("score");
    const movesEl = document.getElementById("moves");
    const messageEl = document.getElementById("message");
    const highScoreEl = document.getElementById("highScore");
    const newGameBtn = document.getElementById("newGameBtn");
    const resetHighBtn = document.getElementById("resetHighBtn");
    const sizeSelect = document.getElementById("sizeSelect");
    const colorSelect = document.getElementById("colorSelect");

    // ハイスコア用キー
    function getHighScoreKey(cols, rows, colors) {
      return `samegameHighScore_${cols}x${rows}_c${colors}`;
    }

    // UI選択値を読む
    function readSettingsFromUI() {
      const sizeVal = sizeSelect.value; // "10x12" など
      const [colsStr, rowsStr] = sizeVal.split("x");
      return {
        cols: parseInt(colsStr, 10),
        rows: parseInt(rowsStr, 10),
        colors: parseInt(colorSelect.value, 10),
        sizeVal,
        colorVal: colorSelect.value
      };
    }

    // UIに設定を反映（存在するoptionのみ）
    function applySettingsToUI(sizeVal, colorVal) {
      if (typeof sizeVal === "string") {
        const ok = Array.from(sizeSelect.options).some(o => o.value === sizeVal);
        if (ok) sizeSelect.value = sizeVal;
      }
      if (typeof colorVal === "string") {
        const ok = Array.from(colorSelect.options).some(o => o.value === colorVal);
        if (ok) colorSelect.value = colorVal;
      }
    }

    // 前回遊んだ設定をUIに復元（ニューゲームで開始した設定）
    function loadLastPlayedSettingsIntoUI() {
      try {
        const raw = localStorage.getItem(LAST_SETTINGS_KEY);
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return;
        applySettingsToUI(obj.size, obj.colors);
      } catch (_) {
        // 壊れたJSON等は無視
      }
    }

    // 前回遊んだ設定を保存（ニューゲームで開始したとき）
    function saveLastPlayedSettingsFromUI() {
      const s = readSettingsFromUI();
      const payload = { size: s.sizeVal, colors: s.colorVal };
      localStorage.setItem(LAST_SETTINGS_KEY, JSON.stringify(payload));
    }

    // UI選択中の設定に対するハイスコアを表示（ゲーム設定は変えない）
    function updateHighScorePreviewFromUI() {
      const s = readSettingsFromUI();
      SEL_COLS = s.cols;
      SEL_ROWS = s.rows;
      SEL_COLORS = s.colors;

      SEL_HIGH_KEY = getHighScoreKey(SEL_COLS, SEL_ROWS, SEL_COLORS);

      const raw = localStorage.getItem(SEL_HIGH_KEY);
      const val = raw ? parseInt(raw, 10) : 0;
      highScoreEl.textContent = isNaN(val) ? 0 : val;
    }

    // ゲーム設定を「選択中（SEL_）」に同期（ニューゲーム開始時だけ）
    function applyGameSettingsFromSelection() {
      GAME_COLS = SEL_COLS;
      GAME_ROWS = SEL_ROWS;
      GAME_COLORS = SEL_COLORS;

      GAME_HIGH_KEY = SEL_HIGH_KEY;

      // 列数だけCSS変数で渡す（サイズ計算はブラウザに任せる）
      gridEl.style.setProperty("--cols", String(GAME_COLS));
    }

    // ハイスコア保存（ゲーム設定で保存）
    function saveHighScoreIfNeeded() {
      const raw = localStorage.getItem(GAME_HIGH_KEY);
      const currentHigh = raw ? parseInt(raw, 10) : 0;
      const hi = isNaN(currentHigh) ? 0 : currentHigh;

      if (score > hi) {
        localStorage.setItem(GAME_HIGH_KEY, String(score));
      }

      // 表示中の設定がゲームと同じ場合のみ、表示も更新
      if (SEL_HIGH_KEY === GAME_HIGH_KEY) {
        const shown = parseInt(highScoreEl.textContent, 10) || 0;
        if (score > shown) highScoreEl.textContent = String(score);
      }
    }

    // 新しい盤面をランダム生成（詰み盤面なら引き直し）
    function initBoard() {
      score = 0;
      moves = 0;
      gameOver = false;
      messageEl.textContent = "";
      messageEl.className = "message";

      // 生成直後だけ軽くアニメ
      gridEl.classList.add("animate");

      for (let tries = 0; tries < 300; tries++) {
        const b = [];
        for (let r = 0; r < GAME_ROWS; r++) {
          const row = [];
          for (let c = 0; c < GAME_COLS; c++) {
            row.push(Math.floor(Math.random() * GAME_COLORS));
          }
          b.push(row);
        }
        board = b;
        if (hasAnyMove()) break;
      }

      updateStatus();
      renderBoard();

      // アニメ解除（短時間だけ）
      setTimeout(() => gridEl.classList.remove("animate"), 260);
    }

    // DOM描画（イベントはデリゲーションで1回だけ付けるので、ここでは付けない）
    function renderBoard() {
      gridEl.innerHTML = "";

      for (let r = 0; r < GAME_ROWS; r++) {
        for (let c = 0; c < GAME_COLS; c++) {
          const cell = document.createElement("div");
          const inner = document.createElement("div");
          inner.className = "cell-inner";
          cell.appendChild(inner);

          cell.classList.add("cell");

          const colorIndex = board[r][c];
          if (colorIndex === null) {
            cell.classList.add("empty");
          } else {
            cell.classList.add(`color-${colorIndex}`);
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
          }

          gridEl.appendChild(cell);
        }
      }
    }

    // グリッドクリック（イベントデリゲーション）
    function onGridClick(e) {
      if (gameOver) return;

      const cell = e.target.closest(".cell");
      if (!cell || !gridEl.contains(cell)) return;
      if (cell.classList.contains("empty")) return;

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      if (!Number.isFinite(r) || !Number.isFinite(c)) return;

      const color = board[r][c];
      if (color === null) return;

      const cluster = getCluster(r, c, color);
      if (cluster.length < 2) return; // 1個だけは消せない

      const n = cluster.length;
      score += n * n * SCORE_FACTOR;
      moves++;

      // クラスタを消す
      for (const [rr, cc] of cluster) {
        board[rr][cc] = null;
      }

      applyGravity();
      shiftColumnsLeft();
      updateStatus();
      renderBoard();
      checkGameEnd();
    }

    // 同色クラスター探索（4方向）
    function getCluster(sr, sc, color) {
      const visited = Array.from({ length: GAME_ROWS }, () =>
        Array(GAME_COLS).fill(false)
      );
      const stack = [[sr, sc]];
      const cluster = [];

      while (stack.length > 0) {
        const [r, c] = stack.pop();
        if (r < 0 || r >= GAME_ROWS || c < 0 || c >= GAME_COLS) continue;
        if (visited[r][c]) continue;
        if (board[r][c] !== color) continue;

        visited[r][c] = true;
        cluster.push([r, c]);

        stack.push([r - 1, c]);
        stack.push([r + 1, c]);
        stack.push([r, c - 1]);
        stack.push([r, c + 1]);
      }

      return cluster;
    }

    // 下方向への重力
    function applyGravity() {
      for (let c = 0; c < GAME_COLS; c++) {
        const columnValues = [];
        for (let r = GAME_ROWS - 1; r >= 0; r--) {
          if (board[r][c] !== null) columnValues.push(board[r][c]);
        }
        let idx = 0;
        for (let r = GAME_ROWS - 1; r >= 0; r--) {
          board[r][c] = (idx < columnValues.length) ? columnValues[idx++] : null;
        }
      }
    }

    // 空列を詰めて左寄せ
    function shiftColumnsLeft() {
      const nonEmptyCols = [];
      for (let c = 0; c < GAME_COLS; c++) {
        let isEmpty = true;
        for (let r = 0; r < GAME_ROWS; r++) {
          if (board[r][c] !== null) { isEmpty = false; break; }
        }
        if (!isEmpty) nonEmptyCols.push(c);
      }

      const newBoard = Array.from({ length: GAME_ROWS }, () =>
        Array(GAME_COLS).fill(null)
      );

      for (let newC = 0; newC < nonEmptyCols.length; newC++) {
        const oldC = nonEmptyCols[newC];
        for (let r = 0; r < GAME_ROWS; r++) {
          newBoard[r][newC] = board[r][oldC];
        }
      }
      board = newBoard;
    }

    // まだ消せる塊があるかチェック
    function hasAnyMove() {
      for (let r = 0; r < GAME_ROWS; r++) {
        for (let c = 0; c < GAME_COLS; c++) {
          const color = board[r][c];
          if (color === null) continue;
          if (r > 0 && board[r - 1][c] === color) return true;
          if (r < GAME_ROWS - 1 && board[r + 1][c] === color) return true;
          if (c > 0 && board[r][c - 1] === color) return true;
          if (c < GAME_COLS - 1 && board[r][c + 1] === color) return true;
        }
      }
      return false;
    }

    // 全部消えたか
    function isBoardEmpty() {
      for (let r = 0; r < GAME_ROWS; r++) {
        for (let c = 0; c < GAME_COLS; c++) {
          if (board[r][c] !== null) return false;
        }
      }
      return true;
    }

    function checkGameEnd() {
      if (isBoardEmpty()) {
        gameOver = true;

        // パーフェクトボーナス（盤面サイズ比例）
        const perfectBonus = GAME_COLS * GAME_ROWS * 10;
        score += perfectBonus;
        updateStatus();

        messageEl.textContent = `パーフェクトクリア！ ボーナス +${perfectBonus}`;
        messageEl.className = "message perfect";
        saveHighScoreIfNeeded();
        return;
      }

      if (!hasAnyMove()) {
        gameOver = true;
        messageEl.textContent = "これ以上消せません。ゲームオーバー。";
        messageEl.className = "message over";
        saveHighScoreIfNeeded();
      }
    }

    function updateStatus() {
      scoreEl.textContent = String(score);
      movesEl.textContent = String(moves);
    }

    // ニューゲーム：選択中の設定をゲームに反映して開始
    function startNewGame() {
      updateHighScorePreviewFromUI();     // SEL_更新（表示も更新）
      applyGameSettingsFromSelection();   // ゲーム設定へ同期
      saveLastPlayedSettingsFromUI();     // 前回設定として保存
      initBoard();
    }

    // ===== イベント =====
    newGameBtn.addEventListener("click", startNewGame);

    resetHighBtn.addEventListener("click", () => {
      if (confirm("今のサイズ＆色数のハイスコアをリセットしますか？")) {
        localStorage.removeItem(SEL_HIGH_KEY);
        updateHighScorePreviewFromUI();
      }
    });

    // サイズ・色数変更：ハイスコア表示だけ切り替え（プレイ中でも安全）
    sizeSelect.addEventListener("change", updateHighScorePreviewFromUI);
    colorSelect.addEventListener("change", updateHighScorePreviewFromUI);

    // グリッドクリック（イベントデリゲーション）
    gridEl.addEventListener("click", onGridClick);

    // ===== 初期化 =====
    // 前回設定をUIに復元 → その設定で自動スタート
    loadLastPlayedSettingsIntoUI();
    updateHighScorePreviewFromUI();
    applyGameSettingsFromSelection();
    initBoard();
  </script>
</body>
</html>
