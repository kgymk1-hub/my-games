<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>さめがめ（サイズ＆色数選択可）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #1f2430;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }

    .game-container {
      background: #262c3a;
      padding: 18px 16px 20px;
      border-radius: 16px;
      box-shadow: 0 14px 32px rgba(0,0,0,0.5);
      width: 380px;
      max-width: 100%;
      box-sizing: border-box;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.25rem;
      text-align: center;
    }

    .subtitle {
      font-size: 0.8rem;
      text-align: center;
      color: #c3c7d8;
      margin-bottom: 8px;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 0.8rem;
    }

    .settings-row label {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    select {
      background: #333949;
      color: #f1f1f1;
      border-radius: 6px;
      border: 1px solid #444b5e;
      padding: 4px 6px;
      font-size: 0.8rem;
      outline: none;
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      margin-bottom: 6px;
      gap: 8px;
    }

    .score-label span {
      font-weight: 600;
    }

    .high-score {
      font-size: 0.78rem;
      color: #c3c7d8;
    }

    .grid-wrapper {
      display: flex;
      justify-content: center;
      margin: 6px 0 10px;
    }

    /* JSから列数だけ渡してレイアウトはCSS側に寄せる */
    .grid {
      --cols: 10;
      width: 100%;
      max-width: 320px;
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: 3px;
      background: #1a1f2a;
      padding: 5px;
      border-radius: 10px;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
      box-sizing: border-box;

      /* スコア演出の配置基準 */
      position: relative;
    }

    @keyframes popIn {
      from { transform: scale(0.92); opacity: 0; }
      to   { transform: scale(1); opacity: 1; }
    }
    /* 初回生成（ニューゲーム直後）だけ軽く出現アニメ */
    .grid.animate .cell:not(.empty) {
      animation: popIn 0.22s ease-out;
    }

    /* スコア加点のフロート表示 */
    @keyframes floatUp {
      from { transform: translate(-50%, -50%) translateY(0); opacity: 0; }
      15%  { opacity: 1; }
      to   { transform: translate(-50%, -50%) translateY(-18px); opacity: 0; }
    }
    .floating-score {
      position: absolute;
      z-index: 5;
      font-size: 0.82rem;
      font-weight: 700;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 2px 8px rgba(0,0,0,0.65);
      pointer-events: none;
      animation: floatUp 650ms ease-out forwards;
      white-space: nowrap;
    }

    .cell {
      width: 100%;
      padding-bottom: 100%; /* 正方形 */
      border-radius: 6px;
      cursor: pointer;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.4);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.12s ease, filter 0.12s ease;
      position: relative;
      overflow: hidden;

      /* スマホの誤ズーム抑止 */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    .cell-inner {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: #555;
    }

    /* 色覚多様性：薄い記号表示（attrで注入） */
    .cell[data-symbol] .cell-inner::after {
      content: attr(data-symbol);
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255,255,255,0.34);
      font-weight: 800;
      font-size: 0.95em;
      letter-spacing: 0.02em;
      pointer-events: none;
      text-shadow: 0 1px 4px rgba(0,0,0,0.35);
    }

    /* ヒント：消せる塊のハイライト */
    .cell.hint {
      filter: brightness(1.12) saturate(1.08);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.18), 0 4px 10px rgba(0,0,0,0.65);
      transform: translateY(-1px);
    }

    .cell:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.6);
    }

    .cell.empty {
      opacity: 0;
      pointer-events: none;
      box-shadow: none;
      border: none;
    }

    /* カラーブロック（ライトっぽく立体感） */
    .color-0 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #fff5f5, #ff6b6b 45%, #b52e32 100%);
    }
    .color-1 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #f0f7ff, #4d8dff 45%, #25427f 100%);
    }
    .color-2 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #f1fff4, #4cd17b 45%, #1f6b3a 100%);
    }
    .color-3 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #fffaf0, #ffb347 45%, #b36819 100%);
    }
    .color-4 .cell-inner {
      background: radial-gradient(circle at 30% 25%, #faf2ff, #c77dff 45%, #6a319d 100%);
    }

    button {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.85rem;
      cursor: pointer;
      background: #4f7dff;
      color: #fff;
      box-shadow: 0 3px 10px rgba(79,125,255,0.5);
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
      white-space: nowrap;

      /* スマホの誤ズーム抑止 */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: #3a4255;
      color: #e0e3f0;
      box-shadow: none;
    }

    .message {
      font-size: 0.85rem;
      min-height: 1.3em;
      margin-top: 6px;
      text-align: center;
      color: #c3c7d8;
    }

    .message.over {
      color: #ff9f6b;
      font-weight: 600;
    }

    .message.perfect {
      color: #7cffb1;
      font-weight: 700;
    }

    .small-note {
      margin-top: 6px;
      font-size: 0.75rem;
      text-align: right;
      color: #9ca3b8;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>さめがめ</h1>
    <div class="subtitle">サイズと色数を変えて、ベストスコアを狙おう</div>

    <div class="settings-row">
      <label>
        サイズ：
        <select id="sizeSelect">
          <option value="8x8">8 × 8</option>
          <option value="10x10">10 × 10</option>
          <option value="10x12" selected>10 × 12（縦長）</option>
        </select>
      </label>
      <label>
        色数：
        <select id="colorSelect">
          <option value="3">3色（やさしめ）</option>
          <option value="4">4色</option>
          <option value="5" selected>5色（むずかしめ）</option>
        </select>
      </label>
    </div>

    <div class="status-row">
      <div class="score-label">スコア：<span id="score">0</span></div>
      <div class="high-score">ハイスコア：<span id="highScore">0</span></div>
    </div>

    <div class="status-row">
      <div>手数：<span id="moves">0</span></div>
      <div style="display:flex; gap:6px; align-items:center;">
        <button id="newGameBtn">ニューゲーム</button>
        <button id="undoBtn" class="btn-secondary" disabled>1手戻す</button>
        <button id="resetHighBtn" class="btn-secondary">ハイスコア消去</button>
      </div>
    </div>

    <div class="grid-wrapper">
      <div id="grid" class="grid"></div>
    </div>

    <div id="message" class="message"></div>
    <div class="small-note">※n個消しのスコア = n × n × 5</div>
  </div>

  <script>
    // ===== 定数 =====
    const SCORE_FACTOR = 5;

    // 色覚多様性：色に加えて薄い記号（3～5色に対応）
    const COLOR_SYMBOLS = ["●", "■", "▲", "★", "◆"];

    // 前回「ニューゲームで開始した設定」を保存するキー
    const LAST_SETTINGS_KEY = "samegameLastSettings_v1";

    // ===== ゲーム本体が使う設定（プレイ中に変わらない） =====
    let GAME_COLS = 10;
    let GAME_ROWS = 12;
    let GAME_COLORS = 5;

    // ===== UIで選択中の設定（プレビュー用） =====
    let SEL_COLS = 10;
    let SEL_ROWS = 12;
    let SEL_COLORS = 5;

    // ハイスコアキー（ゲーム用 / UI選択用）
    let GAME_HIGH_KEY = "";
    let SEL_HIGH_KEY = "";

    // ===== ゲーム状態 =====
    let board = [];
    let score = 0;
    let moves = 0;
    let gameOver = false;

    // 1手戻す用の履歴
    /** @type {Array<{board:number[][], score:number, moves:number, gameOver:boolean, msgText:string, msgClass:string}>} */
    const historyStack = [];

    // ヒント用（直近ハイライトしたセルを保持）
    let lastHintCells = [];
    let lastHintKey = "";

    // 描画セル参照（高速に取りたいとき用）
    const cellMap = new Map(); // key: "r,c" -> cellEl

    // ===== DOM =====
    const gridEl = document.getElementById("grid");
    const scoreEl = document.getElementById("score");
    const movesEl = document.getElementById("moves");
    const messageEl = document.getElementById("message");
    const highScoreEl = document.getElementById("highScore");
    const newGameBtn = document.getElementById("newGameBtn");
    const undoBtn = document.getElementById("undoBtn");
    const resetHighBtn = document.getElementById("resetHighBtn");
    const sizeSelect = document.getElementById("sizeSelect");
    const colorSelect = document.getElementById("colorSelect");

    // ハイスコア用キー
    function getHighScoreKey(cols, rows, colors) {
      return `samegameHighScore_${cols}x${rows}_c${colors}`;
    }

    // UI選択値を読む
    function readSettingsFromUI() {
      const sizeVal = sizeSelect.value; // "10x12" など
      const [colsStr, rowsStr] = sizeVal.split("x");
      return {
        cols: parseInt(colsStr, 10),
        rows: parseInt(rowsStr, 10),
        colors: parseInt(colorSelect.value, 10),
        sizeVal,
        colorVal: colorSelect.value
      };
    }

    // UIに設定を反映（存在するoptionのみ）
    function applySettingsToUI(sizeVal, colorVal) {
      if (typeof sizeVal === "string") {
        const ok = Array.from(sizeSelect.options).some(o => o.value === sizeVal);
        if (ok) sizeSelect.value = sizeVal;
      }
      if (typeof colorVal === "string") {
        const ok = Array.from(colorSelect.options).some(o => o.value === colorVal);
        if (ok) colorSelect.value = colorVal;
      }
    }

    // 前回遊んだ設定をUIに復元（ニューゲームで開始した設定）
    function loadLastPlayedSettingsIntoUI() {
      try {
        const raw = localStorage.getItem(LAST_SETTINGS_KEY);
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return;
        applySettingsToUI(obj.size, obj.colors);
      } catch (_) {
        // 壊れたJSON等は無視
      }
    }

    // 前回遊んだ設定を保存（ニューゲームで開始したとき）
    function saveLastPlayedSettingsFromUI() {
      const s = readSettingsFromUI();
      const payload = { size: s.sizeVal, colors: s.colorVal };
      localStorage.setItem(LAST_SETTINGS_KEY, JSON.stringify(payload));
    }

    // UI選択中の設定に対するハイスコアを表示（ゲーム設定は変えない）
    function updateHighScorePreviewFromUI() {
      const s = readSettingsFromUI();
      SEL_COLS = s.cols;
      SEL_ROWS = s.rows;
      SEL_COLORS = s.colors;

      SEL_HIGH_KEY = getHighScoreKey(SEL_COLS, SEL_ROWS, SEL_COLORS);

      const raw = localStorage.getItem(SEL_HIGH_KEY);
      const val = raw ? parseInt(raw, 10) : 0;
      highScoreEl.textContent = isNaN(val) ? 0 : val;
    }

    // ゲーム設定を「選択中（SEL_）」に同期（ニューゲーム開始時だけ）
    function applyGameSettingsFromSelection() {
      GAME_COLS = SEL_COLS;
      GAME_ROWS = SEL_ROWS;
      GAME_COLORS = SEL_COLORS;

      GAME_HIGH_KEY = SEL_HIGH_KEY;

      // 列数だけCSS変数で渡す（サイズ計算はブラウザに任せる）
      gridEl.style.setProperty("--cols", String(GAME_COLS));
    }

    // ハイスコア保存（ゲーム設定で保存）
    function saveHighScoreIfNeeded() {
      const raw = localStorage.getItem(GAME_HIGH_KEY);
      const currentHigh = raw ? parseInt(raw, 10) : 0;
      const hi = isNaN(currentHigh) ? 0 : currentHigh;

      if (score > hi) {
        localStorage.setItem(GAME_HIGH_KEY, String(score));
      }

      // 表示中の設定がゲームと同じ場合のみ、表示も更新
      if (SEL_HIGH_KEY === GAME_HIGH_KEY) {
        const shown = parseInt(highScoreEl.textContent, 10) || 0;
        if (score > shown) highScoreEl.textContent = String(score);
      }
    }

    // ===== Undo関連 =====
    function deepCopyBoard(b) {
      return b.map(row => row.slice());
    }

    function pushHistory() {
      historyStack.push({
        board: deepCopyBoard(board),
        score,
        moves,
        gameOver,
        msgText: messageEl.textContent || "",
        msgClass: messageEl.className || "message"
      });
      updateUndoButton();
    }

    function updateUndoButton() {
      undoBtn.disabled = historyStack.length === 0;
    }

    function undoOnce() {
      if (historyStack.length === 0) return;
      const prev = historyStack.pop();
      board = deepCopyBoard(prev.board);
      score = prev.score;
      moves = prev.moves;
      gameOver = prev.gameOver;
      messageEl.textContent = prev.msgText;
      messageEl.className = prev.msgClass;

      clearHint();
      updateStatus();
      renderBoard();
      updateUndoButton();
    }

    // ===== 盤面生成 =====
    function initBoard() {
      score = 0;
      moves = 0;
      gameOver = false;
      messageEl.textContent = "";
      messageEl.className = "message";

      historyStack.length = 0;
      updateUndoButton();
      clearHint();

      // 生成直後だけ軽くアニメ
      gridEl.classList.add("animate");

      // triesを超えても生成できない“超エッジケース”のフォールバック
      const MAX_TRIES = 300;
      let ok = false;

      for (let tries = 0; tries < MAX_TRIES; tries++) {
        const b = [];
        for (let r = 0; r < GAME_ROWS; r++) {
          const row = [];
          for (let c = 0; c < GAME_COLS; c++) {
            row.push(Math.floor(Math.random() * GAME_COLORS));
          }
          b.push(row);
        }
        board = b;
        if (hasAnyMove()) { ok = true; break; }
      }

      updateStatus();
      renderBoard();

      // アニメ解除（短時間だけ）
      setTimeout(() => gridEl.classList.remove("animate"), 260);

      if (!ok) {
        // 生成失敗 → ゲームとして成立しないので停止＆案内
        gameOver = true;
        messageEl.textContent = "盤面生成に失敗しました。ニューゲームを押して再試行してください。";
        messageEl.className = "message over";
      }
    }

    // DOM描画（イベントはデリゲーションで1回だけ付ける）
    function renderBoard() {
      gridEl.innerHTML = "";
      cellMap.clear();

      for (let r = 0; r < GAME_ROWS; r++) {
        for (let c = 0; c < GAME_COLS; c++) {
          const cell = document.createElement("div");
          const inner = document.createElement("div");
          inner.className = "cell-inner";
          cell.appendChild(inner);

          cell.classList.add("cell");

          const colorIndex = board[r][c];
          if (colorIndex === null) {
            cell.classList.add("empty");
          } else {
            cell.classList.add(`color-${colorIndex}`);
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
            cell.dataset.symbol = COLOR_SYMBOLS[colorIndex] ?? "";
            cellMap.set(`${r},${c}`, cell);
          }

          gridEl.appendChild(cell);
        }
      }
    }

    // ===== ヒント（ホバー時にその塊を軽く強調）=====
    function clearHint() {
      for (const el of lastHintCells) el.classList.remove("hint");
      lastHintCells = [];
      lastHintKey = "";
    }

    function applyHintForCell(r, c) {
      const key = `${r},${c}`;
      if (key === lastHintKey) return;

      clearHint();
      lastHintKey = key;

      const color = board[r]?.[c];
      if (color === null || color === undefined) return;

      const cluster = getCluster(r, c, color);
      if (cluster.length < 2) return;

      const hintEls = [];
      for (const [rr, cc] of cluster) {
        const el = cellMap.get(`${rr},${cc}`);
        if (el) {
          el.classList.add("hint");
          hintEls.push(el);
        }
      }
      lastHintCells = hintEls;
    }

    // ===== スコア加点のフロート表示 =====
    function showFloatingScore(plus, anchorCellEl) {
      if (!anchorCellEl) return;

      const gridRect = gridEl.getBoundingClientRect();
      const cellRect = anchorCellEl.getBoundingClientRect();

      const x = (cellRect.left - gridRect.left) + cellRect.width / 2;
      const y = (cellRect.top - gridRect.top) + cellRect.height / 2;

      const span = document.createElement("div");
      span.className = "floating-score";
      span.textContent = `+${plus}`;

      span.style.left = `${x}px`;
      span.style.top  = `${y}px`;

      gridEl.appendChild(span);
      setTimeout(() => span.remove(), 700);
    }

    // ===== ゲーム操作 =====
    function onGridClick(e) {
      if (gameOver) return;

      const cell = e.target.closest(".cell");
      if (!cell || !gridEl.contains(cell)) return;
      if (cell.classList.contains("empty")) return;

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      if (!Number.isFinite(r) || !Number.isFinite(c)) return;

      const color = board[r][c];
      if (color === null) return;

      const cluster = getCluster(r, c, color);
      if (cluster.length < 2) return; // 1個だけは消せない

      // ここでUndo用に1手前を保存
      pushHistory();

      const n = cluster.length;
      const gained = n * n * SCORE_FACTOR;
      score += gained;
      moves++;

      // 加点演出（クリック地点に表示）
      showFloatingScore(gained, cell);

      // クラスタを消す
      for (const [rr, cc] of cluster) {
        board[rr][cc] = null;
      }

      clearHint();
      applyGravity();
      shiftColumnsLeft();
      updateStatus();
      renderBoard();
      checkGameEnd();
    }

    // ヒント（PC向け：ポインターが乗ったセルの塊を強調）
    function onGridPointerMove(e) {
      // タッチ中心環境ではヒントが暴れやすいので、hoverできる端末のみ
      if (!(window.matchMedia && window.matchMedia("(hover: hover)").matches)) return;

      const cell = e.target.closest(".cell");
      if (!cell || !gridEl.contains(cell)) { clearHint(); return; }
      if (cell.classList.contains("empty")) { clearHint(); return; }

      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      if (!Number.isFinite(r) || !Number.isFinite(c)) { clearHint(); return; }

      applyHintForCell(r, c);
    }

    function onGridPointerLeave() {
      clearHint();
    }

    // 同色クラスター探索（4方向）
    function getCluster(sr, sc, color) {
      const visited = Array.from({ length: GAME_ROWS }, () =>
        Array(GAME_COLS).fill(false)
      );
      const stack = [[sr, sc]];
      const cluster = [];

      while (stack.length > 0) {
        const [r, c] = stack.pop();
        if (r < 0 || r >= GAME_ROWS || c < 0 || c >= GAME_COLS) continue;
        if (visited[r][c]) continue;
        if (board[r][c] !== color) continue;

        visited[r][c] = true;
        cluster.push([r, c]);

        stack.push([r - 1, c]);
        stack.push([r + 1, c]);
        stack.push([r, c - 1]);
        stack.push([r, c + 1]);
      }

      return cluster;
    }

    // 下方向への重力
    function applyGravity() {
      for (let c = 0; c < GAME_COLS; c++) {
        const columnValues = [];
        for (let r = GAME_ROWS - 1; r >= 0; r--) {
          if (board[r][c] !== null) columnValues.push(board[r][c]);
        }
        let idx = 0;
        for (let r = GAME_ROWS - 1; r >= 0; r--) {
          board[r][c] = (idx < columnValues.length) ? columnValues[idx++] : null;
        }
      }
    }

    // 空列を詰めて左寄せ
    function shiftColumnsLeft() {
      const nonEmptyCols = [];
      for (let c = 0; c < GAME_COLS; c++) {
        let isEmpty = true;
        for (let r = 0; r < GAME_ROWS; r++) {
          if (board[r][c] !== null) { isEmpty = false; break; }
        }
        if (!isEmpty) nonEmptyCols.push(c);
      }

      const newBoard = Array.from({ length: GAME_ROWS }, () =>
        Array(GAME_COLS).fill(null)
      );

      for (let newC = 0; newC < nonEmptyCols.length; newC++) {
        const oldC = nonEmptyCols[newC];
        for (let r = 0; r < GAME_ROWS; r++) {
          newBoard[r][newC] = board
