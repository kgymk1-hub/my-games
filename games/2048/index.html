<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048</title>
  <style>
    :root {
      --bg: #f9f4ff;
      --board: #9b7df5;
      --empty: #c7b6ff;
      --text: #3b2f63;
      --light: #f9f6f2;
      --gap: min(2.5vw, 12px);
      --radius: 10px;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    * {
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #fff7e8, var(--bg));
      color: var(--text);
    }

    .page {
      width: min(92vw, 520px);
      padding: 18px 12px 28px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .title {
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 800;
    }

    .scores {
      display: flex;
      gap: 10px;
    }

    .score-box {
      background: linear-gradient(135deg, #7f5cff, #ff7dc5);
      color: var(--light);
      border-radius: 8px;
      padding: 8px 14px;
      text-align: center;
      min-width: 88px;
      box-shadow: 0 6px 14px rgba(63, 37, 128, 0.2);
    }

    .score-box span {
      display: block;
      font-size: 12px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      opacity: 0.8;
    }

    .score-box strong {
      display: block;
      font-size: 20px;
      margin-top: 2px;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .sound-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.55);
      font-size: 12px;
      font-weight: 600;
      color: #4a3a72;
      box-shadow: 0 4px 10px rgba(63, 37, 128, 0.12);
      flex-wrap: wrap;
      max-width: 100%;
    }

    .sound-controls input[type="checkbox"] {
      accent-color: #ff6aa9;
      cursor: pointer;
    }

    .sound-controls input[type="range"] {
      width: clamp(70px, 28vw, 120px);
      accent-color: #7a5cff;
    }

    .sound-controls .volume-value {
      min-width: 18px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    button {
      background: linear-gradient(135deg, #ff8a5c, #ff5fa2);
      color: var(--light);
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.2s ease;
    }

    button:active {
      transform: scale(0.97);
    }

    .board {
      position: relative;
      background: linear-gradient(135deg, #7a5cff, #57b6ff);
      border-radius: var(--radius);
      padding: var(--gap);
      display: grid;
      width: 100%;
      aspect-ratio: 1 / 1;
      --tile-size: calc((100% - (3 * var(--gap))) / 4);
      grid-template-columns: repeat(4, var(--tile-size));
      grid-template-rows: repeat(4, var(--tile-size));
      gap: var(--gap);
      touch-action: none;
    }

    .cell {
      background: rgba(255, 255, 255, 0.38);
      border-radius: var(--radius);
    }

    .tile {
      position: absolute;
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: clamp(20px, 5vw, 36px);
      transition: transform 0.18s ease, opacity 0.18s ease;
      will-change: transform;
      box-shadow: 0 10px 18px rgba(41, 19, 84, 0.18);
    }

    .tile.new {
      animation: fade-in 0.2s ease;
    }

    .tile.merge {
      animation: merge 0.2s ease;
    }

    @keyframes fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes merge {
      from { transform: scale(1.12); }
      to { transform: scale(1); }
    }

    .message {
      margin-top: 14px;
      text-align: center;
      font-weight: 600;
      min-height: 24px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(250, 248, 239, 0.72);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      border-radius: var(--radius);
      z-index: 5;
      text-align: center;
      font-weight: 700;
      font-size: 22px;
    }

    .overlay.show {
      display: flex;
    }

    .overlay button {
      font-size: 16px;
    }

    @media (max-width: 480px) {
      .scores {
        width: 100%;
        justify-content: space-between;
      }

      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .controls {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title">2048</div>
      <div class="scores">
        <div class="score-box">
          <span>Score</span>
          <strong id="score">0</strong>
        </div>
        <div class="score-box">
          <span>Best</span>
          <strong id="best">0</strong>
        </div>
      </div>
      <div class="controls">
        <button id="undo" disabled>Undo</button>
        <button id="redo" disabled>Redo</button>
        <button id="new-game">New Game</button>
        <div class="sound-controls">
          <label>
            <input type="checkbox" id="sound-toggle" />
            Sound
          </label>
          <input type="range" id="sound-volume" min="0" max="10" step="1" />
          <span class="volume-value" id="volume-value">5</span>
        </div>
      </div>
    </header>

    <div class="board" id="board">
      <div class="overlay" id="overlay">
        <div id="overlay-text"></div>
        <button id="overlay-button">Try Again</button>
      </div>
    </div>

    <div class="message" id="message"></div>
  </div>

  <script>
    const size = 4;
    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const messageEl = document.getElementById("message");
    const newGameBtn = document.getElementById("new-game");
    const undoBtn = document.getElementById("undo");
    const redoBtn = document.getElementById("redo");
    const soundToggle = document.getElementById("sound-toggle");
    const soundVolume = document.getElementById("sound-volume");
    const volumeValue = document.getElementById("volume-value");
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlay-text");
    const overlayButton = document.getElementById("overlay-button");

    let grid = [];
    let score = 0;
    let best = Number(localStorage.getItem("best-score") || 0);
    let hasWon = false;
    let inputLocked = false;
    let tileId = 0;
    let history = [];
    let future = [];
    let audioContext = null;
    let masterGain = null;
    let noiseBuffer = null;
    const storedVolume = Number(localStorage.getItem("sound-volume"));
    const soundSettings = {
      enabled: localStorage.getItem("sound-enabled") !== "false",
      volume: Number.isFinite(storedVolume)
        ? Math.min(10, Math.max(0, storedVolume))
        : 5
    };

    const colors = {
      2: "#b5e4ff",
      4: "#a6ffe0",
      8: "#7fe4ff",
      16: "#7dc8ff",
      32: "#8aa8ff",
      64: "#a683ff",
      128: "#c96bff",
      256: "#ff6bc4",
      512: "#ff7a84",
      1024: "#ff9f66",
      2048: "#ffd166"
    };

    function setupBoard() {
      boardEl.querySelectorAll(".cell").forEach((cell) => cell.remove());
      for (let i = 0; i < size * size; i += 1) {
        const cell = document.createElement("div");
        cell.className = "cell";
        boardEl.appendChild(cell);
      }
    }

    function emptyGrid() {
      grid = Array.from({ length: size }, () => Array(size).fill(null));
    }

    function cloneGridValues() {
      return grid.map((row) => row.map((tile) => (tile ? tile.value : 0)));
    }

    function restoreFromValues(values) {
      grid = values.map((row) =>
        row.map((value) => (value ? { id: (tileId += 1), value } : null))
      );
    }

    function pushHistory(state) {
      history.push(state);
      if (history.length > 50) {
        history = history.slice(history.length - 50);
      }
      future = [];
      updateUndoRedo();
    }

    function updateUndoRedo() {
      undoBtn.disabled = history.length === 0;
      redoBtn.disabled = future.length === 0;
    }

    function updateScores() {
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        localStorage.setItem("best-score", String(best));
      }
      bestEl.textContent = best;
    }

    function updateSoundUI() {
      soundToggle.checked = soundSettings.enabled;
      soundVolume.value = String(soundSettings.volume);
      volumeValue.textContent = String(soundSettings.volume);
      if (masterGain) {
        masterGain.gain.value = soundSettings.volume / 10;
      }
    }

    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = soundSettings.volume / 10;
        masterGain.connect(audioContext.destination);
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
    }

    function playTone({ frequency, duration, type = "sine", detune = 0 }) {
      if (!soundSettings.enabled) return;
      ensureAudioContext();
      if (!audioContext || !masterGain) return;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.type = type;
      oscillator.frequency.value = frequency;
      oscillator.detune.value = detune;
      gainNode.gain.value = 0.0001;
      oscillator.connect(gainNode);
      gainNode.connect(masterGain);
      const now = audioContext.currentTime;
      gainNode.gain.exponentialRampToValueAtTime(0.15, now + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      oscillator.start(now);
      oscillator.stop(now + duration + 0.02);
    }

    function ensureNoiseBuffer() {
      if (!audioContext || noiseBuffer) return;
      const bufferSize = audioContext.sampleRate;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i += 1) {
        data[i] = Math.random() * 2 - 1;
      }
      noiseBuffer = buffer;
    }

    function playSlideSound() {
      if (!soundSettings.enabled) return;
      ensureAudioContext();
      if (!audioContext || !masterGain) return;
      ensureNoiseBuffer();
      if (!noiseBuffer) return;

      const source = audioContext.createBufferSource();
      source.buffer = noiseBuffer;
      const filter = audioContext.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.value = 700;
      const gainNode = audioContext.createGain();
      gainNode.gain.value = 0.0001;

      source.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(masterGain);

      const now = audioContext.currentTime;
      gainNode.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
      source.start(now);
      source.stop(now + 0.14);
    }

    function playMergeSound() {
      if (!soundSettings.enabled) return;
      ensureAudioContext();
      if (!audioContext || !masterGain) return;

      const now = audioContext.currentTime;
      const gainNode = audioContext.createGain();
      gainNode.gain.value = 0.0001;
      gainNode.connect(masterGain);
      gainNode.gain.exponentialRampToValueAtTime(0.2, now + 0.015);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);

      const oscPrimary = audioContext.createOscillator();
      oscPrimary.type = "triangle";
      oscPrimary.frequency.setValueAtTime(520, now);
      oscPrimary.frequency.exponentialRampToValueAtTime(980, now + 0.18);

      const oscAccent = audioContext.createOscillator();
      oscAccent.type = "sine";
      oscAccent.frequency.setValueAtTime(820, now);
      oscAccent.frequency.exponentialRampToValueAtTime(1400, now + 0.16);

      oscPrimary.connect(gainNode);
      oscAccent.connect(gainNode);

      oscPrimary.start(now);
      oscAccent.start(now + 0.015);
      oscPrimary.stop(now + 0.24);
      oscAccent.stop(now + 0.22);
    }

    function randomEmptyCell() {
      const empties = [];
      grid.forEach((row, r) => {
        row.forEach((value, c) => {
          if (!value) {
            empties.push({ r, c });
          }
        });
      });
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function addRandomTile() {
      const cell = randomEmptyCell();
      if (!cell) return null;
      const tile = {
        id: (tileId += 1),
        value: Math.random() < 0.9 ? 2 : 4
      };
      grid[cell.r][cell.c] = tile;
      return tile;
    }

    function renderTiles(animations = []) {
      const existingTiles = new Map();
      boardEl.querySelectorAll(".tile").forEach((tile) => {
        existingTiles.set(Number(tile.dataset.id), tile);
      });
      const usedIds = new Set();

      grid.forEach((row, r) => {
        row.forEach((tileData, c) => {
          if (!tileData) return;
          const { id, value } = tileData;
          const tile = existingTiles.get(id) || document.createElement("div");
          tile.className = "tile";
          tile.dataset.id = String(id);
          tile.textContent = value;
          const offset = getOffset(r, c);
          tile.style.transform = `translate(${offset.x}px, ${offset.y}px)`;
          tile.style.background = colors[value] || "#3c3a32";
          tile.style.color = value <= 4 ? "#776e65" : "#f9f6f2";
          tile.style.fontSize = value >= 1024 ? "20px" : "clamp(20px, 5vw, 36px)";

          tile.classList.remove("new", "merge");
          const animation = animations.find((item) => item.id === id);
          if (animation?.pop) tile.classList.add("new");
          if (animation?.merge) tile.classList.add("merge");

          if (!tile.parentElement) {
            boardEl.appendChild(tile);
          }
          usedIds.add(id);
        });
      });

      existingTiles.forEach((tile, id) => {
        if (!usedIds.has(id)) {
          tile.remove();
        }
      });
    }

    function getOffset(r, c) {
      const sizePx = boardEl.querySelector(".cell").getBoundingClientRect().width;
      const styles = getComputedStyle(boardEl);
      const gap = parseFloat(styles.gap);
      const padding = parseFloat(styles.paddingLeft);
      return {
        x: padding + c * (sizePx + gap),
        y: padding + r * (sizePx + gap)
      };
    }

    function startGame() {
      score = 0;
      hasWon = false;
      tileId = 0;
      overlay.classList.remove("show");
      messageEl.textContent = "";
      emptyGrid();
      const first = addRandomTile();
      const second = addRandomTile();
      history = [];
      future = [];
      updateScores();
      updateUndoRedo();
      renderTiles(
        [first, second].filter(Boolean).map((tile) => ({ id: tile.id, pop: true }))
      );
    }

    function canMove() {
      for (let r = 0; r < size; r += 1) {
        for (let c = 0; c < size; c += 1) {
          const tile = grid[r][c];
          if (!tile) return true;
          if (r < size - 1 && grid[r + 1][c]?.value === tile.value) return true;
          if (c < size - 1 && grid[r][c + 1]?.value === tile.value) return true;
        }
      }
      return false;
    }

    function slide(row) {
      const filtered = row.filter(Boolean);
      const merged = [];
      const merges = [];
      for (let i = 0; i < filtered.length; i += 1) {
        const current = filtered[i];
        const next = filtered[i + 1];
        if (next && current.value === next.value) {
          const newValue = current.value * 2;
          const newTile = { id: current.id, value: newValue };
          merged.push(newTile);
          merges.push(newTile.id);
          score += newValue;
          if (newValue === 2048) hasWon = true;
          i += 1;
        } else {
          merged.push(current);
        }
      }
      while (merged.length < size) {
        merged.push(null);
      }
      return { line: merged, merges };
    }

    function move(direction) {
      if (inputLocked) return;
      const previousState = {
        grid: cloneGridValues(),
        score,
        hasWon
      };
      let moved = false;
      const animations = [];
      let mergeCount = 0;

      function recordAnimation(id, type) {
        animations.push({ id, [type]: true });
      }

      function rowsEqual(a, b) {
        return a.every((tile, index) => {
          const other = b[index];
          if (!tile && !other) return true;
          if (!tile || !other) return false;
          return tile.id === other.id && tile.value === other.value;
        });
      }

      if (direction === "left") {
        for (let r = 0; r < size; r += 1) {
          const current = grid[r];
          const { line, merges } = slide(current);
          if (!rowsEqual(current, line)) {
            moved = true;
            grid[r] = line;
            merges.forEach((id) => recordAnimation(id, "merge"));
            mergeCount += merges.length;
          }
        }
      }

      if (direction === "right") {
        for (let r = 0; r < size; r += 1) {
          const current = [...grid[r]].reverse();
          const { line, merges } = slide(current);
          const next = line.reverse();
          const original = grid[r];
          if (!rowsEqual(original, next)) {
            moved = true;
            grid[r] = next;
            merges.forEach((id) => recordAnimation(id, "merge"));
            mergeCount += merges.length;
          }
        }
      }

      if (direction === "up") {
        for (let c = 0; c < size; c += 1) {
          const column = grid.map((row) => row[c]);
          const { line, merges } = slide(column);
          if (!rowsEqual(column, line)) {
            moved = true;
            for (let r = 0; r < size; r += 1) {
              grid[r][c] = line[r];
            }
            merges.forEach((id) => recordAnimation(id, "merge"));
            mergeCount += merges.length;
          }
        }
      }

      if (direction === "down") {
        for (let c = 0; c < size; c += 1) {
          const column = grid.map((row) => row[c]).reverse();
          const { line, merges } = slide(column);
          const nextColumn = line.reverse();
          if (!rowsEqual(grid.map((row) => row[c]), nextColumn)) {
            moved = true;
            for (let r = 0; r < size; r += 1) {
              grid[r][c] = nextColumn[r];
            }
            merges.forEach((id) => recordAnimation(id, "merge"));
            mergeCount += merges.length;
          }
        }
      }

      if (!moved) return;
      pushHistory(previousState);
      inputLocked = true;
      renderTiles(animations);
      updateScores();
      playSlideSound();
      if (mergeCount > 0) {
        playMergeSound();
      }

      setTimeout(() => {
        const newTile = addRandomTile();
        updateScores();
        renderTiles(newTile ? [{ id: newTile.id, pop: true }] : []);
        inputLocked = false;
        updateUndoRedo();
        if (hasWon) {
          showOverlay("You reached 2048!");
        } else if (!canMove()) {
          showOverlay("Game over!");
        }
      }, 180);
    }

    function showOverlay(text) {
      overlayText.textContent = text;
      overlay.classList.add("show");
    }

    function handleKey(event) {
      if (event.ctrlKey || event.metaKey) {
        const key = event.key.toLowerCase();
        if (key === "z") {
          event.preventDefault();
          if (event.shiftKey) {
            redo();
          } else {
            undo();
          }
          return;
        }
        if (key === "y") {
          event.preventDefault();
          redo();
          return;
        }
      }
      const keyMap = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down"
      };
      const direction = keyMap[event.key];
      if (!direction) return;
      event.preventDefault();
      move(direction);
    }

    function handleTouch() {
      let startX = 0;
      let startY = 0;

      boardEl.addEventListener("touchstart", (event) => {
        const touch = event.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
      });

      boardEl.addEventListener("touchend", (event) => {
        const touch = event.changedTouches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (Math.max(absX, absY) < 30) return;
        if (absX > absY) {
          move(dx > 0 ? "right" : "left");
        } else {
          move(dy > 0 ? "down" : "up");
        }
      });
    }

    function confirmReset() {
      if (confirm("Start a new game? Your current progress will be lost.")) {
        startGame();
      }
    }

    function undo() {
      if (history.length === 0 || inputLocked) return;
      const current = {
        grid: cloneGridValues(),
        score,
        hasWon
      };
      future.push(current);
      const previous = history.pop();
      restoreFromValues(previous.grid);
      score = previous.score;
      hasWon = previous.hasWon;
      overlay.classList.remove("show");
      updateScores();
      renderTiles();
      updateUndoRedo();
    }

    function redo() {
      if (future.length === 0 || inputLocked) return;
      const current = {
        grid: cloneGridValues(),
        score,
        hasWon
      };
      history.push(current);
      const next = future.pop();
      restoreFromValues(next.grid);
      score = next.score;
      hasWon = next.hasWon;
      overlay.classList.remove("show");
      updateScores();
      renderTiles();
      updateUndoRedo();
    }

    setupBoard();
    startGame();
    handleTouch();
    updateSoundUI();

    window.addEventListener("keydown", handleKey);
    newGameBtn.addEventListener("click", confirmReset);
    overlayButton.addEventListener("click", startGame);
    undoBtn.addEventListener("click", undo);
    redoBtn.addEventListener("click", redo);
    soundToggle.addEventListener("change", () => {
      soundSettings.enabled = soundToggle.checked;
      localStorage.setItem("sound-enabled", String(soundSettings.enabled));
      updateSoundUI();
    });
    soundVolume.addEventListener("input", () => {
      soundSettings.volume = Number(soundVolume.value);
      localStorage.setItem("sound-volume", String(soundSettings.volume));
      updateSoundUI();
    });
  </script>
</body>
</html>
