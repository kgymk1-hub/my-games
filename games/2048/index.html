<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048</title>
  <style>
    :root {
      --bg: #faf8ef;
      --board: #bbada0;
      --empty: #cdc1b4;
      --text: #776e65;
      --light: #f9f6f2;
      --tile-size: min(22vw, 110px);
      --gap: min(2.5vw, 12px);
      --radius: 10px;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    * {
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      color: var(--text);
    }

    .page {
      width: min(92vw, 520px);
      padding: 18px 12px 28px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .title {
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 800;
    }

    .scores {
      display: flex;
      gap: 10px;
    }

    .score-box {
      background: var(--board);
      color: var(--light);
      border-radius: 8px;
      padding: 8px 14px;
      text-align: center;
      min-width: 88px;
    }

    .score-box span {
      display: block;
      font-size: 12px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      opacity: 0.8;
    }

    .score-box strong {
      display: block;
      font-size: 20px;
      margin-top: 2px;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    button {
      background: #8f7a66;
      color: var(--light);
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.2s ease;
    }

    button:active {
      transform: scale(0.97);
    }

    .board {
      position: relative;
      background: var(--board);
      border-radius: var(--radius);
      padding: var(--gap);
      display: grid;
      grid-template-columns: repeat(4, var(--tile-size));
      grid-template-rows: repeat(4, var(--tile-size));
      gap: var(--gap);
      touch-action: none;
    }

    .cell {
      background: var(--empty);
      border-radius: var(--radius);
    }

    .tile {
      position: absolute;
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: clamp(20px, 5vw, 36px);
      transition: transform 0.18s ease, opacity 0.18s ease;
    }

    .tile.new {
      animation: pop 0.2s ease;
    }

    .tile.merge {
      animation: merge 0.2s ease;
    }

    @keyframes pop {
      from { transform: scale(0.4); opacity: 0.4; }
      to { transform: scale(1); opacity: 1; }
    }

    @keyframes merge {
      from { transform: scale(1.12); }
      to { transform: scale(1); }
    }

    .message {
      margin-top: 14px;
      text-align: center;
      font-weight: 600;
      min-height: 24px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(250, 248, 239, 0.72);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      border-radius: var(--radius);
      z-index: 5;
      text-align: center;
      font-weight: 700;
      font-size: 22px;
    }

    .overlay.show {
      display: flex;
    }

    .overlay button {
      font-size: 16px;
    }

    @media (max-width: 480px) {
      .scores {
        width: 100%;
        justify-content: space-between;
      }

      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .controls {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title">2048</div>
      <div class="scores">
        <div class="score-box">
          <span>Score</span>
          <strong id="score">0</strong>
        </div>
        <div class="score-box">
          <span>Best</span>
          <strong id="best">0</strong>
        </div>
      </div>
      <div class="controls">
        <button id="new-game">New Game</button>
      </div>
    </header>

    <div class="board" id="board">
      <div class="overlay" id="overlay">
        <div id="overlay-text"></div>
        <button id="overlay-button">Try Again</button>
      </div>
    </div>

    <div class="message" id="message"></div>
  </div>

  <script>
    const size = 4;
    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const messageEl = document.getElementById("message");
    const newGameBtn = document.getElementById("new-game");
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlay-text");
    const overlayButton = document.getElementById("overlay-button");

    let grid = [];
    let score = 0;
    let best = Number(localStorage.getItem("best-score") || 0);
    let hasWon = false;
    let inputLocked = false;

    const colors = {
      2: "#eee4da",
      4: "#ede0c8",
      8: "#f2b179",
      16: "#f59563",
      32: "#f67c5f",
      64: "#f65e3b",
      128: "#edcf72",
      256: "#edcc61",
      512: "#edc850",
      1024: "#edc53f",
      2048: "#edc22e"
    };

    function setupBoard() {
      boardEl.querySelectorAll(".cell").forEach((cell) => cell.remove());
      for (let i = 0; i < size * size; i += 1) {
        const cell = document.createElement("div");
        cell.className = "cell";
        boardEl.appendChild(cell);
      }
    }

    function emptyGrid() {
      grid = Array.from({ length: size }, () => Array(size).fill(0));
    }

    function updateScores() {
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        localStorage.setItem("best-score", String(best));
      }
      bestEl.textContent = best;
    }

    function randomEmptyCell() {
      const empties = [];
      grid.forEach((row, r) => {
        row.forEach((value, c) => {
          if (value === 0) {
            empties.push({ r, c });
          }
        });
      });
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function addRandomTile() {
      const cell = randomEmptyCell();
      if (!cell) return;
      grid[cell.r][cell.c] = Math.random() < 0.9 ? 2 : 4;
      renderTiles([{ r: cell.r, c: cell.c, pop: true }]);
    }

    function renderTiles(animations = []) {
      boardEl.querySelectorAll(".tile").forEach((tile) => tile.remove());
      grid.forEach((row, r) => {
        row.forEach((value, c) => {
          if (value === 0) return;
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.textContent = value;
          const offset = getOffset(r, c);
          tile.style.transform = `translate(${offset.x}px, ${offset.y}px)`;
          tile.style.background = colors[value] || "#3c3a32";
          tile.style.color = value <= 4 ? "#776e65" : "#f9f6f2";
          tile.style.fontSize = value >= 1024 ? "20px" : "clamp(20px, 5vw, 36px)";

          const animation = animations.find((item) => item.r === r && item.c === c);
          if (animation?.pop) tile.classList.add("new");
          if (animation?.merge) tile.classList.add("merge");

          boardEl.appendChild(tile);
        });
      });
    }

    function getOffset(r, c) {
      const sizePx = boardEl.querySelector(".cell").getBoundingClientRect().width;
      const gap = parseFloat(getComputedStyle(boardEl).gap);
      return {
        x: c * (sizePx + gap),
        y: r * (sizePx + gap)
      };
    }

    function startGame() {
      score = 0;
      hasWon = false;
      overlay.classList.remove("show");
      messageEl.textContent = "";
      emptyGrid();
      addRandomTile();
      addRandomTile();
      updateScores();
      renderTiles();
    }

    function canMove() {
      for (let r = 0; r < size; r += 1) {
        for (let c = 0; c < size; c += 1) {
          const value = grid[r][c];
          if (value === 0) return true;
          if (r < size - 1 && grid[r + 1][c] === value) return true;
          if (c < size - 1 && grid[r][c + 1] === value) return true;
        }
      }
      return false;
    }

    function slide(row) {
      const filtered = row.filter((value) => value !== 0);
      const merged = [];
      for (let i = 0; i < filtered.length; i += 1) {
        if (filtered[i] === filtered[i + 1]) {
          const newValue = filtered[i] * 2;
          merged.push(newValue);
          score += newValue;
          if (newValue === 2048) hasWon = true;
          i += 1;
        } else {
          merged.push(filtered[i]);
        }
      }
      while (merged.length < size) {
        merged.push(0);
      }
      return merged;
    }

    function move(direction) {
      if (inputLocked) return;
      let moved = false;
      const animations = [];

      function recordAnimation(r, c, merge = false) {
        animations.push({ r, c, merge });
      }

      if (direction === "left") {
        for (let r = 0; r < size; r += 1) {
          const current = grid[r];
          const next = slide(current);
          if (next.some((value, i) => value !== current[i])) {
            moved = true;
            grid[r] = next;
            next.forEach((value, c) => {
              if (value && (current[c] !== value || current[c] === 0)) {
                recordAnimation(r, c, current[c] && current[c] !== value);
              }
            });
          }
        }
      }

      if (direction === "right") {
        for (let r = 0; r < size; r += 1) {
          const current = [...grid[r]].reverse();
          const next = slide(current).reverse();
          const original = grid[r];
          if (next.some((value, i) => value !== original[i])) {
            moved = true;
            grid[r] = next;
            next.forEach((value, c) => {
              if (value && (original[c] !== value || original[c] === 0)) {
                recordAnimation(r, c, original[c] && original[c] !== value);
              }
            });
          }
        }
      }

      if (direction === "up") {
        for (let c = 0; c < size; c += 1) {
          const column = grid.map((row) => row[c]);
          const nextColumn = slide(column);
          if (nextColumn.some((value, r) => value !== grid[r][c])) {
            moved = true;
            for (let r = 0; r < size; r += 1) {
              grid[r][c] = nextColumn[r];
              if (nextColumn[r] && column[r] !== nextColumn[r]) {
                recordAnimation(r, c, column[r] && column[r] !== nextColumn[r]);
              }
            }
          }
        }
      }

      if (direction === "down") {
        for (let c = 0; c < size; c += 1) {
          const column = grid.map((row) => row[c]).reverse();
          const nextColumn = slide(column).reverse();
          if (nextColumn.some((value, r) => value !== grid[r][c])) {
            moved = true;
            for (let r = 0; r < size; r += 1) {
              if (nextColumn[r] && grid[r][c] !== nextColumn[r]) {
                recordAnimation(r, c, grid[r][c] && grid[r][c] !== nextColumn[r]);
              }
              grid[r][c] = nextColumn[r];
            }
          }
        }
      }

      if (!moved) return;
      inputLocked = true;
      renderTiles(animations);
      updateScores();

      setTimeout(() => {
        addRandomTile();
        updateScores();
        renderTiles();
        inputLocked = false;
        if (hasWon) {
          showOverlay("You reached 2048!");
        } else if (!canMove()) {
          showOverlay("Game over!");
        }
      }, 180);
    }

    function showOverlay(text) {
      overlayText.textContent = text;
      overlay.classList.add("show");
    }

    function handleKey(event) {
      const keyMap = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down"
      };
      const direction = keyMap[event.key];
      if (!direction) return;
      event.preventDefault();
      move(direction);
    }

    function handleTouch() {
      let startX = 0;
      let startY = 0;

      boardEl.addEventListener("touchstart", (event) => {
        const touch = event.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
      });

      boardEl.addEventListener("touchend", (event) => {
        const touch = event.changedTouches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (Math.max(absX, absY) < 30) return;
        if (absX > absY) {
          move(dx > 0 ? "right" : "left");
        } else {
          move(dy > 0 ? "down" : "up");
        }
      });
    }

    function confirmReset() {
      if (confirm("Start a new game? Your current progress will be lost.")) {
        startGame();
      }
    }

    setupBoard();
    startGame();
    handleTouch();

    window.addEventListener("keydown", handleKey);
    newGameBtn.addEventListener("click", confirmReset);
    overlayButton.addEventListener("click", startGame);
  </script>
</body>
</html>
