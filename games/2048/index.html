<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048</title>
  <style>
    :root {
      --bg: #faf8ef;
      --board: #c7b6ff;
      --empty: #e6dcff;
      --text: #776e65;
      --light: #f9f6f2;
      --gap: min(2.5vw, 12px);
      --radius: 10px;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    * {
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      color: var(--text);
    }

    .page {
      width: min(92vw, 520px);
      padding: 18px 12px 28px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .title {
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 800;
    }

    .scores {
      display: flex;
      gap: 10px;
    }

    .score-box {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      color: var(--light);
      border-radius: 8px;
      padding: 8px 14px;
      text-align: center;
      min-width: 88px;
    }

    .score-box span {
      display: block;
      font-size: 12px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      opacity: 0.8;
    }

    .score-box strong {
      display: block;
      font-size: 20px;
      margin-top: 2px;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(135deg, #7f7bff, #ff9ad5);
      color: var(--light);
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.2s ease;
    }

    button:active {
      transform: scale(0.97);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn-undo {
      background: linear-gradient(135deg, #5ee7df, #b490ca);
    }

    .btn-redo {
      background: linear-gradient(135deg, #86ffbd, #fffb7d);
      color: #4d4d4d;
    }

    .btn-new {
      background: linear-gradient(135deg, #ff758c, #ff7eb3);
    }

    .sound-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #ffffffcc;
      padding: 6px 10px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      color: #5a4d83;
      font-size: 12px;
      font-weight: 600;
    }

    .sound-controls input[type="range"] {
      accent-color: #7f7bff;
    }

    .board {
      position: relative;
      background: var(--board);
      border-radius: var(--radius);
      padding: var(--gap);
      display: grid;
      width: 100%;
      aspect-ratio: 1 / 1;
      --tile-size: calc((100% - (5 * var(--gap))) / 4);
      grid-template-columns: repeat(4, var(--tile-size));
      grid-template-rows: repeat(4, var(--tile-size));
      gap: var(--gap);
      touch-action: none;
    }

    .cell {
      background: var(--empty);
      border-radius: var(--radius);
    }

    .tile {
      position: absolute;
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: clamp(20px, 5vw, 36px);
      transition: transform 0.18s ease, opacity 0.18s ease;
      will-change: transform;
      --row: 0;
      --col: 0;
      --tx: calc(var(--gap) + (var(--col) * (var(--tile-size) + var(--gap))));
      --ty: calc(var(--gap) + (var(--row) * (var(--tile-size) + var(--gap))));
      transform: translate(var(--tx), var(--ty));
    }

    .tile.new {
      animation: fade-in 0.22s ease;
    }

    .tile.merge {
      animation: merge 0.2s ease;
    }

    @keyframes fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes merge {
      from { transform: translate(var(--tx), var(--ty)) scale(1.12); }
      to { transform: translate(var(--tx), var(--ty)) scale(1); }
    }

    .message {
      margin-top: 14px;
      text-align: center;
      font-weight: 600;
      min-height: 24px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(250, 248, 239, 0.72);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      border-radius: var(--radius);
      z-index: 5;
      text-align: center;
      font-weight: 700;
      font-size: 22px;
    }

    .overlay.show {
      display: flex;
    }

    .overlay button {
      font-size: 16px;
    }

    @media (max-width: 480px) {
      .scores {
        width: 100%;
        justify-content: space-between;
      }

      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .controls {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title">2048</div>
      <div class="scores">
        <div class="score-box">
          <span>Score</span>
          <strong id="score">0</strong>
        </div>
        <div class="score-box">
          <span>Best</span>
          <strong id="best">0</strong>
        </div>
      </div>
      <div class="controls">
        <button class="btn-undo" id="undo" disabled>Undo</button>
        <button class="btn-redo" id="redo" disabled>Redo</button>
        <button class="btn-new" id="new-game">New Game</button>
        <div class="sound-controls">
          <button id="sound-toggle" aria-pressed="true">Sound: On</button>
          <label for="volume">Vol</label>
          <input id="volume" type="range" min="0" max="10" step="1" value="6" />
        </div>
      </div>
    </header>

    <div class="board" id="board">
      <div class="overlay" id="overlay">
        <div id="overlay-text"></div>
        <button id="overlay-button">Try Again</button>
      </div>
    </div>

    <div class="message" id="message"></div>
  </div>

  <script>
    const size = 4;
    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const messageEl = document.getElementById("message");
    const newGameBtn = document.getElementById("new-game");
    const undoBtn = document.getElementById("undo");
    const redoBtn = document.getElementById("redo");
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlay-text");
    const overlayButton = document.getElementById("overlay-button");
    const soundToggleBtn = document.getElementById("sound-toggle");
    const volumeSlider = document.getElementById("volume");

    let grid = [];
    let score = 0;
    let best = Number(localStorage.getItem("best-score") || 0);
    let hasWon = false;
    let inputLocked = false;
    let tileId = 0;
    let history = [];
    let future = [];
    let soundEnabled = localStorage.getItem("sound-enabled") !== "false";
    let soundVolume = Number(localStorage.getItem("sound-volume") || 6);
    let audioContext = null;

    const colors = {
      2: "#a5f3fc",
      4: "#c7d2fe",
      8: "#f9a8d4",
      16: "#fbcfe8",
      32: "#fda4af",
      64: "#fdba74",
      128: "#fef08a",
      256: "#bbf7d0",
      512: "#86efac",
      1024: "#93c5fd",
      2048: "#fcd34d"
    };

    function setupBoard() {
      boardEl.querySelectorAll(".cell").forEach((cell) => cell.remove());
      for (let i = 0; i < size * size; i += 1) {
        const cell = document.createElement("div");
        cell.className = "cell";
        boardEl.appendChild(cell);
      }
    }

    function emptyGrid() {
      grid = Array.from({ length: size }, () => Array(size).fill(null));
    }

    function cloneGridValues() {
      return grid.map((row) => row.map((tile) => (tile ? tile.value : 0)));
    }

    function restoreFromValues(values) {
      grid = values.map((row) =>
        row.map((value) => (value ? { id: (tileId += 1), value } : null))
      );
    }

    function pushHistory(state) {
      history.push(state);
      if (history.length > 50) {
        history = history.slice(history.length - 50);
      }
      future = [];
      updateUndoRedo();
    }

    function updateUndoRedo() {
      undoBtn.disabled = history.length === 0;
      redoBtn.disabled = future.length === 0;
    }

    function updateScores() {
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        localStorage.setItem("best-score", String(best));
      }
      bestEl.textContent = best;
    }

    function randomEmptyCell() {
      const empties = [];
      grid.forEach((row, r) => {
        row.forEach((value, c) => {
          if (!value) {
            empties.push({ r, c });
          }
        });
      });
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function addRandomTile() {
      const cell = randomEmptyCell();
      if (!cell) return null;
      const tile = {
        id: (tileId += 1),
        value: Math.random() < 0.9 ? 2 : 4
      };
      grid[cell.r][cell.c] = tile;
      return tile;
    }

    function renderTiles(animations = []) {
      const existingTiles = new Map();
      boardEl.querySelectorAll(".tile").forEach((tile) => {
        existingTiles.set(Number(tile.dataset.id), tile);
      });
      const usedIds = new Set();

      grid.forEach((row, r) => {
        row.forEach((tileData, c) => {
          if (!tileData) return;
          const { id, value } = tileData;
          const tile = existingTiles.get(id) || document.createElement("div");
          tile.className = "tile";
          tile.dataset.id = String(id);
          tile.textContent = value;
          tile.style.setProperty("--row", r);
          tile.style.setProperty("--col", c);
          tile.style.background = colors[value] || "#3c3a32";
          tile.style.color = value <= 4 ? "#3f3d56" : "#1b1b1b";
          tile.style.fontSize = value >= 1024 ? "20px" : "clamp(20px, 5vw, 36px)";

          tile.classList.remove("new", "merge");
          const animation = animations.find((item) => item.id === id);
          if (animation?.pop) tile.classList.add("new");
          if (animation?.merge) tile.classList.add("merge");

          if (!tile.parentElement) {
            boardEl.appendChild(tile);
          }
          usedIds.add(id);
        });
      });

      existingTiles.forEach((tile, id) => {
        if (!usedIds.has(id)) {
          tile.remove();
        }
      });
    }

    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
    }

    function playTone({ startFreq, endFreq, duration, type = "sine" }) {
      if (!soundEnabled) return;
      ensureAudioContext();
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const now = audioContext.currentTime;
      const volume = Math.max(0, Math.min(1, soundVolume / 10));
      osc.type = type;
      osc.frequency.setValueAtTime(startFreq, now);
      osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
      gain.gain.setValueAtTime(volume * 0.16, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.connect(gain).connect(audioContext.destination);
      osc.start(now);
      osc.stop(now + duration);
    }

    function playSlideSound() {
      playTone({ startFreq: 240, endFreq: 160, duration: 0.12, type: "triangle" });
    }

    function playMergeSound() {
      playTone({ startFreq: 440, endFreq: 660, duration: 0.18, type: "square" });
    }

    function startGame() {
      score = 0;
      hasWon = false;
      tileId = 0;
      overlay.classList.remove("show");
      messageEl.textContent = "";
      emptyGrid();
      const first = addRandomTile();
      const second = addRandomTile();
      history = [];
      future = [];
      updateScores();
      updateUndoRedo();
      renderTiles(
        [first, second].filter(Boolean).map((tile) => ({ id: tile.id, pop: true }))
      );
    }

    function canMove() {
      for (let r = 0; r < size; r += 1) {
        for (let c = 0; c < size; c += 1) {
          const tile = grid[r][c];
          if (!tile) return true;
          if (r < size - 1 && grid[r + 1][c]?.value === tile.value) return true;
          if (c < size - 1 && grid[r][c + 1]?.value === tile.value) return true;
        }
      }
      return false;
    }

    function slide(row) {
      const filtered = row.filter(Boolean);
      const merged = [];
      const merges = [];
      for (let i = 0; i < filtered.length; i += 1) {
        const current = filtered[i];
        const next = filtered[i + 1];
        if (next && current.value === next.value) {
          const newValue = current.value * 2;
          const newTile = { id: current.id, value: newValue };
          merged.push(newTile);
          merges.push(newTile.id);
          score += newValue;
          if (newValue === 2048) hasWon = true;
          i += 1;
        } else {
          merged.push(current);
        }
      }
      while (merged.length < size) {
        merged.push(null);
      }
      return { line: merged, merges };
    }

    function move(direction) {
      if (inputLocked) return;
      const previousState = {
        grid: cloneGridValues(),
        score,
        hasWon
      };
      let moved = false;
      const animations = [];

      function recordAnimation(id, type) {
        animations.push({ id, [type]: true });
      }

      function rowsEqual(a, b) {
        return a.every((tile, index) => {
          const other = b[index];
          if (!tile && !other) return true;
          if (!tile || !other) return false;
          return tile.id === other.id && tile.value === other.value;
        });
      }

      if (direction === "left") {
        for (let r = 0; r < size; r += 1) {
          const current = grid[r];
          const { line, merges } = slide(current);
          if (!rowsEqual(current, line)) {
            moved = true;
            grid[r] = line;
            merges.forEach((id) => recordAnimation(id, "merge"));
          }
        }
      }

      if (direction === "right") {
        for (let r = 0; r < size; r += 1) {
          const current = [...grid[r]].reverse();
          const { line, merges } = slide(current);
          const next = line.reverse();
          const original = grid[r];
          if (!rowsEqual(original, next)) {
            moved = true;
            grid[r] = next;
            merges.forEach((id) => recordAnimation(id, "merge"));
          }
        }
      }

      if (direction === "up") {
        for (let c = 0; c < size; c += 1) {
          const column = grid.map((row) => row[c]);
          const { line, merges } = slide(column);
          if (!rowsEqual(column, line)) {
            moved = true;
            for (let r = 0; r < size; r += 1) {
              grid[r][c] = line[r];
            }
            merges.forEach((id) => recordAnimation(id, "merge"));
          }
        }
      }

      if (direction === "down") {
        for (let c = 0; c < size; c += 1) {
          const column = grid.map((row) => row[c]).reverse();
          const { line, merges } = slide(column);
          const nextColumn = line.reverse();
          if (!rowsEqual(grid.map((row) => row[c]), nextColumn)) {
            moved = true;
            for (let r = 0; r < size; r += 1) {
              grid[r][c] = nextColumn[r];
            }
            merges.forEach((id) => recordAnimation(id, "merge"));
          }
        }
      }

      if (!moved) return;
      pushHistory(previousState);
      inputLocked = true;
      renderTiles(animations);
      playSlideSound();
      if (animations.some((animation) => animation.merge)) {
        playMergeSound();
      }
      updateScores();

      setTimeout(() => {
        const newTile = addRandomTile();
        updateScores();
        renderTiles(newTile ? [{ id: newTile.id, pop: true }] : []);
        inputLocked = false;
        updateUndoRedo();
        if (hasWon) {
          showOverlay("You reached 2048!");
        } else if (!canMove()) {
          showOverlay("Game over!");
        }
      }, 180);
    }

    function showOverlay(text) {
      overlayText.textContent = text;
      overlay.classList.add("show");
    }

    function handleKey(event) {
      if (event.ctrlKey || event.metaKey) {
        const key = event.key.toLowerCase();
        if (key === "z") {
          event.preventDefault();
          if (event.shiftKey) {
            redo();
          } else {
            undo();
          }
          return;
        }
        if (key === "y") {
          event.preventDefault();
          redo();
          return;
        }
      }
      const keyMap = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down"
      };
      const direction = keyMap[event.key];
      if (!direction) return;
      event.preventDefault();
      move(direction);
    }

    function handleTouch() {
      let startX = 0;
      let startY = 0;

      boardEl.addEventListener("touchstart", (event) => {
        const touch = event.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
      });

      boardEl.addEventListener("touchend", (event) => {
        const touch = event.changedTouches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (Math.max(absX, absY) < 30) return;
        if (absX > absY) {
          move(dx > 0 ? "right" : "left");
        } else {
          move(dy > 0 ? "down" : "up");
        }
      });
    }

    function confirmReset() {
      if (confirm("Start a new game? Your current progress will be lost.")) {
        startGame();
      }
    }

    function undo() {
      if (history.length === 0 || inputLocked) return;
      const current = {
        grid: cloneGridValues(),
        score,
        hasWon
      };
      future.push(current);
      const previous = history.pop();
      restoreFromValues(previous.grid);
      score = previous.score;
      hasWon = previous.hasWon;
      overlay.classList.remove("show");
      updateScores();
      renderTiles();
      updateUndoRedo();
    }

    function redo() {
      if (future.length === 0 || inputLocked) return;
      const current = {
        grid: cloneGridValues(),
        score,
        hasWon
      };
      history.push(current);
      const next = future.pop();
      restoreFromValues(next.grid);
      score = next.score;
      hasWon = next.hasWon;
      overlay.classList.remove("show");
      updateScores();
      renderTiles();
      updateUndoRedo();
    }

    setupBoard();
    startGame();
    handleTouch();

    volumeSlider.value = String(soundVolume);
    soundToggleBtn.textContent = soundEnabled ? "Sound: On" : "Sound: Off";
    soundToggleBtn.setAttribute("aria-pressed", String(soundEnabled));

    soundToggleBtn.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      soundToggleBtn.textContent = soundEnabled ? "Sound: On" : "Sound: Off";
      soundToggleBtn.setAttribute("aria-pressed", String(soundEnabled));
      localStorage.setItem("sound-enabled", String(soundEnabled));
      if (soundEnabled) {
        ensureAudioContext();
      }
    });

    volumeSlider.addEventListener("input", () => {
      soundVolume = Number(volumeSlider.value);
      localStorage.setItem("sound-volume", String(soundVolume));
    });

    window.addEventListener("keydown", handleKey);
    newGameBtn.addEventListener("click", confirmReset);
    overlayButton.addEventListener("click", startGame);
    undoBtn.addEventListener("click", undo);
    redoBtn.addEventListener("click", redo);
  </script>
</body>
</html>
