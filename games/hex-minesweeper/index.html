<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Minesweeper</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --panel: #ffffff;
      --text: #1b1f24;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --danger: #dc2626;
      --tile: #d9e2ec;
      --tile-closed: #c9d4e3;
      --tile-open: #f2f6fb;
      --tile-outline: #a8b4c6;
      --highlight: rgba(37, 99, 235, 0.2);
      --flag: #e11d48;
      --mine: #0f172a;
    }

    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .app {
      width: min(980px, 100%);
      display: flex;
      flex-direction: column;
      padding: 12px 14px 18px;
      gap: 10px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      background: var(--panel);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
    }

    .stat {
      display: flex;
      flex-direction: column;
      padding: 6px 10px;
      border-radius: 10px;
      background: #f0f4fa;
      min-width: 88px;
    }

    .stat span {
      font-size: 0.72rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat strong {
      font-size: 1.1rem;
    }

    .controls {
      display: flex;
      flex: 1 1 auto;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: #f0f4fa;
      font-weight: 600;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .toggle input {
      accent-color: var(--accent);
      cursor: pointer;
    }

    .segmented {
      display: inline-flex;
      background: #edf1f7;
      border-radius: 999px;
      padding: 4px;
      gap: 4px;
    }

    .segmented button {
      border: none;
      background: transparent;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 600;
      color: var(--muted);
      cursor: pointer;
      min-width: 72px;
    }

    .segmented button.active {
      background: var(--accent);
      color: #fff;
    }

    button.primary {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 8px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    button.primary:active {
      background: var(--accent-strong);
    }

    button.secondary {
      border: 1px solid #d5dbe6;
      background: #fff;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.82rem;
    }

    select {
      border-radius: 10px;
      border: 1px solid #d5dbe6;
      padding: 8px 10px;
      background: #fff;
      font-weight: 600;
    }

    .status {
      font-weight: 600;
      color: var(--muted);
      min-height: 20px;
    }

    .status.win {
      color: #15803d;
    }

    .status.lose {
      color: var(--danger);
    }

    .canvas-wrap {
      background: var(--panel);
      border-radius: 18px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
      padding: 10px;
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    canvas {
      width: 100%;
      height: min(75vh, 620px);
      display: block;
      border-radius: 12px;
      touch-action: none;
    }

    .footer {
      display: flex;
      justify-content: flex-end;
      padding: 0 6px 2px;
    }

    @media (max-width: 600px) {
      header {
        padding: 8px 10px;
      }

      .stat {
        min-width: 76px;
      }

      .segmented button {
        min-width: 64px;
        padding: 6px 12px;
      }

      canvas {
        height: min(56vh, 520px);
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="stat">
        <span>Timer</span>
        <strong id="timer">0</strong>
      </div>
      <div class="stat">
        <span>Mines</span>
        <strong id="mines">0</strong>
      </div>
      <div class="stat">
        <span>Best</span>
        <strong id="best">--</strong>
      </div>
      <div class="controls">
        <select id="size-select">
          <option value="12x12" selected>Normal 12×12</option>
          <option value="16x16">Hard 16×16</option>
          <option value="20x18">Expert 20×18</option>
          <option value="24x20">Master 24×20</option>
          <option value="28x20">Extreme 28×20</option>
        </select>
        <select id="density-select">
          <option value="0.14">0.14 density</option>
          <option value="0.18" selected>0.18 density</option>
          <option value="0.22">0.22 density</option>
          <option value="0.26">0.26 density</option>
          <option value="0.30">0.30 density</option>
        </select>
        <label class="toggle" for="vibration-toggle">
          <input id="vibration-toggle" type="checkbox" />
          Vibration
        </label>
        <div class="segmented" role="group" aria-label="Mode toggle">
          <button id="mode-open" class="active" type="button">Open</button>
          <button id="mode-flag" type="button">Flag</button>
        </div>
        <button id="restart" class="primary" type="button">Restart</button>
      </div>
    </header>
    <div class="status" id="status"></div>
    <div class="canvas-wrap">
      <canvas id="board" width="800" height="600"></canvas>
      <div class="footer">
        <button id="reset-best" class="secondary" type="button">Reset Best</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const timerEl = document.getElementById('timer');
    const minesEl = document.getElementById('mines');
    const bestEl = document.getElementById('best');
    const statusEl = document.getElementById('status');
    const modeOpenBtn = document.getElementById('mode-open');
    const modeFlagBtn = document.getElementById('mode-flag');
    const restartBtn = document.getElementById('restart');
    const resetBestBtn = document.getElementById('reset-best');
    const sizeSelect = document.getElementById('size-select');
    const densitySelect = document.getElementById('density-select');
    const vibrationToggle = document.getElementById('vibration-toggle');

    const EVEN_COL_DIRS = [
      [1, 0],
      [0, -1],
      [-1, -1],
      [-1, 0],
      [0, 1],
      [1, -1]
    ];

    const ODD_COL_DIRS = [
      [1, 1],
      [1, 0],
      [-1, 0],
      [-1, 1],
      [0, 1],
      [0, -1]
    ];

    let winFx = null;
    const winFxDuration = 2000;

    const VIBRATION_STORAGE_KEY = 'hexMines:vibration';

    const resetBestState = {
      armed: false,
      timeoutId: null,
      defaultLabel: resetBestBtn.textContent
    };

    class Game {
      constructor() {
        this.mode = 'open';
        this.reset(getConfigFromControls());
      }

      reset({ W, H, density }) {
        this.W = W;
        this.H = H;
        this.density = density;
        this.totalMines = Math.max(1, Math.floor(W * H * density));
        this.board = [];
        for (let row = 0; row < H; row++) {
          const rowCells = [];
          for (let col = 0; col < W; col++) {
            rowCells.push({ col, row, isMine: false, number: 0, state: 'closed' });
          }
          this.board.push(rowCells);
        }
        this.started = false;
        this.gameOver = false;
        this.win = false;
        this.flags = 0;
        this.firstCell = null;
        this.startTime = null;
        this.elapsed = 0;
        this.timerId = null;
        this.highlight = null;
        winFx = null;
        if (game) updateUI();
      }

      cell(col, row) {
        if (col < 0 || col >= this.W || row < 0 || row >= this.H) return null;
        return this.board[row][col];
      }

      neighbors(col, row) {
        const dirs = col % 2 === 0 ? EVEN_COL_DIRS : ODD_COL_DIRS;
        return dirs.map(([dc, dr]) => this.cell(col + dc, row + dr)).filter(Boolean);
      }

      placeMinesSafe(startCell) {
        const forbidden = new Set();
        forbidden.add(`${startCell.col},${startCell.row}`);
        this.neighbors(startCell.col, startCell.row).forEach(cell => {
          forbidden.add(`${cell.col},${cell.row}`);
        });
        const candidates = [];
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const key = `${col},${row}`;
            if (!forbidden.has(key)) {
              candidates.push(this.board[row][col]);
            }
          }
        }
        const minesToPlace = Math.min(this.totalMines, candidates.length);
        shuffle(candidates);
        for (let i = 0; i < minesToPlace; i++) {
          candidates[i].isMine = true;
        }
        this.totalMines = minesToPlace;
        this.computeNumbers();
      }

      computeNumbers() {
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (cell.isMine) {
              cell.number = 0;
            } else {
              cell.number = this.neighbors(col, row).filter(n => n.isMine).length;
            }
          }
        }
      }

      toggleFlag(cell) {
        if (this.gameOver || cell.state === 'open') return;
        let changed = false;
        if (cell.state === 'flag') {
          cell.state = 'closed';
          this.flags = Math.max(0, this.flags - 1);
          changed = true;
        } else if (cell.state === 'closed') {
          cell.state = 'flag';
          this.flags += 1;
          changed = true;
        }
        if (changed) {
          maybeVibrate([12, 40, 12]);
        }
        updateUI();
      }

      openCell(cell) {
        if (this.gameOver || cell.state !== 'closed') return;
        maybeVibrate([8, 20, 8]);
        if (!this.started) {
          this.started = true;
          this.firstCell = cell;
          this.placeMinesSafe(cell);
          this.startTimer();
        }
        if (cell.isMine) {
          cell.state = 'open';
          this.gameOver = true;
          this.revealMines();
          this.stopTimer();
          updateUI();
          return;
        }
        this.floodOpen(cell);
        this.checkWin();
      }

      floodOpen(startCell) {
        const queue = [startCell];
        while (queue.length) {
          const cell = queue.shift();
          if (cell.state !== 'closed') continue;
          cell.state = 'open';
          if (cell.number === 0) {
            this.neighbors(cell.col, cell.row).forEach(n => {
              if (n.state === 'closed') {
                queue.push(n);
              }
            });
          }
        }
      }

      revealMines() {
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (cell.isMine) {
              cell.state = 'open';
            }
          }
        }
      }

      checkWin() {
        let openCount = 0;
        let safeCount = 0;
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (!cell.isMine) safeCount++;
            if (cell.state === 'open' && !cell.isMine) openCount++;
          }
        }
        if (openCount === safeCount && !this.gameOver) {
          this.gameOver = true;
          this.win = true;
          this.stopTimer();
          maybeUpdateBestTime(this.elapsed);
          startWinFx();
          updateUI();
        }
      }

      startTimer() {
        this.startTime = performance.now();
        this.timerId = setInterval(() => {
          this.elapsed = Math.floor((performance.now() - this.startTime) / 1000);
          timerEl.textContent = this.elapsed;
        }, 250);
      }

      stopTimer() {
        if (this.timerId) {
          clearInterval(this.timerId);
          this.timerId = null;
        }
      }
    }

    let game = null;
    game = new Game();

    const renderer = {
      size: 24,
      originX: 0,
      originY: 0,
      hoverCell: null,
      needsRender: true
    };

    const camera = {
      scale: 1,
      tx: 0,
      ty: 0
    };

    const pointerState = {
      pointers: new Map(),
      gestureActive: false,
      gesturePointerIds: new Set(),
      startDist: 0,
      startScale: 1,
      startMid: { x: 0, y: 0 },
      worldMidStart: { x: 0, y: 0 },
      startTx: 0,
      startTy: 0,
      suppressTap: false,
      startPoints: new Map(),
      lastTapTime: 0,
      lastTapPos: null
    };

    function getConfigFromControls() {
      const [W, H] = sizeSelect.value.split('x').map(Number);
      const density = parseFloat(densitySelect.value);
      return { W, H, density };
    }

    function configKey({ W, H, density }) {
      return `${W}x${H}_${density.toFixed(3)}`;
    }

    function storageKey(config) {
      return `hexMinesBest:${configKey(config)}`;
    }

    function getBestTime(config) {
      const stored = localStorage.getItem(storageKey(config));
      if (!stored) return null;
      const value = Number.parseInt(stored, 10);
      return Number.isFinite(value) ? value : null;
    }

    function setBestTime(config, value) {
      localStorage.setItem(storageKey(config), value.toString());
    }

    function getVibrationEnabled() {
      const stored = localStorage.getItem(VIBRATION_STORAGE_KEY);
      if (stored === null) return true;
      return stored === '1';
    }

    function setVibrationEnabled(isEnabled) {
      localStorage.setItem(VIBRATION_STORAGE_KEY, isEnabled ? '1' : '0');
    }

    function maybeVibrate(pattern) {
      if (!vibrationToggle.checked) return;
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
      }
    }

    function maybeUpdateBestTime(elapsed) {
      const config = { W: game.W, H: game.H, density: game.density };
      const best = getBestTime(config);
      if (best === null || elapsed < best) {
        setBestTime(config, elapsed);
      }
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * devicePixelRatio);
      canvas.height = Math.floor(rect.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      fitBoard();
      requestRender();
    }

    function fitBoard() {
      const padding = 16;
      const cw = canvas.clientWidth;
      const ch = canvas.clientHeight;

      const usableW = Math.max(0, cw - padding * 2);
      const usableH = Math.max(0, ch - padding * 2);

      const widthCoeff = 1.5 * (game.W - 1) + 2;
      const heightCoeff = Math.sqrt(3) * (game.H + 0.5);

      const sizeX = usableW / widthCoeff;
      const sizeY = usableH / heightCoeff;

      renderer.size = Math.max(4, Math.min(sizeX, sizeY));

      const stepX = 1.5 * renderer.size;
      const stepY = Math.sqrt(3) * renderer.size;
      const totalW = stepX * (game.W - 1) + 2 * renderer.size;
      const totalH = stepY * (game.H + 0.5);

      renderer.originX = padding + (usableW - totalW) / 2 + renderer.size;
      renderer.originY = padding + (usableH - totalH) / 2 + renderer.size;

      camera.scale = 1;
      camera.tx = 0;
      camera.ty = 0;
    }

    function offsetToPixel(col, row) {
      const stepX = 1.5 * renderer.size;
      const stepY = Math.sqrt(3) * renderer.size;
      const x = renderer.originX + stepX * col;
      const y = renderer.originY + stepY * (row + 0.5 * (col % 2));
      return { x, y };
    }

    function pixelToCell(x, y) {
      const stepX = 1.5 * renderer.size;
      const stepY = Math.sqrt(3) * renderer.size;
      const approxCol = Math.round((x - renderer.originX) / stepX);
      const col = Math.max(0, Math.min(game.W - 1, approxCol));
      const approxRow = Math.round((y - renderer.originY) / stepY - 0.5 * (col % 2));
      let best = null;
      let bestDist = Infinity;
      for (let r = approxRow - 1; r <= approxRow + 1; r++) {
        for (let c = approxCol - 1; c <= approxCol + 1; c++) {
          const cell = game.cell(c, r);
          if (!cell) continue;
          const center = offsetToPixel(c, r);
          const dx = x - center.x;
          const dy = y - center.y;
          const dist = dx * dx + dy * dy;
          if (dist < bestDist) {
            bestDist = dist;
            best = { col: c, row: r };
          }
        }
      }
      return best;
    }

    function drawHex(x, y, size, fillStyle, strokeStyle, lineWidth = 1) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i - 30);
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }

    function drawFlag(x, y, size, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = Math.max(2, size * 0.12);
      ctx.beginPath();
      ctx.moveTo(x - size * 0.1, y + size * 0.35);
      ctx.lineTo(x - size * 0.1, y - size * 0.45);
      ctx.stroke();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--flag');
      ctx.beginPath();
      ctx.moveTo(x - size * 0.1, y - size * 0.45);
      ctx.lineTo(x + size * 0.55, y - size * 0.25);
      ctx.lineTo(x - size * 0.1, y - size * 0.05);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawMine(x, y, size) {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mine');
      ctx.beginPath();
      ctx.arc(x, y, size * 0.35, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = size * 0.08;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = Math.PI / 4 * i;
        const inner = size * 0.5;
        const outer = size * 0.75;
        ctx.moveTo(x + inner * Math.cos(angle), y + inner * Math.sin(angle));
        ctx.lineTo(x + outer * Math.cos(angle), y + outer * Math.sin(angle));
      }
      ctx.stroke();
    }

    function drawNumber(x, y, number) {
      const colors = {
        1: '#2563eb',
        2: '#16a34a',
        3: '#dc2626',
        4: '#7c3aed',
        5: '#b45309',
        6: '#0f172a'
      };
      ctx.fillStyle = colors[number] || '#334155';
      ctx.font = `600 ${renderer.size * 0.85}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(number.toString(), x, y + 1);
    }

    function startWinFx() {
      const centerX = canvas.clientWidth / 2;
      const centerY = canvas.clientHeight / 2;
      const colors = ['#2563eb', '#16a34a', '#dc2626', '#f59e0b', '#7c3aed', '#0ea5e9'];
      const particles = Array.from({ length: 42 }, () => {
        const angle = Math.random() * Math.PI * 2;
        const speed = 80 + Math.random() * 140;
        return {
          x: centerX,
          y: centerY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 40,
          size: 4 + Math.random() * 4,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * Math.PI
        };
      });
      winFx = { start: performance.now(), particles };
      requestRender();
    }

    function renderWinFx() {
      if (!winFx) return;
      const now = performance.now();
      const elapsed = (now - winFx.start) / 1000;
      const duration = winFxDuration / 1000;
      if (elapsed > duration) {
        winFx = null;
        return;
      }
      const progress = elapsed / duration;
      const alpha = Math.max(0, 1 - progress);
      const centerX = canvas.clientWidth / 2;
      const centerY = canvas.clientHeight / 2;
      const popPhase = Math.min(progress / 0.25, 1);
      const popScale = 1 + Math.sin(popPhase * Math.PI) * 0.2;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#15803d';
      ctx.font = `700 ${48 * popScale}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(15, 23, 42, 0.15)';
      ctx.shadowBlur = 12;
      ctx.fillText('CLEAR!', centerX, centerY - 10);
      ctx.restore();

      const gravity = 140;
      winFx.particles.forEach(p => {
        const px = p.x + p.vx * elapsed;
        const py = p.y + p.vy * elapsed + 0.5 * gravity * elapsed * elapsed;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(px, py);
        ctx.rotate(p.rotation + elapsed * 3);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 1.4);
        ctx.restore();
      });

      ctx.save();
      ctx.globalAlpha = alpha * 0.6;
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;
      const ringRadius = 40 + 120 * progress;
      ctx.beginPath();
      ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function render() {
      if (!renderer.needsRender) return;
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      ctx.save();
      ctx.translate(camera.tx, camera.ty);
      ctx.scale(camera.scale, camera.scale);
      for (let row = 0; row < game.H; row++) {
        for (let col = 0; col < game.W; col++) {
          const cell = game.cell(col, row);
          const { x, y } = offsetToPixel(col, row);
          const isHover = renderer.hoverCell && renderer.hoverCell.col === col && renderer.hoverCell.row === row;
          const fill = cell.state === 'open' ? getCss('--tile-open') : getCss('--tile-closed');
          const stroke = getCss('--tile-outline');
          drawHex(x, y, renderer.size * 0.95, fill, stroke, 1);
          if (isHover && !game.gameOver) {
            ctx.save();
            ctx.globalAlpha = 0.9;
            drawHex(x, y, renderer.size * 0.98, getCss('--highlight'), 'transparent', 0);
            ctx.restore();
          }
          if (cell.state === 'open') {
            if (cell.isMine && game.gameOver) {
              drawMine(x, y, renderer.size);
            } else if (cell.number > 0) {
              drawNumber(x, y, cell.number);
            }
          } else if (cell.state === 'flag') {
            drawFlag(x, y, renderer.size);
          } else if (
            isHover &&
            game.mode === 'flag' &&
            cell.state === 'closed' &&
            !game.gameOver
          ) {
            drawFlag(x, y, renderer.size, 0.35);
          }
        }
      }
      ctx.restore();
      renderWinFx();
      renderer.needsRender = false;
    }

    function getCss(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function requestRender() {
      renderer.needsRender = true;
    }

    function loop() {
      if (winFx && performance.now() - winFx.start < winFxDuration) {
        requestRender();
      }
      render();
      requestAnimationFrame(loop);
    }

    function updateUI() {
      const config = { W: game.W, H: game.H, density: game.density };
      const best = getBestTime(config);
      minesEl.textContent = Math.max(0, game.totalMines - game.flags).toString();
      timerEl.textContent = game.elapsed.toString();
      bestEl.textContent = best === null ? '--' : best.toString();
      if (game.gameOver) {
        if (game.win) {
          statusEl.textContent = 'You cleared the field!';
          statusEl.className = 'status win';
        } else {
          statusEl.textContent = 'Boom! Tap restart to try again.';
          statusEl.className = 'status lose';
        }
      } else {
        statusEl.textContent = 'Stay sharp. Clear all safe tiles.';
        statusEl.className = 'status';
      }
      requestRender();
    }

    function setMode(mode) {
      game.mode = mode;
      modeOpenBtn.classList.toggle('active', mode === 'open');
      modeFlagBtn.classList.toggle('active', mode === 'flag');
      requestRender();
    }

    function handleAction(cell, actionMode) {
      if (!cell) return;
      if (game.gameOver) return;
      if (actionMode === 'flag') {
        game.toggleFlag(cell);
      } else {
        game.openCell(cell);
      }
      updateUI();
    }

    function getCanvasPoint(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }

    function pointerToCell(event) {
      const point = getCanvasPoint(event);
      const wx = (point.x - camera.tx) / camera.scale;
      const wy = (point.y - camera.ty) / camera.scale;
      const hit = pixelToCell(wx, wy);
      if (!hit) return null;
      return game.cell(hit.col, hit.row);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function startGesture() {
      if (pointerState.pointers.size < 2) return;
      const entries = Array.from(pointerState.pointers.entries()).slice(0, 2);
      const [aId, a] = entries[0];
      const [bId, b] = entries[1];
      pointerState.gestureActive = true;
      pointerState.gesturePointerIds = new Set([aId, bId]);
      pointerState.startDist = Math.hypot(a.x - b.x, a.y - b.y) || 1;
      pointerState.startScale = camera.scale;
      pointerState.startMid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      pointerState.worldMidStart = {
        x: (pointerState.startMid.x - camera.tx) / camera.scale,
        y: (pointerState.startMid.y - camera.ty) / camera.scale
      };
      pointerState.startTx = camera.tx;
      pointerState.startTy = camera.ty;
    }

    function updateGesture() {
      if (!pointerState.gestureActive || pointerState.pointers.size < 2) return;
      const entries = Array.from(pointerState.pointers.entries()).filter(([id]) =>
        pointerState.gesturePointerIds.has(id)
      );
      if (entries.length < 2) return;
      const a = entries[0][1];
      const b = entries[1][1];
      const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      const dist = Math.hypot(a.x - b.x, a.y - b.y) || 1;
      const scaleNew = clamp(pointerState.startScale * (dist / pointerState.startDist), 0.6, 3);
      camera.scale = scaleNew;
      camera.tx = mid.x - pointerState.worldMidStart.x * camera.scale;
      camera.ty = mid.y - pointerState.worldMidStart.y * camera.scale;
      if (Math.hypot(mid.x - pointerState.startMid.x, mid.y - pointerState.startMid.y) > 6) {
        pointerState.suppressTap = true;
      }
      requestRender();
    }

    function endGestureIfNeeded() {
      if (pointerState.pointers.size < 2) {
        pointerState.gestureActive = false;
        pointerState.gesturePointerIds.clear();
      }
    }

    function handleDoubleTap(point, event) {
      if (event.pointerType === 'mouse') return false;
      const now = performance.now();
      if (pointerState.lastTapTime && now - pointerState.lastTapTime < 300) {
        const prev = pointerState.lastTapPos;
        if (prev) {
          const dist = Math.hypot(point.x - prev.x, point.y - prev.y);
          if (dist < 24) {
            fitBoard();
            requestRender();
            pointerState.lastTapTime = 0;
            pointerState.lastTapPos = null;
            return true;
          }
        }
      }
      pointerState.lastTapTime = now;
      pointerState.lastTapPos = point;
      return false;
    }

    canvas.addEventListener('pointerdown', event => {
      if (event.pointerType === 'mouse' && event.button === 2) return;
      canvas.setPointerCapture(event.pointerId);
      const point = getCanvasPoint(event);
      if (pointerState.pointers.size === 0) {
        pointerState.suppressTap = false;
        pointerState.startPoints.clear();
      }
      pointerState.pointers.set(event.pointerId, { x: point.x, y: point.y });
      pointerState.startPoints.set(event.pointerId, { x: point.x, y: point.y });
      if (pointerState.pointers.size === 2) {
        pointerState.suppressTap = true;
        startGesture();
      }
      if (!pointerState.gestureActive) {
        const cell = pointerToCell(event);
        renderer.hoverCell = cell;
        requestRender();
      }
    });

    canvas.addEventListener('pointermove', event => {
      const point = getCanvasPoint(event);
      if (pointerState.pointers.has(event.pointerId)) {
        pointerState.pointers.set(event.pointerId, { x: point.x, y: point.y });
        const startPoint = pointerState.startPoints.get(event.pointerId);
        if (startPoint) {
          const moved = Math.hypot(point.x - startPoint.x, point.y - startPoint.y);
          if (moved > 6) {
            pointerState.suppressTap = true;
          }
        }
      }
      if (pointerState.gestureActive) {
        updateGesture();
        return;
      }
      const cell = pointerToCell(event);
      if (
        renderer.hoverCell &&
        cell &&
        renderer.hoverCell.col === cell.col &&
        renderer.hoverCell.row === cell.row
      ) {
        return;
      }
      renderer.hoverCell = cell;
      requestRender();
    });

    canvas.addEventListener('pointerleave', () => {
      renderer.hoverCell = null;
      requestRender();
    });

    canvas.addEventListener('pointerup', event => {
      const point = getCanvasPoint(event);
      const wasGesturePointer = pointerState.gesturePointerIds.has(event.pointerId);
      pointerState.pointers.delete(event.pointerId);
      pointerState.startPoints.delete(event.pointerId);
      if (pointerState.gestureActive) {
        endGestureIfNeeded();
        if (wasGesturePointer) {
          return;
        }
      }
      if (pointerState.suppressTap) {
        if (pointerState.pointers.size === 0) {
          pointerState.suppressTap = false;
          pointerState.startPoints.clear();
        }
        return;
      }
      const cell = pointerToCell(event);
      renderer.hoverCell = cell;
      if (event.pointerType === 'mouse' && event.button === 2) {
        handleAction(cell, 'flag');
      } else {
        handleAction(cell, game.mode);
      }
      if (handleDoubleTap(point, event)) {
        renderer.hoverCell = null;
      }
      requestRender();
    });

    canvas.addEventListener('pointercancel', event => {
      pointerState.pointers.delete(event.pointerId);
      pointerState.startPoints.delete(event.pointerId);
      endGestureIfNeeded();
    });

    canvas.addEventListener('contextmenu', event => {
      event.preventDefault();
    });

    modeOpenBtn.addEventListener('click', () => setMode('open'));
    modeFlagBtn.addEventListener('click', () => setMode('flag'));

    restartBtn.addEventListener('click', () => {
      resetResetBestPrompt();
      game.stopTimer();
      game.reset(getConfigFromControls());
      setMode('open');
      resizeCanvas();
    });

    resetBestBtn.addEventListener('click', () => {
      if (resetBestState.armed) {
        const config = getConfigFromControls();
        localStorage.removeItem(storageKey(config));
        resetResetBestPrompt();
        updateUI();
        return;
      }
      resetBestState.armed = true;
      resetBestBtn.textContent = 'Tap again to confirm';
      if (resetBestState.timeoutId) {
        clearTimeout(resetBestState.timeoutId);
      }
      resetBestState.timeoutId = setTimeout(() => {
        resetResetBestPrompt();
      }, 3000);
    });

    function handleConfigChange() {
      resetResetBestPrompt();
      game.stopTimer();
      game.reset(getConfigFromControls());
      setMode('open');
      resizeCanvas();
    }

    sizeSelect.addEventListener('change', handleConfigChange);
    densitySelect.addEventListener('change', handleConfigChange);
    vibrationToggle.checked = getVibrationEnabled();
    vibrationToggle.addEventListener('change', () => {
      setVibrationEnabled(vibrationToggle.checked);
    });

    window.addEventListener('resize', resizeCanvas);

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function resetResetBestPrompt() {
      resetBestState.armed = false;
      resetBestBtn.textContent = resetBestState.defaultLabel;
      if (resetBestState.timeoutId) {
        clearTimeout(resetBestState.timeoutId);
        resetBestState.timeoutId = null;
      }
    }

    resizeCanvas();
    updateUI();
    loop();
  </script>
</body>
</html>
