<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Minesweeper</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --panel: #ffffff;
      --text: #1b1f24;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --danger: #dc2626;
      --tile: #d9e2ec;
      --tile-closed: #c9d4e3;
      --tile-open: #f2f6fb;
      --tile-outline: #a8b4c6;
      --highlight: rgba(37, 99, 235, 0.2);
      --flag: #e11d48;
      --mine: #0f172a;
    }

    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .app {
      width: min(980px, 100%);
      display: flex;
      flex-direction: column;
      padding: 12px 14px 18px;
      gap: 10px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      background: var(--panel);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
    }

    .stat {
      display: flex;
      flex-direction: column;
      padding: 6px 10px;
      border-radius: 10px;
      background: #f0f4fa;
      min-width: 88px;
    }

    .stat span {
      font-size: 0.72rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat strong {
      font-size: 1.1rem;
    }

    .controls {
      display: flex;
      flex: 1 1 auto;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: #f0f4fa;
      font-weight: 600;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .toggle input {
      accent-color: var(--accent);
      cursor: pointer;
    }

    .volume {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      background: #f0f4fa;
      color: var(--muted);
      font-weight: 600;
    }

    .volume input[type="range"] {
      width: 120px;
      accent-color: var(--accent);
    }

    .volume small {
      min-width: 44px;
      text-align: right;
      color: var(--muted);
      font-weight: 700;
    }

    .segmented {
      display: inline-flex;
      background: #edf1f7;
      border-radius: 999px;
      padding: 4px;
      gap: 4px;
    }

    .segmented button {
      border: none;
      background: transparent;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 600;
      color: var(--muted);
      cursor: pointer;
      min-width: 72px;
    }

    .segmented button.active {
      background: var(--accent);
      color: #fff;
    }

    button.primary {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 8px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    button.primary:active {
      background: var(--accent-strong);
    }

    button.secondary {
      border: 1px solid #d5dbe6;
      background: #fff;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.82rem;
    }

    select {
      border-radius: 10px;
      border: 1px solid #d5dbe6;
      padding: 8px 10px;
      background: #fff;
      font-weight: 600;
    }

    .status {
      font-weight: 600;
      color: var(--muted);
      min-height: 20px;
    }

    .status.win {
      color: #15803d;
    }

    .status.lose {
      color: var(--danger);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .canvas-wrap {
      background: var(--panel);
      border-radius: 18px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
      padding: 10px;
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    canvas {
      width: 100%;
      height: min(75vh, 620px);
      display: block;
      border-radius: 12px;
      touch-action: none;
    }

    .footer {
      display: flex;
      justify-content: flex-end;
      padding: 0 6px 2px;
    }

    @media (max-width: 600px) {
      header {
        padding: 8px 10px;
      }

      .stat {
        min-width: 76px;
      }

      .segmented button {
        min-width: 64px;
        padding: 6px 12px;
      }

      canvas {
        height: min(56vh, 520px);
      }

      .volume input[type="range"] {
        width: 96px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="stat">
        <span>Timer</span>
        <strong id="timer">0</strong>
      </div>
      <div class="stat">
        <span>Mines</span>
        <strong id="mines">0</strong>
      </div>
      <div class="stat">
        <span>Best</span>
        <strong id="best">--</strong>
      </div>
      <div class="controls">
        <select id="size-select">
          <option value="12x12" selected>Normal 12×12</option>
          <option value="16x16">Hard 16×16</option>
          <option value="20x18">Expert 20×18</option>
          <option value="24x20">Master 24×20</option>
          <option value="28x20">Extreme 28×20</option>
        </select>
        <select id="density-select">
          <option value="0.14">0.14 density</option>
          <option value="0.18" selected>0.18 density</option>
          <option value="0.22">0.22 density</option>
          <option value="0.26">0.26 density</option>
          <option value="0.30">0.30 density</option>
        </select>

        <label class="toggle" for="vibration-toggle">
          <input id="vibration-toggle" type="checkbox" />
          Vibration
        </label>

        <label class="toggle" for="sound-toggle">
          <input id="sound-toggle" type="checkbox" />
          Sound
        </label>

        <label class="toggle" for="solvable-toggle">
          <input id="solvable-toggle" type="checkbox" />
          Solvable
        </label>

        <div class="volume" title="Sound volume">
          <span>Vol</span>
          <input id="volume-slider" type="range" min="0" max="100" step="1" />
          <small id="volume-label">100%</small>
        </div>

        <div class="segmented" role="group" aria-label="Mode toggle">
          <button id="mode-open" class="active" type="button">Open</button>
          <button id="mode-flag" type="button">Flag</button>
        </div>
        <button id="restart" class="primary" type="button">Restart</button>
      </div>
    </header>

    <div class="status" id="status" aria-live="polite"></div>
    <div id="a11y-live" class="sr-only" aria-live="polite"></div>

    <div class="canvas-wrap">
      <canvas id="board" width="800" height="600" tabindex="0" aria-label="Hex Minesweeper board. Arrow keys move. Enter opens. F toggles flag. R restarts. M toggles mode. Double-tap resets view on touch."></canvas>
      <div class="footer">
        <button id="reset-best" class="secondary" type="button">Reset Best</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    const timerEl = document.getElementById('timer');
    const minesEl = document.getElementById('mines');
    const bestEl = document.getElementById('best');
    const statusEl = document.getElementById('status');

    const modeOpenBtn = document.getElementById('mode-open');
    const modeFlagBtn = document.getElementById('mode-flag');

    const restartBtn = document.getElementById('restart');
    const resetBestBtn = document.getElementById('reset-best');

    const sizeSelect = document.getElementById('size-select');
    const densitySelect = document.getElementById('density-select');

    const vibrationToggle = document.getElementById('vibration-toggle');
    const soundToggle = document.getElementById('sound-toggle');
    const solvableToggle = document.getElementById('solvable-toggle');

    const volumeSlider = document.getElementById('volume-slider');
    const volumeLabel = document.getElementById('volume-label');

    const a11yLiveEl = document.getElementById('a11y-live');

    const EVEN_COL_DIRS = [
      [1, 0],
      [0, -1],
      [-1, -1],
      [-1, 0],
      [0, 1],
      [1, -1]
    ];

    const ODD_COL_DIRS = [
      [1, 1],
      [1, 0],
      [-1, 0],
      [-1, 1],
      [0, 1],
      [0, -1]
    ];

    let winFx = null;
    const winFxDuration = 2000;

    let boomFx = null;
    const boomFxDuration = 900;

    let chordFailFx = null;
    const chordFailDuration = 180;

    const VIBRATION_STORAGE_KEY = 'hexMines:vibration';
    const SOUND_STORAGE_KEY = 'hexMines:sound';
    const VOLUME_STORAGE_KEY = 'hexMines:volume';
    const SOLVABLE_STORAGE_KEY = 'hexMines:solvable';
    const LONG_PRESS_MS = 420;
    const LONG_PRESS_MOVE_PX = 10;

    let audioContext = null;
    let audioUnlocked = false;

    const resetBestState = {
      armed: false,
      timeoutId: null,
      defaultLabel: resetBestBtn.textContent
    };

    class Game {
      constructor() {
        this.mode = 'open';
        this.triggeredMine = null;
        this.reset(getConfigFromControls());
      }

      reset({ W, H, density }) {
        this.W = W;
        this.H = H;
        this.density = density;
        this.totalMines = Math.max(1, Math.floor(W * H * density));
        this.board = [];
        for (let row = 0; row < H; row++) {
          const rowCells = [];
          for (let col = 0; col < W; col++) {
            rowCells.push({ col, row, isMine: false, number: 0, state: 'closed', wrongFlag: false });
          }
          this.board.push(rowCells);
        }
        this.started = false;
        this.gameOver = false;
        this.win = false;
        this.flags = 0;
        this.firstCell = null;
        this.startTime = null;
        this.elapsed = 0;
        this.timerId = null;
        this.highlight = null;
        this.triggeredMine = null;
        winFx = null;
        boomFx = null;
        chordFailFx = null;
        if (game) updateUI();
      }

      cell(col, row) {
        if (col < 0 || col >= this.W || row < 0 || row >= this.H) return null;
        return this.board[row][col];
      }

      neighbors(col, row) {
        const dirs = col % 2 === 0 ? EVEN_COL_DIRS : ODD_COL_DIRS;
        return dirs.map(([dc, dr]) => this.cell(col + dc, row + dr)).filter(Boolean);
      }

      placeMinesSafe(startCell) {
        const forbidden = new Set();
        forbidden.add(`${startCell.col},${startCell.row}`);
        this.neighbors(startCell.col, startCell.row).forEach(cell => {
          forbidden.add(`${cell.col},${cell.row}`);
        });

        const candidates = [];
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const key = `${col},${row}`;
            if (!forbidden.has(key)) {
              candidates.push(this.board[row][col]);
            }
          }
        }

        const minesToPlace = Math.min(this.totalMines, candidates.length);
        const maxAttempts = solvableToggle.checked ? 30 : 1;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          for (let row = 0; row < this.H; row++) {
            for (let col = 0; col < this.W; col++) {
              this.board[row][col].isMine = false;
            }
          }
          shuffle(candidates);
          for (let i = 0; i < minesToPlace; i++) {
            candidates[i].isMine = true;
          }
          this.totalMines = minesToPlace;
          this.computeNumbers();
          if (!solvableToggle.checked || isSolvableByLogic(this, startCell)) {
            break;
          }
        }
      }

      computeNumbers() {
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (cell.isMine) cell.number = 0;
            else cell.number = this.neighbors(col, row).filter(n => n.isMine).length;
          }
        }
      }

      toggleFlag(cell) {
        if (this.gameOver || cell.state === 'open') return;

        let changed = false;
        if (cell.state === 'flag') {
          cell.state = 'closed';
          this.flags = Math.max(0, this.flags - 1);
          changed = true;
        } else if (cell.state === 'closed') {
          cell.state = 'flag';
          this.flags += 1;
          changed = true;
        }

        if (changed) {
          vibrateFlag();
          playFlag();
          // p1: a11y detail
          announceCellAction(cell, cell.state === 'flag' ? 'Flag set' : 'Flag removed');
        }
        updateUI();
      }

      openCell(cell, options = {}) {
        if (this.gameOver || cell.state !== 'closed') return;

        if (!this.started) {
          this.started = true;
          this.firstCell = cell;
          this.placeMinesSafe(cell);
          this.startTimer();
        }

        if (cell.isMine) {
          cell.state = 'open';
          this.gameOver = true;
          this.triggeredMine = { col: cell.col, row: cell.row };
          this.revealMines();
          this.markWrongFlags();
          this.stopTimer();

          startBoomFx(cell.col, cell.row);

          vibrateBoom();
          playBoom();
          // p1: a11y detail
          announceCellAction(cell, 'Boom. Mine');

          updateUI();
          return;
        }

        if (!options.silent) {
          vibrateOpen();
          playOpen();
        }

        this.floodOpen(cell);

        // p1: a11y detail (what opened)
        if (!options.silent) {
          announceCellAction(cell, cell.number > 0 ? `Opened. ${cell.number} nearby` : 'Opened. Empty');
        }

        this.checkWin();
      }

      chord(cell) {
        if (this.gameOver) return { openedCount: 0, flagMatch: false };
        if (cell.state !== 'open' || cell.number <= 0) return { openedCount: 0, flagMatch: false };

        const neighbors = this.neighbors(cell.col, cell.row);
        const flagCount = neighbors.filter(n => n.state === 'flag').length;
        if (flagCount !== cell.number) {
          return { openedCount: 0, flagMatch: false };
        }

        let openedCount = 0;
        for (const n of neighbors) {
          if (n.state === 'closed') {
            openedCount += 1;
            this.openCell(n, { silent: true });
            if (this.gameOver) break;
          }
        }

        return { openedCount, flagMatch: true };
      }

      floodOpen(startCell) {
        const queue = [startCell];
        while (queue.length) {
          const cell = queue.shift();
          if (cell.state !== 'closed') continue;

          cell.state = 'open';
          if (cell.number === 0) {
            this.neighbors(cell.col, cell.row).forEach(n => {
              if (n.state === 'closed') queue.push(n);
            });
          }
        }
      }

      revealMines() {
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (cell.isMine) cell.state = 'open';
          }
        }
      }

      markWrongFlags() {
        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (cell.state === 'flag' && !cell.isMine) {
              cell.wrongFlag = true;
            }
          }
        }
      }

      checkWin() {
        let openCount = 0;
        let safeCount = 0;

        for (let row = 0; row < this.H; row++) {
          for (let col = 0; col < this.W; col++) {
            const cell = this.board[row][col];
            if (!cell.isMine) safeCount++;
            if (cell.state === 'open' && !cell.isMine) openCount++;
          }
        }

        if (openCount === safeCount && !this.gameOver) {
          this.gameOver = true;
          this.win = true;
          this.stopTimer();
          maybeUpdateBestTime(this.elapsed);
          startWinFx();
          vibrateClear();
          playClear();
          announceMessage('Clear. You win.');
          updateUI();
        }
      }

      startTimer() {
        this.startTime = performance.now();
        this.timerId = setInterval(() => {
          this.elapsed = Math.floor((performance.now() - this.startTime) / 1000);
          timerEl.textContent = this.elapsed;
        }, 250);
      }

      stopTimer() {
        if (this.timerId) {
          clearInterval(this.timerId);
          this.timerId = null;
        }
      }
    }

    let game = null;
    game = new Game();

    const renderer = {
      size: 24,
      originX: 0,
      originY: 0,
      hoverCell: null,
      pressPreviewCell: null,
      keyboardCell: null,
      needsRender: true
    };

    const camera = {
      scale: 1,
      tx: 0,
      ty: 0
    };

    const pointerState = {
      pointers: new Map(),
      gestureActive: false,
      gesturePointerIds: new Set(),
      startDist: 0,
      startScale: 1,
      startMid: { x: 0, y: 0 },
      worldMidStart: { x: 0, y: 0 },
      startTx: 0,
      startTy: 0,
      suppressTap: false,
      startPoints: new Map(),
      pressPreviewId: null,
      lastTapTime: 0,
      lastTapPos: null,
      longPressTimerId: null,
      longPressPointerId: null,
      longPressStart: null,
      longPressCell: null,
      longPressTriggered: false
    };

    let longPressFx = null;
    let isKeyboardActive = false;

    let lastCanvasCssW = 0;
    let lastCanvasCssH = 0;
    let lastDpr = 0;

    function getConfigFromControls() {
      const [W, H] = sizeSelect.value.split('x').map(Number);
      const density = parseFloat(densitySelect.value);
      return { W, H, density };
    }

    function configKey({ W, H, density }) {
      return `${W}x${H}_${density.toFixed(3)}`;
    }

    function storageKey(config) {
      return `hexMinesBest:${configKey(config)}`;
    }

    function getBestTime(config) {
      const stored = localStorage.getItem(storageKey(config));
      if (!stored) return null;
      const value = Number.parseInt(stored, 10);
      return Number.isFinite(value) ? value : null;
    }

    function setBestTime(config, value) {
      localStorage.setItem(storageKey(config), value.toString());
    }

    function maybeUpdateBestTime(elapsed) {
      const config = { W: game.W, H: game.H, density: game.density };
      const best = getBestTime(config);
      if (best === null || elapsed < best) setBestTime(config, elapsed);
    }

    function getVibrationEnabled() {
      const stored = localStorage.getItem(VIBRATION_STORAGE_KEY);
      if (stored === null) return true;
      return stored === '1';
    }

    function setVibrationEnabled(isEnabled) {
      localStorage.setItem(VIBRATION_STORAGE_KEY, isEnabled ? '1' : '0');
    }

    function getSoundEnabled() {
      const stored = localStorage.getItem(SOUND_STORAGE_KEY);
      if (stored === null) return true;
      return stored === '1';
    }

    function setSoundEnabled(isEnabled) {
      localStorage.setItem(SOUND_STORAGE_KEY, isEnabled ? '1' : '0');
    }

    function getSolvableEnabled() {
      const stored = localStorage.getItem(SOLVABLE_STORAGE_KEY);
      if (stored === null) return true;
      return stored === '1';
    }

    function setSolvableEnabled(isEnabled) {
      localStorage.setItem(SOLVABLE_STORAGE_KEY, isEnabled ? '1' : '0');
    }

    function clamp01(v) {
      return Math.max(0, Math.min(1, v));
    }

    function getVolume() {
      const stored = localStorage.getItem(VOLUME_STORAGE_KEY);
      if (stored === null) return 1;
      const v = Number.parseFloat(stored);
      return Number.isFinite(v) ? clamp01(v) : 1;
    }

    function setVolume(v01) {
      localStorage.setItem(VOLUME_STORAGE_KEY, clamp01(v01).toString());
    }

    function applyVolumeUI(v01) {
      const pct = Math.round(clamp01(v01) * 100);
      volumeSlider.value = String(pct);
      volumeLabel.textContent = `${pct}%`;
    }

    function masterVolume() {
      const v = getVolume();
      return Math.pow(v, 2);
    }

    function maybeVibrate(pattern) {
      if (!vibrationToggle.checked) return;
      if (navigator.vibrate) navigator.vibrate(pattern);
    }

    function vibrateOpen() { maybeVibrate([30]); }
    function vibrateFlag() { maybeVibrate([30, 60, 30]); }
    function vibrateBoom() { maybeVibrate([30, 40, 30, 40, 60, 60, 120, 60, 180]); }
    function vibrateClear() { maybeVibrate([20, 40, 20, 40, 60]); }
    function vibrateChordSuccess() { maybeVibrate([18, 28, 18]); }
    function vibrateChordFail() { maybeVibrate([80]); }

    // ---------- Sound engine ----------
    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // p2: More robust unlock (event-callback direct)
    function unlockAudioNow() {
      if (audioUnlocked) return;
      if (!soundToggle.checked) return;

      const ctx = getAudioContext();

      // iOS/Safari: must be called directly in user gesture callback
      try {
        if (ctx.state === 'suspended') {
          ctx.resume(); // do not await (keep in callback sync flow)
        }
      } catch (err) {
        // ignore
      }

      // Play a tiny silent sound immediately
      try {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        gain.gain.value = 0.0001;
        osc.connect(gain);
        gain.connect(ctx.destination);
        const now = ctx.currentTime;
        osc.start(now);
        osc.stop(now + 0.01);
      } catch (err) {
        // ignore
      }

      audioUnlocked = true;
    }

    // One-shot global unlock on first gesture (helps strict mobile browsers)
    document.addEventListener('pointerdown', () => unlockAudioNow(), { passive: true, once: true });
    document.addEventListener('keydown', () => unlockAudioNow(), { passive: true, once: true });

    function playTone({
      freq,
      durationMs,
      type = 'sine',
      gain = 0.2,
      attackMs = 5,
      decayMs = 40,
      freqEnd = null,
      startTime = null
    }) {
      if (!soundToggle.checked) return;
      const ctx = getAudioContext();
      const now = ctx.currentTime;
      const start = startTime ?? now;

      const vol = masterVolume();
      const g = Math.max(0.0001, gain * vol);

      const osc = ctx.createOscillator();
      const amp = ctx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, start);
      if (freqEnd) {
        osc.frequency.exponentialRampToValueAtTime(freqEnd, start + durationMs / 1000);
      }

      amp.gain.setValueAtTime(0.0001, start);
      const attack = Math.max(0.001, attackMs / 1000);
      amp.gain.exponentialRampToValueAtTime(g, start + attack);

      const endTime = start + durationMs / 1000;
      const decay = Math.max(0.001, decayMs / 1000);
      amp.gain.exponentialRampToValueAtTime(0.0001, Math.max(start + attack, endTime - decay));

      osc.connect(amp);
      amp.connect(ctx.destination);
      osc.start(start);
      osc.stop(endTime + 0.02);
    }

    function playNoise({ durationMs, gain = 0.12, startTime = null }) {
      if (!soundToggle.checked) return;
      const ctx = getAudioContext();
      const now = ctx.currentTime;
      const start = startTime ?? now;

      const vol = masterVolume();
      const g = Math.max(0.0001, gain * vol);

      const bufferSize = Math.max(1, Math.floor(ctx.sampleRate * (durationMs / 1000)));
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        const env = 1 - i / bufferSize;
        data[i] = (Math.random() * 2 - 1) * env;
      }

      const source = ctx.createBufferSource();
      const amp = ctx.createGain();
      source.buffer = buffer;

      amp.gain.setValueAtTime(g, start);
      amp.gain.exponentialRampToValueAtTime(0.0001, start + durationMs / 1000);

      source.connect(amp);
      amp.connect(ctx.destination);

      source.start(start);
      source.stop(start + durationMs / 1000 + 0.02);
    }

    function playOpen() {
      if (!soundToggle.checked) return;
      unlockAudioNow();
      playTone({ freq: 1040, durationMs: 42, type: 'triangle', gain: 0.16, attackMs: 4, decayMs: 30 });
    }

    function playFlag() {
      if (!soundToggle.checked) return;
      unlockAudioNow();
      const ctx = getAudioContext();
      const base = ctx.currentTime + 0.01;
      playTone({ freq: 920, durationMs: 40, type: 'triangle', gain: 0.16, attackMs: 4, decayMs: 28, startTime: base });
      playTone({ freq: 1200, durationMs: 40, type: 'triangle', gain: 0.16, attackMs: 4, decayMs: 28, startTime: base + 0.075 });
    }

    function playBoom() {
      if (!soundToggle.checked) return;
      unlockAudioNow();
      const ctx = getAudioContext();
      const base = ctx.currentTime + 0.01;

      playTone({
        freq: 170,
        freqEnd: 70,
        durationMs: 360,
        type: 'sine',
        gain: 0.34,
        attackMs: 4,
        decayMs: 300,
        startTime: base
      });

      playNoise({ durationMs: 160, gain: 0.18, startTime: base + 0.01 });

      playTone({
        freq: 110,
        freqEnd: 90,
        durationMs: 220,
        type: 'triangle',
        gain: 0.22,
        attackMs: 2,
        decayMs: 190,
        startTime: base + 0.08
      });
    }

    function playClear() {
      if (!soundToggle.checked) return;
      unlockAudioNow();
      const ctx = getAudioContext();
      const base = ctx.currentTime + 0.02;
      playTone({ freq: 880, durationMs: 85, type: 'sine', gain: 0.18, attackMs: 6, decayMs: 65, startTime: base });
      playTone({ freq: 1100, durationMs: 85, type: 'sine', gain: 0.18, attackMs: 6, decayMs: 65, startTime: base + 0.09 });
      playTone({ freq: 1320, durationMs: 125, type: 'sine', gain: 0.20, attackMs: 6, decayMs: 95, startTime: base + 0.18 });
    }

    function playChordSuccess() {
      if (!soundToggle.checked) return;
      unlockAudioNow();
      const ctx = getAudioContext();
      const base = ctx.currentTime + 0.01;
      playTone({ freq: 880, durationMs: 45, type: 'triangle', gain: 0.18, startTime: base });
      playTone({ freq: 1100, durationMs: 45, type: 'triangle', gain: 0.18, startTime: base + 0.012 });
      playTone({ freq: 1320, durationMs: 45, type: 'triangle', gain: 0.18, startTime: base + 0.024 });
    }

    function playChordFail() {
      if (!soundToggle.checked) return;
      unlockAudioNow();
      playTone({ freq: 220, durationMs: 55, type: 'sine', gain: 0.12, attackMs: 6, decayMs: 40 });
    }

    // ---------- Rendering / Layout ----------
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const cssW = rect.width;
      const cssH = rect.height;
      if (
        Math.abs(cssW - lastCanvasCssW) < 1 &&
        Math.abs(cssH - lastCanvasCssH) < 1 &&
        dpr === lastDpr
      ) {
        return;
      }
      lastCanvasCssW = cssW;
      lastCanvasCssH = cssH;
      lastDpr = dpr;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      fitBoard();
      requestRender();
    }

    function fitBoard() {
      const padding = 16;
      const cw = canvas.clientWidth;
      const ch = canvas.clientHeight;

      const usableW = Math.max(0, cw - padding * 2);
      const usableH = Math.max(0, ch - padding * 2);

      const widthCoeff = 1.5 * (game.W - 1) + 2;
      const heightCoeff = Math.sqrt(3) * (game.H + 0.5);

      const sizeX = usableW / widthCoeff;
      const sizeY = usableH / heightCoeff;

      renderer.size = Math.max(4, Math.min(sizeX, sizeY));

      const stepX = 1.5 * renderer.size;
      const stepY = Math.sqrt(3) * renderer.size;
      const totalW = stepX * (game.W - 1) + 2 * renderer.size;
      const totalH = stepY * (game.H + 0.5);

      renderer.originX = padding + (usableW - totalW) / 2 + renderer.size;
      renderer.originY = padding + (usableH - totalH) / 2 + renderer.size;

      camera.scale = 1;
      camera.tx = 0;
      camera.ty = 0;
    }

    function offsetToPixel(col, row) {
      const stepX = 1.5 * renderer.size;
      const stepY = Math.sqrt(3) * renderer.size;
      const x = renderer.originX + stepX * col;
      const y = renderer.originY + stepY * (row + 0.5 * (col % 2));
      return { x, y };
    }

    // p0 already: cube/axial based conversion
    function pixelToCell(x, y) {
      const stepX = 1.5 * renderer.size;
      const stepY = Math.sqrt(3) * renderer.size;
      const q = (x - renderer.originX) / stepX;
      const r = (y - renderer.originY) / stepY - q / 2;
      const cube = cubeRound(q, -q - r, r);
      const col = cube.x;
      const row = cube.z + (cube.x - (cube.x & 1)) / 2;
      if (col < 0 || col >= game.W || row < 0 || row >= game.H) return null;
      return { col, row };
    }

    function cubeRound(x, y, z) {
      let rx = Math.round(x);
      let ry = Math.round(y);
      let rz = Math.round(z);

      const dx = Math.abs(rx - x);
      const dy = Math.abs(ry - y);
      const dz = Math.abs(rz - z);

      if (dx > dy && dx > dz) {
        rx = -ry - rz;
      } else if (dy > dz) {
        ry = -rx - rz;
      } else {
        rz = -rx - ry;
      }

      return { x: rx, y: ry, z: rz };
    }

    function drawHex(x, y, size, fillStyle, strokeStyle, lineWidth = 1) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i + 60);
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }

    function drawFlag(x, y, size, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = Math.max(2, size * 0.12);
      ctx.beginPath();
      ctx.moveTo(x - size * 0.1, y + size * 0.35);
      ctx.lineTo(x - size * 0.1, y - size * 0.45);
      ctx.stroke();

      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--flag');
      ctx.beginPath();
      ctx.moveTo(x - size * 0.1, y - size * 0.45);
      ctx.lineTo(x + size * 0.55, y - size * 0.25);
      ctx.lineTo(x - size * 0.1, y - size * 0.05);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawMine(x, y, size) {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mine');
      ctx.beginPath();
      ctx.arc(x, y, size * 0.35, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#111827';
      ctx.lineWidth = size * 0.08;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = Math.PI / 4 * i;
        const inner = size * 0.5;
        const outer = size * 0.75;
        ctx.moveTo(x + inner * Math.cos(angle), y + inner * Math.sin(angle));
        ctx.lineTo(x + outer * Math.cos(angle), y + outer * Math.sin(angle));
      }
      ctx.stroke();
    }

    function drawCross(x, y, size) {
      ctx.save();
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = Math.max(2, size * 0.14);
      ctx.beginPath();
      ctx.moveTo(x - size * 0.35, y - size * 0.35);
      ctx.lineTo(x + size * 0.35, y + size * 0.35);
      ctx.moveTo(x - size * 0.35, y + size * 0.35);
      ctx.lineTo(x + size * 0.35, y - size * 0.35);
      ctx.stroke();
      ctx.restore();
    }

    function drawNumber(x, y, number) {
      const colors = {
        1: '#2563eb',
        2: '#16a34a',
        3: '#dc2626',
        4: '#7c3aed',
        5: '#b45309',
        6: '#0f172a'
      };
      ctx.fillStyle = colors[number] || '#334155';
      ctx.font = `600 ${renderer.size * 0.85}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(number.toString(), x, y + 1);
    }

    function getCss(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function requestRender() {
      renderer.needsRender = true;
    }

    // ---------- Win FX ----------
    function startWinFx() {
      const centerX = canvas.clientWidth / 2;
      const centerY = canvas.clientHeight / 2;
      const colors = ['#2563eb', '#16a34a', '#dc2626', '#f59e0b', '#7c3aed', '#0ea5e9'];
      const particles = Array.from({ length: 42 }, () => {
        const angle = Math.random() * Math.PI * 2;
        const speed = 80 + Math.random() * 140;
        return {
          x: centerX,
          y: centerY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 40,
          size: 4 + Math.random() * 4,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * Math.PI
        };
      });
      winFx = { start: performance.now(), particles };
      requestRender();
    }

    function renderWinFx() {
      if (!winFx) return;
      const now = performance.now();
      const elapsed = (now - winFx.start) / 1000;
      const duration = winFxDuration / 1000;
      if (elapsed > duration) {
        winFx = null;
        return;
      }

      const progress = elapsed / duration;
      const alpha = Math.max(0, 1 - progress);
      const centerX = canvas.clientWidth / 2;
      const centerY = canvas.clientHeight / 2;
      const popPhase = Math.min(progress / 0.25, 1);
      const popScale = 1 + Math.sin(popPhase * Math.PI) * 0.2;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#15803d';
      ctx.font = `700 ${48 * popScale}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(15, 23, 42, 0.15)';
      ctx.shadowBlur = 12;
      ctx.fillText('CLEAR!', centerX, centerY - 10);
      ctx.restore();

      const gravity = 140;
      winFx.particles.forEach(p => {
        const px = p.x + p.vx * elapsed;
        const py = p.y + p.vy * elapsed + 0.5 * gravity * elapsed * elapsed;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(px, py);
        ctx.rotate(p.rotation + elapsed * 3);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 1.4);
        ctx.restore();
      });

      ctx.save();
      ctx.globalAlpha = alpha * 0.6;
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;
      const ringRadius = 40 + 120 * progress;
      ctx.beginPath();
      ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    // ---------- Boom FX ----------
    function startBoomFx(col, row) {
      const center = offsetToPixel(col, row);
      const colors = ['#ef4444', '#f97316', '#f59e0b', '#fb7185', '#dc2626'];

      const particles = Array.from({ length: 54 }, () => {
        const angle = Math.random() * Math.PI * 2;
        const speed = 120 + Math.random() * 260;
        return {
          x: center.x,
          y: center.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 30,
          size: 3 + Math.random() * 5,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * Math.PI
        };
      });

      boomFx = {
        start: performance.now(),
        cx: center.x,
        cy: center.y,
        particles
      };

      requestRender();
    }

    function boomShakeOffset() {
      if (!boomFx) return { x: 0, y: 0 };
      const t = (performance.now() - boomFx.start) / boomFxDuration;
      if (t < 0 || t > 1) return { x: 0, y: 0 };
      const strength = (1 - t) * 10;
      return {
        x: (Math.random() * 2 - 1) * strength,
        y: (Math.random() * 2 - 1) * strength
      };
    }

    function startChordFailFx(cell) {
      chordFailFx = { col: cell.col, row: cell.row, start: performance.now() };
      requestRender();
    }

    function chordFailOffset(cell) {
      if (!chordFailFx) return 0;
      if (cell.col !== chordFailFx.col || cell.row !== chordFailFx.row) return 0;
      const t = (performance.now() - chordFailFx.start) / chordFailDuration;
      if (t < 0 || t > 1) {
        chordFailFx = null;
        return 0;
      }
      const easeOut = 1 - t;
      return Math.sin(t * Math.PI * 8) * 4 * easeOut;
    }

    function renderBoomFx() {
      if (!boomFx) return;

      const now = performance.now();
      const elapsed = (now - boomFx.start) / 1000;
      const duration = boomFxDuration / 1000;

      if (elapsed > duration) {
        boomFx = null;
        return;
      }

      const progress = elapsed / duration;
      const alpha = Math.max(0, 1 - progress);

      ctx.save();
      ctx.globalAlpha = 0.18 * alpha;
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      ctx.restore();

      const ring = 18 + 220 * progress;
      ctx.save();
      ctx.globalAlpha = 0.65 * alpha;
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(boomFx.cx, boomFx.cy, ring, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();

      const gravity = 220;
      boomFx.particles.forEach(p => {
        const px = p.x + p.vx * elapsed;
        const py = p.y + p.vy * elapsed + 0.5 * gravity * elapsed * elapsed;

        ctx.save();
        ctx.globalAlpha = 0.9 * alpha;
        ctx.translate(px, py);
        ctx.rotate(p.rotation + elapsed * 6);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 1.6);
        ctx.restore();
      });
    }

    // ---------- Main render ----------
    function render() {
      if (!renderer.needsRender) return;

      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      const shake = boomShakeOffset();

      ctx.save();
      ctx.translate(camera.tx + shake.x, camera.ty + shake.y);
      ctx.scale(camera.scale, camera.scale);

      for (let row = 0; row < game.H; row++) {
        for (let col = 0; col < game.W; col++) {
          const cell = game.cell(col, row);
          const shakeX = chordFailOffset(cell);
          const { x, y } = offsetToPixel(col, row);
          const isHover = renderer.hoverCell && renderer.hoverCell.col === col && renderer.hoverCell.row === row;
          const isPressPreview = renderer.pressPreviewCell &&
            renderer.pressPreviewCell.col === col &&
            renderer.pressPreviewCell.row === row;
          const isLongPressTarget = longPressFx &&
            longPressFx.col === col &&
            longPressFx.row === row &&
            !game.gameOver;

          const fill = cell.state === 'open' ? getCss('--tile-open') : getCss('--tile-closed');
          const stroke = getCss('--tile-outline');
          const pressScale = isLongPressTarget ? 0.96 : 1;

          drawHex(x + shakeX, y, renderer.size * 0.95 * pressScale, fill, stroke, 1);

          if (isHover && !game.gameOver && !isPressPreview) {
            ctx.save();
            ctx.globalAlpha = 0.9;
            drawHex(x + shakeX, y, renderer.size * 0.98, getCss('--highlight'), 'transparent', 0);
            ctx.restore();
          }

          if (isLongPressTarget) {
            ctx.save();
            ctx.globalAlpha = 0.25;
            drawHex(x + shakeX, y, renderer.size * 0.88, getCss('--highlight'), 'transparent', 0);
            ctx.restore();
          }

          if (isPressPreview && !game.gameOver) {
            ctx.save();
            ctx.globalAlpha = 0.4;
            drawHex(x + shakeX, y, renderer.size * 0.98, getCss('--highlight'), 'transparent', 0);
            ctx.restore();
          }

          if (cell.state === 'open') {
            if (cell.isMine && game.gameOver) {
              if (
                game.triggeredMine &&
                game.triggeredMine.col === col &&
                game.triggeredMine.row === row
              ) {
                ctx.save();
                ctx.strokeStyle = '#dc2626';
                ctx.globalAlpha = 0.9;
                ctx.lineWidth = Math.max(3, renderer.size * 0.18);
                ctx.beginPath();
                ctx.arc(x + shakeX, y, renderer.size * 0.6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
              }
              drawMine(x + shakeX, y, renderer.size);
            } else if (cell.number > 0) {
              drawNumber(x + shakeX, y, cell.number);
            }
          } else if (cell.state === 'flag') {
            drawFlag(x + shakeX, y, renderer.size);
            if (game.gameOver && cell.wrongFlag) {
              drawCross(x + shakeX, y, renderer.size);
            }
          } else if (
            isHover &&
            game.mode === 'flag' &&
            cell.state === 'closed' &&
            !game.gameOver
          ) {
            drawFlag(x + shakeX, y, renderer.size, 0.35);
          }
        }
      }

      if (longPressFx && !game.gameOver) {
        const target = offsetToPixel(longPressFx.col, longPressFx.row);
        const progress = clamp01((performance.now() - longPressFx.startMs) / LONG_PRESS_MS);
        ctx.save();
        ctx.strokeStyle = getCss('--accent');
        ctx.globalAlpha = 0.75;
        ctx.lineWidth = Math.max(2, renderer.size * 0.1);
        ctx.beginPath();
        const startAngle = -Math.PI / 2;
        ctx.arc(
          target.x,
          target.y,
          renderer.size * 0.85,
          startAngle,
          startAngle + Math.PI * 2 * progress
        );
        ctx.stroke();
        ctx.restore();
      }

      if (isKeyboardActive && renderer.keyboardCell) {
        const { x, y } = offsetToPixel(renderer.keyboardCell.col, renderer.keyboardCell.row);
        ctx.save();
        ctx.strokeStyle = getCss('--accent');
        ctx.lineWidth = Math.max(2, renderer.size * 0.16);
        drawHex(x, y, renderer.size * 1.02, 'transparent', ctx.strokeStyle, ctx.lineWidth);
        ctx.restore();
      }

      ctx.restore();

      renderBoomFx();
      renderWinFx();

      renderer.needsRender = false;
    }

    function loop() {
      if (winFx && performance.now() - winFx.start < winFxDuration) requestRender();
      if (boomFx && performance.now() - boomFx.start < boomFxDuration) requestRender();
      if (chordFailFx && performance.now() - chordFailFx.start < chordFailDuration) requestRender();
      if (longPressFx && !game.gameOver) requestRender();
      render();
      requestAnimationFrame(loop);
    }

    function updateUI() {
      const config = { W: game.W, H: game.H, density: game.density };
      const best = getBestTime(config);

      minesEl.textContent = Math.max(0, game.totalMines - game.flags).toString();
      timerEl.textContent = game.elapsed.toString();
      bestEl.textContent = best === null ? '--' : best.toString();

      if (game.gameOver) {
        if (game.win) {
          statusEl.textContent = 'You cleared the field!';
          statusEl.className = 'status win';
        } else {
          statusEl.textContent = 'Boom! Tap restart to try again.';
          statusEl.className = 'status lose';
        }
      } else {
        statusEl.textContent = 'Stay sharp. Clear all safe tiles.';
        statusEl.className = 'status';
      }

      requestRender();
    }

    // p1: richer a11y helper
    function announceCellAction(cell, actionText) {
      if (!cell) return;
      const rowLabel = cell.row + 1;
      const colLabel = cell.col + 1;
      announceMessage(`Row ${rowLabel} Column ${colLabel}. ${actionText}.`);
    }

    function announceMessage(message) {
      if (!a11yLiveEl || !message) return;
      a11yLiveEl.textContent = '';
      requestAnimationFrame(() => {
        a11yLiveEl.textContent = message;
      });
    }

    function announceFocusedCell() {
      if (!a11yLiveEl || !renderer.keyboardCell) return;
      const cell = game.cell(renderer.keyboardCell.col, renderer.keyboardCell.row);
      if (!cell) return;
      const rowLabel = cell.row + 1;
      const colLabel = cell.col + 1;
      let detail = 'closed';
      if (cell.state === 'flag') {
        detail = 'flagged';
      } else if (cell.state === 'open') {
        if (cell.isMine) {
          detail = 'open, mine';
        } else if (cell.number > 0) {
          detail = `open, ${cell.number} nearby`;
        } else {
          detail = 'open, empty';
        }
      }
      announceMessage(`Row ${rowLabel} Column ${colLabel}, ${detail}`);
    }

    function isSolvableByLogic(currentGame, startCell) {
      const state = Array.from({ length: currentGame.H }, () =>
        Array.from({ length: currentGame.W }, () => 'closed')
      );

      const openFrom = (col, row) => {
        const queue = [[col, row]];
        while (queue.length) {
          const [c, r] = queue.shift();
          if (c < 0 || c >= currentGame.W || r < 0 || r >= currentGame.H) continue;
          if (state[r][c] !== 'closed') continue;
          const cell = currentGame.cell(c, r);
          if (!cell) continue;
          if (cell.isMine) return false;
          state[r][c] = 'open';
          if (cell.number === 0) {
            currentGame.neighbors(c, r).forEach(n => {
              if (state[n.row][n.col] === 'closed') queue.push([n.col, n.row]);
            });
          }
        }
        return true;
      };

      const flagCell = (col, row) => {
        if (state[row][col] !== 'closed') return true;
        const cell = currentGame.cell(col, row);
        if (!cell || !cell.isMine) return false;
        state[row][col] = 'flag';
        return true;
      };

      if (!openFrom(startCell.col, startCell.row)) return false;

      let progress = true;
      while (progress) {
        progress = false;
        for (let row = 0; row < currentGame.H; row++) {
          for (let col = 0; col < currentGame.W; col++) {
            if (state[row][col] !== 'open') continue;
            const cell = currentGame.cell(col, row);
            if (!cell || cell.number <= 0) continue;

            const neighbors = currentGame.neighbors(col, row);
            let flagCount = 0;
            let closedCount = 0;
            neighbors.forEach(n => {
              const nState = state[n.row][n.col];
              if (nState === 'flag') flagCount += 1;
              if (nState === 'closed') closedCount += 1;
            });

            if (flagCount === cell.number && closedCount > 0) {
              for (const n of neighbors) {
                if (state[n.row][n.col] === 'closed') {
                  if (!openFrom(n.col, n.row)) return false;
                  progress = true;
                }
              }
            } else if (flagCount + closedCount === cell.number && closedCount > 0) {
              for (const n of neighbors) {
                if (state[n.row][n.col] === 'closed') {
                  if (!flagCell(n.col, n.row)) return false;
                  progress = true;
                }
              }
            }
          }
        }
      }

      for (let row = 0; row < currentGame.H; row++) {
        for (let col = 0; col < currentGame.W; col++) {
          const cell = currentGame.cell(col, row);
          if (!cell) continue;
          if (!cell.isMine && state[row][col] !== 'open') return false;
        }
      }

      return true;
    }

    function setMode(mode) {
      game.mode = mode;
      modeOpenBtn.classList.toggle('active', mode === 'open');
      modeFlagBtn.classList.toggle('active', mode === 'flag');
      // p1: announce mode change for a11y
      announceMessage(mode === 'open' ? 'Mode: Open' : 'Mode: Flag');
      requestRender();
    }

    function handleAction(cell, actionMode) {
      if (!cell) return;
      if (game.gameOver) return;
      if (actionMode === 'flag') {
        game.toggleFlag(cell);
      } else if (cell.state === 'open' && cell.number > 0) {
        const result = game.chord(cell);
        if (result.flagMatch) {
          if (result.openedCount > 0 && !game.gameOver) {
            vibrateChordSuccess();
            playChordSuccess();
            announceMessage('Chord opened.');
          }
        } else {
          vibrateChordFail();
          playChordFail();
          startChordFailFx(cell);
          announceMessage('Chord failed.');
        }
      } else {
        game.openCell(cell);
      }
      updateUI();
    }

    function getCanvasPoint(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }

    function pointerToCell(event) {
      const point = getCanvasPoint(event);
      const wx = (point.x - camera.tx) / camera.scale;
      const wy = (point.y - camera.ty) / camera.scale;
      const hit = pixelToCell(wx, wy);
      if (!hit) return null;
      return game.cell(hit.col, hit.row);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function ensureKeyboardCell() {
      if (!renderer.keyboardCell) {
        renderer.keyboardCell = {
          col: Math.floor(game.W / 2),
          row: Math.floor(game.H / 2)
        };
      }
      renderer.keyboardCell.col = clamp(renderer.keyboardCell.col, 0, game.W - 1);
      renderer.keyboardCell.row = clamp(renderer.keyboardCell.row, 0, game.H - 1);
    }

    function zoomAt(point, scaleFactor) {
      const worldX = (point.x - camera.tx) / camera.scale;
      const worldY = (point.y - camera.ty) / camera.scale;
      const nextScale = clamp(camera.scale * scaleFactor, 0.6, 3);
      camera.scale = nextScale;
      camera.tx = point.x - worldX * camera.scale;
      camera.ty = point.y - worldY * camera.scale;
      requestRender();
    }

    function startGesture() {
      if (pointerState.pointers.size < 2) return;
      const entries = Array.from(pointerState.pointers.entries()).slice(0, 2);
      const [aId, a] = entries[0];
      const [bId, b] = entries[1];

      pointerState.gestureActive = true;
      pointerState.gesturePointerIds = new Set([aId, bId]);
      pointerState.startDist = Math.hypot(a.x - b.x, a.y - b.y) || 1;
      pointerState.startScale = camera.scale;
      pointerState.startMid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      pointerState.worldMidStart = {
        x: (pointerState.startMid.x - camera.tx) / camera.scale,
        y: (pointerState.startMid.y - camera.ty) / camera.scale
      };
      pointerState.startTx = camera.tx;
      pointerState.startTy = camera.ty;
    }

    function updateGesture() {
      if (!pointerState.gestureActive || pointerState.pointers.size < 2) return;

      const entries = Array.from(pointerState.pointers.entries()).filter(([id]) =>
        pointerState.gesturePointerIds.has(id)
      );
      if (entries.length < 2) return;

      const a = entries[0][1];
      const b = entries[1][1];
      const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      const dist = Math.hypot(a.x - b.x, a.y - b.y) || 1;

      const scaleNew = clamp(pointerState.startScale * (dist / pointerState.startDist), 0.6, 3);
      camera.scale = scaleNew;
      camera.tx = mid.x - pointerState.worldMidStart.x * camera.scale;
      camera.ty = mid.y - pointerState.worldMidStart.y * camera.scale;

      if (Math.hypot(mid.x - pointerState.startMid.x, mid.y - pointerState.startMid.y) > 6) {
        pointerState.suppressTap = true;
      }
      requestRender();
    }

    function endGestureIfNeeded() {
      if (pointerState.pointers.size < 2) {
        pointerState.gestureActive = false;
        pointerState.gesturePointerIds.clear();
      }
    }

    function handleDoubleTap(point, event, tapDidAction) {
      if (event.pointerType === 'mouse') return false;
      if (tapDidAction) {
        pointerState.lastTapTime = 0;
        pointerState.lastTapPos = null;
        return false;
      }
      const now = performance.now();

      if (pointerState.lastTapTime && now - pointerState.lastTapTime < 280) {
        const prev = pointerState.lastTapPos;
        if (prev) {
          const dist = Math.hypot(point.x - prev.x, point.y - prev.y);
          if (dist <= 18) {
            fitBoard();
            requestRender();
            renderer.hoverCell = null;
            pointerState.lastTapTime = 0;
            pointerState.lastTapPos = null;
            return true;
          }
        }
      }

      pointerState.lastTapTime = now;
      pointerState.lastTapPos = point;
      return false;
    }

    function cancelLongPress() {
      if (pointerState.longPressTimerId) {
        clearTimeout(pointerState.longPressTimerId);
        pointerState.longPressTimerId = null;
      }
      pointerState.longPressPointerId = null;
      pointerState.longPressStart = null;
      pointerState.longPressCell = null;
      pointerState.longPressTriggered = false;
      if (longPressFx) {
        longPressFx = null;
        requestRender();
      }
    }

    function scheduleLongPress(pointerId, startPoint, cell) {
      cancelLongPress();
      pointerState.longPressPointerId = pointerId;
      pointerState.longPressStart = startPoint;
      pointerState.longPressCell = cell;
      pointerState.longPressTriggered = false;
      longPressFx = { startMs: performance.now(), col: cell.col, row: cell.row, pointerId };
      requestRender();
      pointerState.longPressTimerId = setTimeout(() => {
        if (
          pointerState.pointers.size !== 1 ||
          !pointerState.pointers.has(pointerId) ||
          pointerState.gestureActive ||
          pointerState.suppressTap ||
          !pointerState.longPressCell ||
          !['closed', 'flag'].includes(pointerState.longPressCell.state)
        ) {
          return;
        }
        pointerState.longPressTriggered = true;
        pointerState.suppressTap = true;
        renderer.pressPreviewCell = null;
        pointerState.pressPreviewId = null;
        longPressFx = null;
        handleAction(pointerState.longPressCell, 'flag');
        requestRender();
      }, LONG_PRESS_MS);
    }

    canvas.addEventListener('pointerdown', event => {
      if (event.pointerType === 'mouse' && event.button === 2) return;

      // p2: unlock directly in callback
      unlockAudioNow();

      canvas.setPointerCapture(event.pointerId);
      const point = getCanvasPoint(event);

      if (pointerState.pointers.size === 0) {
        pointerState.suppressTap = false;
        pointerState.startPoints.clear();
      }

      pointerState.pointers.set(event.pointerId, { x: point.x, y: point.y });
      pointerState.startPoints.set(event.pointerId, { x: point.x, y: point.y });

      if (pointerState.pointers.size === 2) {
        pointerState.suppressTap = true;
        renderer.pressPreviewCell = null;
        pointerState.pressPreviewId = null;
        cancelLongPress();
        startGesture();
      }

      if (!pointerState.gestureActive) {
        const cell = pointerToCell(event);
        if (event.pointerType === 'mouse') {
          renderer.hoverCell = cell;
        } else {
          renderer.hoverCell = null;
          if (cell && !pointerState.gestureActive) {
            renderer.pressPreviewCell = cell;
            pointerState.pressPreviewId = event.pointerId;
          }
        }
        if (
          event.pointerType !== 'mouse' &&
          pointerState.pointers.size === 1 &&
          !pointerState.gestureActive &&
          cell
        ) {
          scheduleLongPress(event.pointerId, point, cell);
        } else {
          cancelLongPress();
        }
        requestRender();
      }
    });

    canvas.addEventListener('pointermove', event => {
      const point = getCanvasPoint(event);

      if (pointerState.pointers.has(event.pointerId)) {
        pointerState.pointers.set(event.pointerId, { x: point.x, y: point.y });
        const startPoint = pointerState.startPoints.get(event.pointerId);
        if (startPoint) {
          const moved = Math.hypot(point.x - startPoint.x, point.y - startPoint.y);
          if (moved > 6) {
            pointerState.suppressTap = true;
            if (pointerState.pressPreviewId === event.pointerId) {
              renderer.pressPreviewCell = null;
              pointerState.pressPreviewId = null;
            }
          }
        }
      }

      if (pointerState.gestureActive) {
        cancelLongPress();
        updateGesture();
        return;
      }

      if (
        event.pointerType !== 'mouse' &&
        pointerState.longPressPointerId === event.pointerId &&
        pointerState.longPressStart
      ) {
        const moved = Math.hypot(
          point.x - pointerState.longPressStart.x,
          point.y - pointerState.longPressStart.y
        );
        if (moved > LONG_PRESS_MOVE_PX) {
          cancelLongPress();
        }
      }

      if (event.pointerType === 'mouse') {
        const cell = pointerToCell(event);
        if (
          renderer.hoverCell &&
          cell &&
          renderer.hoverCell.col === cell.col &&
          renderer.hoverCell.row === cell.row
        ) return;

        renderer.hoverCell = cell;
        requestRender();
      }
    });

    canvas.addEventListener('pointerleave', () => {
      renderer.hoverCell = null;
      renderer.pressPreviewCell = null;
      pointerState.pressPreviewId = null;
      cancelLongPress();
      requestRender();
    });

    canvas.addEventListener('pointerup', event => {
      const point = getCanvasPoint(event);
      const cell = pointerToCell(event);
      let tapDidAction = false;
      if (pointerState.longPressPointerId === event.pointerId) {
        if (pointerState.longPressTimerId) {
          clearTimeout(pointerState.longPressTimerId);
          pointerState.longPressTimerId = null;
        }
        if (pointerState.longPressTriggered) {
          pointerState.pointers.delete(event.pointerId);
          pointerState.startPoints.delete(event.pointerId);
          if (pointerState.pressPreviewId === event.pointerId) {
            renderer.pressPreviewCell = null;
            pointerState.pressPreviewId = null;
          }
          endGestureIfNeeded();
          if (pointerState.pointers.size === 0) {
            pointerState.suppressTap = false;
            pointerState.startPoints.clear();
          }
          cancelLongPress();
          requestRender();
          return;
        }
        cancelLongPress();
      }
      const wasGesturePointer = pointerState.gesturePointerIds.has(event.pointerId);

      pointerState.pointers.delete(event.pointerId);
      pointerState.startPoints.delete(event.pointerId);
      if (pointerState.pressPreviewId === event.pointerId) {
        renderer.pressPreviewCell = null;
        pointerState.pressPreviewId = null;
      }

      if (pointerState.gestureActive) {
        endGestureIfNeeded();
        if (wasGesturePointer) return;
      }

      if (pointerState.suppressTap) {
        if (pointerState.pointers.size === 0) {
          pointerState.suppressTap = false;
          pointerState.startPoints.clear();
        }
        return;
      }

      if (event.pointerType === 'mouse') {
        renderer.hoverCell = cell;
      }

      if (cell) {
        if (event.pointerType === 'mouse' && event.button === 2) {
          tapDidAction = true;
          handleAction(cell, 'flag');
        } else {
          tapDidAction = true;
          handleAction(cell, game.mode);
        }
      }

      handleDoubleTap(point, event, tapDidAction);
      requestRender();
    });

    canvas.addEventListener('pointercancel', event => {
      pointerState.pointers.delete(event.pointerId);
      pointerState.startPoints.delete(event.pointerId);
      if (pointerState.pressPreviewId === event.pointerId) {
        renderer.pressPreviewCell = null;
        pointerState.pressPreviewId = null;
      }
      cancelLongPress();
      endGestureIfNeeded();
    });

    canvas.addEventListener('contextmenu', event => event.preventDefault());

    canvas.addEventListener('focus', () => {
      isKeyboardActive = true;
      ensureKeyboardCell();
      announceFocusedCell();
      requestRender();
    });

    canvas.addEventListener('blur', () => {
      isKeyboardActive = false;
      requestRender();
    });

    canvas.addEventListener('keydown', event => {
      if (!isKeyboardActive) return;
      ensureKeyboardCell();
      const key = event.key;
      const lower = key.toLowerCase();
      let handled = false;

      if (key === 'ArrowLeft') {
        renderer.keyboardCell.col = clamp(renderer.keyboardCell.col - 1, 0, game.W - 1);
        handled = true;
      } else if (key === 'ArrowRight') {
        renderer.keyboardCell.col = clamp(renderer.keyboardCell.col + 1, 0, game.W - 1);
        handled = true;
      } else if (key === 'ArrowUp') {
        renderer.keyboardCell.row = clamp(renderer.keyboardCell.row - 1, 0, game.H - 1);
        handled = true;
      } else if (key === 'ArrowDown') {
        renderer.keyboardCell.row = clamp(renderer.keyboardCell.row + 1, 0, game.H - 1);
        handled = true;
      } else if (key === 'Enter' || key === ' ') {
        const cell = game.cell(renderer.keyboardCell.col, renderer.keyboardCell.row);
        if (cell) {
          unlockAudioNow();
          handleAction(cell, game.mode);
        }
        handled = true;
      } else if (lower === 'f') {
        const cell = game.cell(renderer.keyboardCell.col, renderer.keyboardCell.row);
        if (cell) {
          unlockAudioNow();
          handleAction(cell, 'flag');
        }
        handled = true;
      } else if (lower === 'm') {
        unlockAudioNow();
        setMode(game.mode === 'open' ? 'flag' : 'open');
        handled = true;
      } else if (lower === 'r') {
        unlockAudioNow();
        resetResetBestPrompt();
        game.stopTimer();
        game.reset(getConfigFromControls());
        setMode('open');
        resizeCanvas();
        ensureKeyboardCell();
        handled = true;
      } else if (key === '+' || key === '=') {
        zoomAt({ x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 }, 1.1);
        handled = true;
      } else if (key === '-') {
        zoomAt({ x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 }, 1 / 1.1);
        handled = true;
      } else if (key === '0') {
        fitBoard();
        requestRender();
        handled = true;
      }

      if (handled) {
        event.preventDefault();
        announceFocusedCell();
        requestRender();
      }
    });

    modeOpenBtn.addEventListener('click', () => {
      unlockAudioNow();
      setMode('open');
    });
    modeFlagBtn.addEventListener('click', () => {
      unlockAudioNow();
      setMode('flag');
    });

    restartBtn.addEventListener('click', () => {
      unlockAudioNow();
      resetResetBestPrompt();
      game.stopTimer();
      game.reset(getConfigFromControls());
      setMode('open');
      resizeCanvas();
      ensureKeyboardCell();
      announceMessage('Restarted.');
    });

    resetBestBtn.addEventListener('click', () => {
      unlockAudioNow();
      if (resetBestState.armed) {
        const config = getConfigFromControls();
        localStorage.removeItem(storageKey(config));
        resetResetBestPrompt();
        updateUI();
        announceMessage('Best time reset.');
        return;
      }
      resetBestState.armed = true;
      resetBestBtn.textContent = 'Tap again to confirm';
      announceMessage('Tap again to confirm best reset.');
      if (resetBestState.timeoutId) clearTimeout(resetBestState.timeoutId);
      resetBestState.timeoutId = setTimeout(() => resetResetBestPrompt(), 3000);
    });

    function handleConfigChange() {
      resetResetBestPrompt();
      game.stopTimer();
      game.reset(getConfigFromControls());
      setMode('open');
      resizeCanvas();
      ensureKeyboardCell();
      announceMessage('New game settings applied.');
    }

    sizeSelect.addEventListener('change', handleConfigChange);
    densitySelect.addEventListener('change', handleConfigChange);

    vibrationToggle.checked = getVibrationEnabled();
    vibrationToggle.addEventListener('change', () => setVibrationEnabled(vibrationToggle.checked));

    soundToggle.checked = getSoundEnabled();
    soundToggle.addEventListener('change', () => {
      setSoundEnabled(soundToggle.checked);
      // allow unlocking again when turned on
      if (soundToggle.checked) {
        audioUnlocked = false;
        announceMessage('Sound on.');
      } else {
        announceMessage('Sound off.');
      }
    });

    solvableToggle.checked = getSolvableEnabled();
    solvableToggle.addEventListener('change', () => {
      setSolvableEnabled(solvableToggle.checked);
      announceMessage(solvableToggle.checked ? 'Solvable on.' : 'Solvable off.');
    });

    applyVolumeUI(getVolume());
    volumeSlider.addEventListener('input', () => {
      const v01 = Number(volumeSlider.value) / 100;
      setVolume(v01);
      applyVolumeUI(v01);
    });

    window.addEventListener('resize', resizeCanvas);

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function resetResetBestPrompt() {
      resetBestState.armed = false;
      resetBestBtn.textContent = resetBestState.defaultLabel;
      if (resetBestState.timeoutId) {
        clearTimeout(resetBestState.timeoutId);
        resetBestState.timeoutId = null;
      }
    }

    resizeCanvas();
    updateUI();
    loop();
  </script>
</body>
</html>
